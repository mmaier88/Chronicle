This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/src/components/**/*.tsx, app/src/app/**/*.tsx, app/src/app/**/*.ts, app/tailwind.config.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  src/
    app/
      (auth)/
        callback/
          route.ts
        invite/
          [token]/
            page.tsx
        login/
          page.tsx
        signup/
          page.tsx
      (dashboard)/
        automations/
          page.tsx
        dashboard/
          page.tsx
        documents/
          [id]/
            page.tsx
        knowledge/
          page.tsx
        search/
          page.tsx
        sources/
          import/
            page.tsx
          page.tsx
        workspace/
          [id]/
            project/
              [projectId]/
                document/
                  new/
                    page.tsx
                page.tsx
              new/
                page.tsx
            settings/
              page.tsx
            page.tsx
          new/
            page.tsx
        layout.tsx
      api/
        agents/
          [id]/
            route.ts
          disagreements/
            route.ts
          execute/
            route.ts
          executions/
            [id]/
              route.ts
            route.ts
          pipelines/
            route.ts
          route.ts
        ai/
          edit/
            route.ts
        ask/
          route.ts
        auth/
          signout/
            route.ts
        citations/
          verify/
            route.ts
        claims/
          extract/
            route.ts
        diff/
          semantic/
            route.ts
        documents/
          [id]/
            branches/
              [branchId]/
                diff/
                  route.ts
                merge/
                  route.ts
                route.ts
              route.ts
            comments/
              [commentId]/
                route.ts
              route.ts
          route.ts
        evidence/
          find/
            route.ts
        guardrails/
          analyze/
            route.ts
          fact-check/
            route.ts
          suggest-citations/
            route.ts
          writing/
            route.ts
        import/
          arxiv/
            route.ts
          bibtex/
            route.ts
          doi/
            route.ts
          web/
            route.ts
        invitations/
          [token]/
            accept/
              route.ts
        knowledge/
          contradictions/
            route.ts
          entities/
            [id]/
              route.ts
            route.ts
          extract/
            route.ts
          graph/
            route.ts
          query/
            route.ts
          relationships/
            route.ts
        notifications/
          preferences/
            route.ts
          route.ts
        projects/
          route.ts
        research/
          arguments/
            [id]/
              nodes/
                route.ts
            route.ts
          fallacies/
            route.ts
          hypotheses/
            route.ts
          literature-review/
            [id]/
              screen/
                route.ts
              sources/
                route.ts
              route.ts
            route.ts
          templates/
            route.ts
          writing/
            [id]/
              feedback/
                route.ts
            route.ts
        safety/
          assess/
            route.ts
        search/
          saved/
            route.ts
          route.ts
        sources/
          [id]/
            process/
              route.ts
          upload/
            route.ts
          route.ts
        workflows/
          execute/
            route.ts
          route.ts
        workspaces/
          [id]/
            activity/
              route.ts
            invitations/
              route.ts
            members/
              route.ts
            summary/
              route.ts
            route.ts
          route.ts
      layout.tsx
      page.tsx
    components/
      arguments/
        ArgumentPanel.tsx
      ask/
        AskProject.tsx
      citations/
        CitationExportPanel.tsx
        CitationPanel.tsx
      collaboration/
        CollaborativeEditor.tsx
        CollaboratorPresence.tsx
      diff/
        SemanticDiffPanel.tsx
      editor/
        extensions/
          SlashCommand.tsx
        CitationDialog.tsx
        Editor.tsx
        EditorToolbar.tsx
      evidence/
        EvidencePanel.tsx
      guardrails/
        GuardrailsPanel.tsx
      help/
        KeyboardShortcutsHelp.tsx
      knowledge/
        EntityPanel.tsx
        KnowledgeGraph.tsx
      pdf/
        PDFViewer.tsx
        PDFViewerModal.tsx
      safety/
        SafetyPanel.tsx
      workflows/
        WorkflowPanel.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/src/app/(auth)/callback/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  const redirect = searchParams.get('redirect') || '/dashboard'

  if (code) {
    const supabase = await createClient()
    const { error } = await supabase.auth.exchangeCodeForSession(code)

    if (!error) {
      return NextResponse.redirect(`${origin}${redirect}`)
    }
  }

  // Return the user to an error page with instructions
  return NextResponse.redirect(`${origin}/login?error=auth_callback_error`)
}
</file>

<file path="app/src/app/(auth)/invite/[token]/page.tsx">
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useRouter, useParams } from 'next/navigation'
import Link from 'next/link'

interface InvitationData {
  email: string
  role: string
  expires_at: string
  workspace: {
    id: string
    name: string
    slug: string
  }
}

export default function AcceptInvitationPage() {
  const router = useRouter()
  const params = useParams()
  const token = params.token as string

  const [invitation, setInvitation] = useState<InvitationData | null>(null)
  const [loading, setLoading] = useState(true)
  const [accepting, setAccepting] = useState(false)
  const [error, setError] = useState('')
  const [needsAuth, setNeedsAuth] = useState(false)

  const fetchInvitation = useCallback(async () => {
    try {
      const res = await fetch(`/api/invitations/${token}/accept`)
      const data = await res.json()

      if (!res.ok) {
        throw new Error(data.error || 'Invalid invitation')
      }

      setInvitation(data.invitation)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load invitation')
    } finally {
      setLoading(false)
    }
  }, [token])

  useEffect(() => {
    fetchInvitation()
  }, [fetchInvitation])

  const handleAccept = async () => {
    setAccepting(true)
    setError('')

    try {
      const res = await fetch(`/api/invitations/${token}/accept`, {
        method: 'POST',
      })

      const data = await res.json()

      if (res.status === 401) {
        // User needs to sign in
        setNeedsAuth(true)
        setAccepting(false)
        return
      }

      if (!res.ok) {
        throw new Error(data.error || 'Failed to accept invitation')
      }

      // Redirect to workspace
      router.push(`/workspace/${data.workspace.id}`)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to accept invitation')
      setAccepting(false)
    }
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
      </div>
    )
  }

  if (error && !invitation) {
    return (
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center p-4">
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8 max-w-md w-full text-center">
          <div className="w-16 h-16 bg-red-100 dark:bg-red-900/30 rounded-full flex items-center justify-center mx-auto mb-4">
            <svg className="w-8 h-8 text-red-600 dark:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </div>
          <h1 className="text-xl font-bold text-gray-900 dark:text-white mb-2">
            Invalid Invitation
          </h1>
          <p className="text-gray-600 dark:text-gray-400 mb-6">
            {error}
          </p>
          <Link
            href="/dashboard"
            className="inline-flex items-center px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
          >
            Go to Dashboard
          </Link>
        </div>
      </div>
    )
  }

  if (needsAuth) {
    return (
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center p-4">
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8 max-w-md w-full text-center">
          <div className="w-16 h-16 bg-blue-100 dark:bg-blue-900/30 rounded-full flex items-center justify-center mx-auto mb-4">
            <svg className="w-8 h-8 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
            </svg>
          </div>
          <h1 className="text-xl font-bold text-gray-900 dark:text-white mb-2">
            Sign In Required
          </h1>
          <p className="text-gray-600 dark:text-gray-400 mb-6">
            Please sign in or create an account to accept this invitation to join{' '}
            <strong>{invitation?.workspace.name}</strong>.
          </p>
          <div className="space-y-3">
            <Link
              href={`/login?redirect=/invite/${token}`}
              className="block w-full px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
            >
              Sign In
            </Link>
            <Link
              href={`/signup?redirect=/invite/${token}`}
              className="block w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700"
            >
              Create Account
            </Link>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8 max-w-md w-full text-center">
        <div className="w-16 h-16 bg-green-100 dark:bg-green-900/30 rounded-full flex items-center justify-center mx-auto mb-4">
          <svg className="w-8 h-8 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M18 9v3m0 0v3m0-3h3m-3 0h-3m-2-5a4 4 0 11-8 0 4 4 0 018 0zM3 20a6 6 0 0112 0v1H3v-1z" />
          </svg>
        </div>

        <h1 className="text-xl font-bold text-gray-900 dark:text-white mb-2">
          You&apos;ve Been Invited!
        </h1>

        <p className="text-gray-600 dark:text-gray-400 mb-6">
          You&apos;ve been invited to join <strong className="text-gray-900 dark:text-white">{invitation?.workspace.name}</strong> as a{' '}
          <strong className="text-gray-900 dark:text-white capitalize">{invitation?.role}</strong>.
        </p>

        {error && (
          <div className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-600 dark:text-red-400 text-sm mb-4">
            {error}
          </div>
        )}

        <div className="space-y-3">
          <button
            onClick={handleAccept}
            disabled={accepting}
            className="w-full px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50"
          >
            {accepting ? 'Joining...' : 'Accept Invitation'}
          </button>
          <Link
            href="/dashboard"
            className="block w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700"
          >
            Decline
          </Link>
        </div>

        <p className="text-xs text-gray-500 dark:text-gray-400 mt-4">
          This invitation expires on {invitation && new Date(invitation.expires_at).toLocaleDateString()}
        </p>
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/automations/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { createClient } from '@/lib/supabase/client'
import Link from 'next/link'

interface Workflow {
  id: string
  projectId: string
  workflowType: string
  name: string
  description: string
  schedule: string
  enabled: boolean
  lastRun?: string
  nextRun?: string
}

interface Project {
  id: string
  name: string
  workspaceId: string
}

export default function AutomationsPage() {
  const [projects, setProjects] = useState<Project[]>([])
  const [selectedProject, setSelectedProject] = useState<string | null>(null)
  const [workflows, setWorkflows] = useState<Workflow[]>([])
  const [loading, setLoading] = useState(true)
  const [workflowsLoading, setWorkflowsLoading] = useState(false)
  const [updating, setUpdating] = useState<string | null>(null)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    loadProjects()
  }, [])

  useEffect(() => {
    if (selectedProject) {
      loadWorkflows(selectedProject)
    }
  }, [selectedProject])

  const loadProjects = async () => {
    const supabase = createClient()

    // Try to load projects, or use demo project
    const { data, error: projectsError } = await supabase
      .from('projects')
      .select('id, name, workspace_id')
      .order('created_at', { ascending: false })

    if (projectsError || !data?.length) {
      // Use demo project for testing
      setProjects([{ id: 'demo-project', name: 'Demo Project', workspaceId: 'demo' }])
      setSelectedProject('demo-project')
    } else {
      setProjects(data.map(p => ({ id: p.id, name: p.name, workspaceId: p.workspace_id })))
      setSelectedProject(data[0].id)
    }

    setLoading(false)
  }

  const loadWorkflows = async (projectId: string) => {
    setWorkflowsLoading(true)
    setError(null)

    try {
      const response = await fetch(`/api/workflows?projectId=${projectId}`)
      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to load workflows')
      }

      setWorkflows(data.workflows)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load workflows')
    } finally {
      setWorkflowsLoading(false)
    }
  }

  const toggleWorkflow = async (workflow: Workflow) => {
    if (!selectedProject) return
    setUpdating(workflow.id)

    try {
      const response = await fetch('/api/workflows', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          projectId: selectedProject,
          workflowType: workflow.workflowType,
          enabled: !workflow.enabled
        })
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to update workflow')
      }

      setWorkflows(prev =>
        prev.map(w =>
          w.workflowType === workflow.workflowType
            ? { ...w, enabled: !workflow.enabled }
            : w
        )
      )
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update workflow')
    } finally {
      setUpdating(null)
    }
  }

  const getScheduleIcon = (schedule: string) => {
    switch (schedule) {
      case 'daily':
        return (
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
          </svg>
        )
      case 'weekly':
        return (
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
          </svg>
        )
      default:
        return (
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        )
    }
  }

  const getWorkflowIcon = (type: string) => {
    switch (type) {
      case 'daily_index_refresh':
        return (
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
        )
      case 'weekly_exec_summary':
        return (
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
        )
      case 'weekly_inconsistency_scan':
        return (
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
          </svg>
        )
      case 'weekly_citation_check':
        return (
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" />
          </svg>
        )
      case 'weekly_risk_assessment':
        return (
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
          </svg>
        )
      default:
        return (
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
          </svg>
        )
    }
  }

  const formatDate = (dateString?: string) => {
    if (!dateString) return null
    const date = new Date(dateString)
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    })
  }

  const enabledCount = workflows.filter(w => w.enabled).length

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <div className="text-gray-500 dark:text-gray-400">Loading...</div>
      </div>
    )
  }

  return (
    <div className="space-y-8">
      {/* Header */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Automations
          </h1>
          <p className="text-gray-600 dark:text-gray-400 mt-1">
            Configure automated workflows to keep your research up-to-date
          </p>
        </div>
        <Link
          href="/dashboard"
          className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </Link>
      </div>

      {/* Project Selector */}
      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4">
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Select Project
        </label>
        <select
          value={selectedProject || ''}
          onChange={(e) => setSelectedProject(e.target.value)}
          className="w-full md:w-64 px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg text-gray-900 dark:text-white focus:ring-2 focus:ring-purple-500 focus:border-transparent"
        >
          {projects.map((project) => (
            <option key={project.id} value={project.id}>
              {project.name}
            </option>
          ))}
        </select>
      </div>

      {/* Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-purple-100 dark:bg-purple-900/30 rounded-lg">
              <svg className="w-5 h-5 text-purple-600 dark:text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
              </svg>
            </div>
            <div>
              <div className="text-2xl font-bold text-gray-900 dark:text-white">
                {enabledCount}
              </div>
              <div className="text-sm text-gray-500 dark:text-gray-400">
                Active Workflows
              </div>
            </div>
          </div>
        </div>
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-blue-100 dark:bg-blue-900/30 rounded-lg">
              <svg className="w-5 h-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div>
              <div className="text-2xl font-bold text-gray-900 dark:text-white">
                {workflows.length}
              </div>
              <div className="text-sm text-gray-500 dark:text-gray-400">
                Available Workflows
              </div>
            </div>
          </div>
        </div>
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-green-100 dark:bg-green-900/30 rounded-lg">
              <svg className="w-5 h-5 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div>
              <div className="text-2xl font-bold text-gray-900 dark:text-white">
                0
              </div>
              <div className="text-sm text-gray-500 dark:text-gray-400">
                Runs Today
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Error */}
      {error && (
        <div className="p-4 text-sm text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900/20 rounded-lg">
          {error}
        </div>
      )}

      {/* Workflows Grid */}
      <div>
        <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
          Workflows
        </h2>

        {workflowsLoading ? (
          <div className="flex items-center justify-center py-12">
            <svg className="w-6 h-6 animate-spin text-purple-600" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
            </svg>
          </div>
        ) : (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            {workflows.map((workflow) => (
              <div
                key={workflow.id}
                className={`p-6 rounded-lg border transition-all ${
                  workflow.enabled
                    ? 'bg-purple-50 dark:bg-purple-900/20 border-purple-200 dark:border-purple-700'
                    : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700'
                }`}
              >
                <div className="flex items-start justify-between">
                  <div className="flex items-start gap-4">
                    <div className={`p-3 rounded-lg ${
                      workflow.enabled
                        ? 'bg-purple-100 dark:bg-purple-800 text-purple-600 dark:text-purple-400'
                        : 'bg-gray-100 dark:bg-gray-700 text-gray-500 dark:text-gray-400'
                    }`}>
                      {getWorkflowIcon(workflow.workflowType)}
                    </div>
                    <div className="flex-1">
                      <h3 className="font-semibold text-gray-900 dark:text-white">
                        {workflow.name}
                      </h3>
                      <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                        {workflow.description}
                      </p>
                      <div className="flex items-center gap-4 mt-3">
                        <span className="flex items-center gap-1.5 text-sm text-gray-500 dark:text-gray-400">
                          {getScheduleIcon(workflow.schedule)}
                          <span className="capitalize">{workflow.schedule}</span>
                        </span>
                        {workflow.lastRun && (
                          <span className="text-sm text-gray-400 dark:text-gray-500">
                            Last: {formatDate(workflow.lastRun)}
                          </span>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* Toggle */}
                  <button
                    onClick={() => toggleWorkflow(workflow)}
                    disabled={updating === workflow.id}
                    className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors flex-shrink-0 ${
                      workflow.enabled
                        ? 'bg-purple-600'
                        : 'bg-gray-300 dark:bg-gray-600'
                    } ${updating === workflow.id ? 'opacity-50' : ''}`}
                  >
                    <span
                      className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                        workflow.enabled ? 'translate-x-6' : 'translate-x-1'
                      }`}
                    />
                  </button>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Info Section */}
      <div className="bg-gradient-to-r from-purple-50 to-blue-50 dark:from-purple-900/20 dark:to-blue-900/20 rounded-lg p-6">
        <h3 className="font-semibold text-gray-900 dark:text-white mb-3">
          How Automations Work
        </h3>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
          <div className="flex items-start gap-3">
            <div className="w-8 h-8 bg-purple-100 dark:bg-purple-800 rounded-full flex items-center justify-center text-purple-600 dark:text-purple-400 font-bold">
              1
            </div>
            <div>
              <div className="font-medium text-gray-900 dark:text-white">Enable Workflows</div>
              <div className="text-gray-500 dark:text-gray-400">Toggle on the workflows you want to automate</div>
            </div>
          </div>
          <div className="flex items-start gap-3">
            <div className="w-8 h-8 bg-purple-100 dark:bg-purple-800 rounded-full flex items-center justify-center text-purple-600 dark:text-purple-400 font-bold">
              2
            </div>
            <div>
              <div className="font-medium text-gray-900 dark:text-white">Scheduled Runs</div>
              <div className="text-gray-500 dark:text-gray-400">Workflows run automatically on their schedule</div>
            </div>
          </div>
          <div className="flex items-start gap-3">
            <div className="w-8 h-8 bg-purple-100 dark:bg-purple-800 rounded-full flex items-center justify-center text-purple-600 dark:text-purple-400 font-bold">
              3
            </div>
            <div>
              <div className="font-medium text-gray-900 dark:text-white">Get Notified</div>
              <div className="text-gray-500 dark:text-gray-400">Results appear in your notifications</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/knowledge/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useSearchParams } from 'next/navigation'
import { createClient } from '@/lib/supabase/client'
import { KnowledgeGraph } from '@/components/knowledge/KnowledgeGraph'
import { EntityPanel } from '@/components/knowledge/EntityPanel'
import { useKnowledgeGraph } from '@/hooks/useKnowledgeGraph'

interface Workspace {
  id: string
  name: string
}

export default function KnowledgePage() {
  const searchParams = useSearchParams()
  const workspaceIdParam = searchParams.get('workspace')

  const [workspaces, setWorkspaces] = useState<Workspace[]>([])
  const [selectedWorkspaceId, setSelectedWorkspaceId] = useState<string | null>(workspaceIdParam)
  const [selectedEntityId, setSelectedEntityId] = useState<string | null>(null)
  const [query, setQuery] = useState('')
  const [queryResult, setQueryResult] = useState<{
    answer: string
    relevant_entities: string[]
    confidence: string
    gaps: string[]
  } | null>(null)
  const [queryLoading, setQueryLoading] = useState(false)

  const { listContradictions } = useKnowledgeGraph(selectedWorkspaceId || '')
  const [contradictions, setContradictions] = useState<Array<{
    id: string
    description: string
    severity: string
    status: string
  }>>([])

  // Load workspaces
  useEffect(() => {
    async function loadWorkspaces() {
      const supabase = createClient()
      const { data: memberships } = await supabase
        .from('workspace_members')
        .select('workspace:workspaces(id, name)')

      if (memberships) {
        const ws: Workspace[] = []
        for (const m of memberships) {
          const workspace = m.workspace as unknown
          if (workspace && typeof workspace === 'object' && 'id' in workspace && 'name' in workspace) {
            ws.push(workspace as Workspace)
          }
        }
        setWorkspaces(ws)
        if (!selectedWorkspaceId && ws.length > 0) {
          setSelectedWorkspaceId(ws[0].id)
        }
      }
    }
    loadWorkspaces()
  }, [selectedWorkspaceId])

  // Load contradictions when workspace changes
  useEffect(() => {
    if (!selectedWorkspaceId) return

    async function loadContradictions() {
      try {
        const data = await listContradictions({ status: 'detected', limit: 10 })
        setContradictions(data.contradictions || [])
      } catch {
        // Ignore errors
      }
    }
    loadContradictions()
  }, [selectedWorkspaceId, listContradictions])

  // Natural language query
  const handleQuery = async () => {
    if (!query.trim() || !selectedWorkspaceId) return

    setQueryLoading(true)
    setQueryResult(null)

    try {
      const res = await fetch('/api/knowledge/query', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          workspace_id: selectedWorkspaceId,
          query: query.trim(),
        }),
      })

      if (!res.ok) throw new Error('Query failed')

      const data = await res.json()
      setQueryResult(data.result)
    } catch (err) {
      console.error('Query error:', err)
    } finally {
      setQueryLoading(false)
    }
  }

  if (!selectedWorkspaceId) {
    return (
      <div className="p-8">
        <h1 className="text-2xl font-bold mb-4">Knowledge Graph</h1>
        <p className="text-gray-500">Select a workspace to view its knowledge graph.</p>
        <div className="mt-4 space-y-2">
          {workspaces.map(ws => (
            <button
              key={ws.id}
              onClick={() => setSelectedWorkspaceId(ws.id)}
              className="block w-full text-left px-4 py-2 border rounded hover:bg-gray-50"
            >
              {ws.name}
            </button>
          ))}
        </div>
      </div>
    )
  }

  return (
    <div className="h-screen flex flex-col">
      {/* Header */}
      <div className="p-4 border-b bg-white dark:bg-gray-900 flex items-center justify-between">
        <div className="flex items-center gap-4">
          <h1 className="text-xl font-bold">Knowledge Graph</h1>
          <select
            value={selectedWorkspaceId}
            onChange={e => setSelectedWorkspaceId(e.target.value)}
            className="border rounded px-2 py-1"
          >
            {workspaces.map(ws => (
              <option key={ws.id} value={ws.id}>
                {ws.name}
              </option>
            ))}
          </select>
        </div>
      </div>

      {/* Main content */}
      <div className="flex-1 flex overflow-hidden">
        {/* Graph */}
        <div className="flex-1 p-4">
          <KnowledgeGraph
            workspaceId={selectedWorkspaceId}
            centerId={selectedEntityId || undefined}
            onNodeClick={setSelectedEntityId}
          />
        </div>

        {/* Sidebar */}
        <div className="w-96 border-l bg-gray-50 dark:bg-gray-800 overflow-y-auto">
          {/* Query */}
          <div className="p-4 border-b bg-white dark:bg-gray-900">
            <h3 className="font-semibold mb-2">Ask your knowledge base</h3>
            <div className="flex gap-2">
              <input
                type="text"
                value={query}
                onChange={e => setQuery(e.target.value)}
                onKeyDown={e => e.key === 'Enter' && handleQuery()}
                placeholder="What do we know about...?"
                className="flex-1 border rounded px-3 py-2 text-sm"
              />
              <button
                onClick={handleQuery}
                disabled={queryLoading || !query.trim()}
                className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
              >
                {queryLoading ? '...' : 'Ask'}
              </button>
            </div>

            {queryResult && (
              <div className="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded text-sm">
                <p className="mb-2">{queryResult.answer}</p>
                {queryResult.relevant_entities.length > 0 && (
                  <p className="text-xs text-gray-500">
                    Related: {queryResult.relevant_entities.join(', ')}
                  </p>
                )}
                <p className="text-xs text-gray-400 mt-1">
                  Confidence: {queryResult.confidence}
                </p>
              </div>
            )}
          </div>

          {/* Entity Panel */}
          {selectedEntityId && (
            <div className="p-4 border-b">
              <EntityPanel
                workspaceId={selectedWorkspaceId}
                entityId={selectedEntityId}
                onClose={() => setSelectedEntityId(null)}
                onNavigate={setSelectedEntityId}
              />
            </div>
          )}

          {/* Contradictions */}
          {contradictions.length > 0 && (
            <div className="p-4">
              <h3 className="font-semibold mb-2">Detected Contradictions</h3>
              <div className="space-y-2">
                {contradictions.map(c => (
                  <div
                    key={c.id}
                    className={`p-2 rounded text-sm ${
                      c.severity === 'critical'
                        ? 'bg-red-100 dark:bg-red-900/30'
                        : c.severity === 'high'
                        ? 'bg-orange-100 dark:bg-orange-900/30'
                        : 'bg-yellow-100 dark:bg-yellow-900/30'
                    }`}
                  >
                    <span className="text-xs font-medium uppercase text-gray-500">{c.severity}</span>
                    <p className="mt-1">{c.description}</p>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Quick queries */}
          <div className="p-4">
            <h3 className="font-semibold mb-2">Quick Queries</h3>
            <div className="space-y-1">
              {[
                'What are our main findings?',
                'What claims lack supporting evidence?',
                'What are the key contradictions?',
                'Who are the main researchers mentioned?',
                'What methodologies do we reference?',
              ].map(q => (
                <button
                  key={q}
                  onClick={() => {
                    setQuery(q)
                    handleQuery()
                  }}
                  className="block w-full text-left px-3 py-2 text-sm hover:bg-white dark:hover:bg-gray-700 rounded"
                >
                  {q}
                </button>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/search/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useSearchParams, useRouter } from 'next/navigation'
import Link from 'next/link'
import { useSearch, SearchResult, SavedSearch } from '@/hooks/useSearch'
import { createClient } from '@/lib/supabase/client'

const TYPE_ICONS: Record<string, string> = {
  document: 'üìÑ',
  source: 'üìö',
  entity: 'üîó',
  section: 'üìù',
  claim: 'üí°',
}

const TYPE_COLORS: Record<string, string> = {
  document: 'bg-blue-100 text-blue-800',
  source: 'bg-purple-100 text-purple-800',
  entity: 'bg-green-100 text-green-800',
  section: 'bg-gray-100 text-gray-800',
  claim: 'bg-amber-100 text-amber-800',
}

export default function SearchPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const initialQuery = searchParams.get('q') || ''
  const workspaceIdParam = searchParams.get('workspace')

  const { results, loading, total, search, clearResults, getSavedSearches, saveSearch, deleteSavedSearch } = useSearch()

  const [query, setQuery] = useState(initialQuery)
  const [selectedTypes, setSelectedTypes] = useState<string[]>(['document', 'source', 'entity', 'section'])
  const [selectedWorkspace, setSelectedWorkspace] = useState<string | null>(workspaceIdParam)
  const [workspaces, setWorkspaces] = useState<Array<{ id: string; name: string }>>([])
  const [savedSearches, setSavedSearches] = useState<SavedSearch[]>([])
  const [showSaveDialog, setShowSaveDialog] = useState(false)
  const [saveName, setSaveName] = useState('')

  // Load workspaces
  useEffect(() => {
    async function loadWorkspaces() {
      const supabase = createClient()
      const { data: memberships } = await supabase
        .from('workspace_members')
        .select('workspace:workspaces(id, name)')

      if (memberships) {
        const ws: Array<{ id: string; name: string }> = []
        for (const m of memberships) {
          const workspace = m.workspace as unknown
          if (workspace && typeof workspace === 'object' && 'id' in workspace && 'name' in workspace) {
            ws.push(workspace as { id: string; name: string })
          }
        }
        setWorkspaces(ws)
      }
    }
    loadWorkspaces()
  }, [])

  // Load saved searches
  useEffect(() => {
    async function loadSaved() {
      try {
        const searches = await getSavedSearches(selectedWorkspace || undefined)
        setSavedSearches(searches)
      } catch {
        // Ignore errors
      }
    }
    loadSaved()
  }, [selectedWorkspace, getSavedSearches])

  // Run search when query params change
  useEffect(() => {
    if (initialQuery) {
      handleSearch()
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialQuery])

  const handleSearch = async () => {
    if (!query.trim()) {
      clearResults()
      return
    }

    // Update URL
    const params = new URLSearchParams()
    params.set('q', query)
    if (selectedWorkspace) params.set('workspace', selectedWorkspace)
    router.push(`/search?${params}`)

    await search({
      query: query.trim(),
      workspace_id: selectedWorkspace || undefined,
      types: selectedTypes,
      limit: 50,
    })
  }

  const handleSaveSearch = async () => {
    if (!saveName.trim() || !query.trim()) return

    try {
      const saved = await saveSearch({
        name: saveName,
        query: query.trim(),
        workspace_id: selectedWorkspace || undefined,
        filters: { types: selectedTypes },
      })
      setSavedSearches([saved, ...savedSearches])
      setShowSaveDialog(false)
      setSaveName('')
    } catch (err) {
      console.error('Save search error:', err)
    }
  }

  const handleLoadSaved = (saved: SavedSearch) => {
    setQuery(saved.query)
    if (saved.filters?.types) {
      setSelectedTypes(saved.filters.types as string[])
    }
    if (saved.workspace_id) {
      setSelectedWorkspace(saved.workspace_id)
    }
    search({
      query: saved.query,
      workspace_id: saved.workspace_id || undefined,
      types: (saved.filters?.types as string[]) || selectedTypes,
    })
  }

  const handleDeleteSaved = async (searchId: string) => {
    try {
      await deleteSavedSearch(searchId)
      setSavedSearches(savedSearches.filter(s => s.id !== searchId))
    } catch (err) {
      console.error('Delete saved search error:', err)
    }
  }

  const toggleType = (type: string) => {
    setSelectedTypes(prev =>
      prev.includes(type) ? prev.filter(t => t !== type) : [...prev, type]
    )
  }

  const getResultLink = (result: SearchResult) => {
    switch (result.type) {
      case 'document':
        return `/documents/${result.id}`
      case 'section':
        return result.document_id ? `/documents/${result.document_id}` : '#'
      case 'source':
        return `/sources?highlight=${result.id}`
      case 'entity':
      case 'claim':
        return `/knowledge?entity=${result.id}&workspace=${result.workspace_id}`
      default:
        return '#'
    }
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      {/* Header */}
      <div className="bg-white dark:bg-gray-800 border-b sticky top-0 z-10">
        <div className="max-w-4xl mx-auto px-4 py-4">
          <h1 className="text-xl font-bold mb-4">Search</h1>

          {/* Search input */}
          <div className="flex gap-2">
            <input
              type="text"
              value={query}
              onChange={e => setQuery(e.target.value)}
              onKeyDown={e => e.key === 'Enter' && handleSearch()}
              placeholder="Search documents, sources, entities..."
              className="flex-1 border rounded-lg px-4 py-2"
              autoFocus
            />
            <button
              onClick={handleSearch}
              disabled={loading}
              className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
            >
              {loading ? 'Searching...' : 'Search'}
            </button>
          </div>

          {/* Filters */}
          <div className="mt-3 flex flex-wrap items-center gap-4">
            <div className="flex gap-2">
              {['document', 'source', 'entity', 'section', 'claim'].map(type => (
                <button
                  key={type}
                  onClick={() => toggleType(type)}
                  className={`px-3 py-1 rounded-full text-sm ${
                    selectedTypes.includes(type)
                      ? TYPE_COLORS[type]
                      : 'bg-gray-100 text-gray-400'
                  }`}
                >
                  {TYPE_ICONS[type]} {type}
                </button>
              ))}
            </div>

            <select
              value={selectedWorkspace || ''}
              onChange={e => setSelectedWorkspace(e.target.value || null)}
              className="border rounded px-2 py-1 text-sm"
            >
              <option value="">All workspaces</option>
              {workspaces.map(ws => (
                <option key={ws.id} value={ws.id}>
                  {ws.name}
                </option>
              ))}
            </select>

            {query.trim() && (
              <button
                onClick={() => setShowSaveDialog(true)}
                className="text-sm text-blue-600 hover:underline"
              >
                Save search
              </button>
            )}
          </div>
        </div>
      </div>

      <div className="max-w-4xl mx-auto px-4 py-6 flex gap-6">
        {/* Results */}
        <div className="flex-1">
          {results.length > 0 && (
            <p className="text-sm text-gray-500 mb-4">
              {total} result{total !== 1 ? 's' : ''} for &quot;{query}&quot;
            </p>
          )}

          {results.length === 0 && query && !loading && (
            <div className="text-center py-12 text-gray-500">
              <p>No results found for &quot;{query}&quot;</p>
              <p className="text-sm mt-2">Try adjusting your search or filters</p>
            </div>
          )}

          <div className="space-y-4">
            {results.map(result => (
              <Link
                key={`${result.type}-${result.id}`}
                href={getResultLink(result)}
                className="block p-4 bg-white dark:bg-gray-800 rounded-lg border hover:shadow-md transition-shadow"
              >
                <div className="flex items-start gap-3">
                  <span className="text-xl">{TYPE_ICONS[result.type]}</span>
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2 mb-1">
                      <span className={`px-2 py-0.5 rounded text-xs ${TYPE_COLORS[result.type]}`}>
                        {result.type}
                      </span>
                      {result.workspace_name && (
                        <span className="text-xs text-gray-400">{result.workspace_name}</span>
                      )}
                    </div>
                    <h3 className="font-medium truncate">{result.title}</h3>
                    {result.excerpt && (
                      <p className="text-sm text-gray-600 dark:text-gray-400 mt-1 line-clamp-2">
                        {result.excerpt}
                      </p>
                    )}
                    {result.document_title && (
                      <p className="text-xs text-gray-400 mt-1">
                        in {result.document_title}
                      </p>
                    )}
                  </div>
                </div>
              </Link>
            ))}
          </div>
        </div>

        {/* Saved searches sidebar */}
        {savedSearches.length > 0 && (
          <div className="w-64 hidden lg:block">
            <h3 className="font-medium mb-3">Saved Searches</h3>
            <div className="space-y-2">
              {savedSearches.map(saved => (
                <div
                  key={saved.id}
                  className="p-2 bg-white dark:bg-gray-800 rounded border text-sm"
                >
                  <button
                    onClick={() => handleLoadSaved(saved)}
                    className="font-medium hover:text-blue-600 block w-full text-left"
                  >
                    {saved.name}
                  </button>
                  <div className="flex justify-between items-center mt-1">
                    <span className="text-xs text-gray-400 truncate">{saved.query}</span>
                    <button
                      onClick={() => handleDeleteSaved(saved.id)}
                      className="text-xs text-red-500 hover:underline"
                    >
                      Delete
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* Save dialog */}
      {showSaveDialog && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-96">
            <h3 className="font-semibold mb-4">Save Search</h3>
            <input
              type="text"
              value={saveName}
              onChange={e => setSaveName(e.target.value)}
              placeholder="Search name"
              className="w-full border rounded px-3 py-2 mb-4"
              autoFocus
            />
            <p className="text-sm text-gray-500 mb-4">
              Query: {query}
            </p>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => setShowSaveDialog(false)}
                className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded"
              >
                Cancel
              </button>
              <button
                onClick={handleSaveSearch}
                disabled={!saveName.trim()}
                className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
              >
                Save
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/sources/import/page.tsx">
'use client'

import { useState } from 'react'
import Link from 'next/link'

type ImportTab = 'arxiv' | 'doi' | 'bibtex' | 'web'

interface ImportResult {
  success: boolean
  message: string
  source?: { id: string; title: string }
}

export default function ImportPage() {
  const [activeTab, setActiveTab] = useState<ImportTab>('arxiv')
  const [loading, setLoading] = useState(false)
  const [result, setResult] = useState<ImportResult | null>(null)
  const [error, setError] = useState('')

  // ArXiv state
  const [arxivId, setArxivId] = useState('')
  const [arxivSearch, setArxivSearch] = useState('')
  const [arxivResults, setArxivResults] = useState<Array<{
    arxiv_id: string
    title: string
    authors: string[]
    abstract: string
    published: string
  }>>([])

  // DOI state
  const [doi, setDoi] = useState('')

  // BibTeX state
  const [bibtex, setBibtex] = useState('')
  const [bibtexResults, setBibtexResults] = useState<{
    imported: number
    skipped: number
    failed: number
  } | null>(null)

  // Web state
  const [webUrl, setWebUrl] = useState('')

  const handleArxivSearch = async () => {
    if (!arxivSearch.trim()) return
    setLoading(true)
    setError('')
    setArxivResults([])

    try {
      const res = await fetch(`/api/import/arxiv?query=${encodeURIComponent(arxivSearch)}&max_results=10`)
      const data = await res.json()

      if (!res.ok) throw new Error(data.error)
      setArxivResults(data.results)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Search failed')
    } finally {
      setLoading(false)
    }
  }

  const handleArxivImport = async (id?: string) => {
    const importId = id || arxivId.trim()
    if (!importId) return

    setLoading(true)
    setError('')
    setResult(null)

    try {
      const res = await fetch('/api/import/arxiv', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ arxiv_id: importId }),
      })
      const data = await res.json()

      if (!res.ok) throw new Error(data.error)

      setResult({
        success: true,
        message: data.message,
        source: data.source,
      })
      setArxivId('')
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Import failed')
    } finally {
      setLoading(false)
    }
  }

  const handleDoiImport = async () => {
    if (!doi.trim()) return

    setLoading(true)
    setError('')
    setResult(null)

    try {
      const res = await fetch('/api/import/doi', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ doi: doi.trim() }),
      })
      const data = await res.json()

      if (!res.ok) throw new Error(data.error)

      setResult({
        success: true,
        message: data.message,
        source: data.source,
      })
      setDoi('')
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Import failed')
    } finally {
      setLoading(false)
    }
  }

  const handleBibtexImport = async () => {
    if (!bibtex.trim()) return

    setLoading(true)
    setError('')
    setBibtexResults(null)

    try {
      const res = await fetch('/api/import/bibtex', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ bibtex: bibtex.trim() }),
      })
      const data = await res.json()

      if (!res.ok) throw new Error(data.error)

      setBibtexResults({
        imported: data.imported,
        skipped: data.skipped,
        failed: data.failed,
      })

      if (data.imported > 0) {
        setBibtex('')
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Import failed')
    } finally {
      setLoading(false)
    }
  }

  const handleWebImport = async () => {
    if (!webUrl.trim()) return

    setLoading(true)
    setError('')
    setResult(null)

    try {
      const res = await fetch('/api/import/web', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url: webUrl.trim() }),
      })
      const data = await res.json()

      if (!res.ok) throw new Error(data.error)

      setResult({
        success: true,
        message: data.message,
        source: data.source,
      })
      setWebUrl('')
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Import failed')
    } finally {
      setLoading(false)
    }
  }

  const tabs: { id: ImportTab; label: string; icon: string }[] = [
    { id: 'arxiv', label: 'ArXiv', icon: 'M12 14l9-5-9-5-9 5 9 5z M12 14l6.16-3.422a12.083 12.083 0 01.665 6.479A11.952 11.952 0 0012 20.055a11.952 11.952 0 00-6.824-2.998 12.078 12.078 0 01.665-6.479L12 14z' },
    { id: 'doi', label: 'DOI', icon: 'M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1' },
    { id: 'bibtex', label: 'BibTeX', icon: 'M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z' },
    { id: 'web', label: 'Web Article', icon: 'M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9' },
  ]

  return (
    <div className="max-w-4xl mx-auto space-y-6">
      {/* Header */}
      <div className="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400 mb-2">
        <Link href="/sources" className="hover:text-gray-700 dark:hover:text-gray-200">
          Sources
        </Link>
        <span>/</span>
        <span className="text-gray-900 dark:text-white">Import</span>
      </div>

      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
          Import Sources
        </h1>
      </div>

      {/* Tabs */}
      <div className="border-b border-gray-200 dark:border-gray-700">
        <nav className="flex space-x-8">
          {tabs.map((tab) => (
            <button
              key={tab.id}
              onClick={() => {
                setActiveTab(tab.id)
                setError('')
                setResult(null)
              }}
              className={`flex items-center gap-2 py-4 px-1 border-b-2 font-medium text-sm transition-colors ${
                activeTab === tab.id
                  ? 'border-blue-500 text-blue-600 dark:text-blue-400'
                  : 'border-transparent text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200'
              }`}
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d={tab.icon} />
              </svg>
              {tab.label}
            </button>
          ))}
        </nav>
      </div>

      {/* Error/Success Messages */}
      {error && (
        <div className="p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-600 dark:text-red-400">
          {error}
        </div>
      )}

      {result && (
        <div className="p-4 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg text-green-600 dark:text-green-400">
          {result.message}
          {result.source && (
            <Link
              href={`/sources/${result.source.id}`}
              className="ml-2 underline hover:no-underline"
            >
              View source
            </Link>
          )}
        </div>
      )}

      {/* Tab Content */}
      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
        {/* ArXiv Tab */}
        {activeTab === 'arxiv' && (
          <div className="space-y-6">
            <div>
              <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">
                Import from ArXiv
              </h2>
              <p className="text-sm text-gray-500 dark:text-gray-400">
                Import papers directly from ArXiv by ID or search.
              </p>
            </div>

            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  ArXiv ID
                </label>
                <div className="flex gap-2">
                  <input
                    type="text"
                    value={arxivId}
                    onChange={(e) => setArxivId(e.target.value)}
                    placeholder="e.g., 2301.12345 or https://arxiv.org/abs/2301.12345"
                    className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white"
                  />
                  <button
                    onClick={() => handleArxivImport()}
                    disabled={loading || !arxivId.trim()}
                    className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
                  >
                    Import
                  </button>
                </div>
              </div>

              <div className="border-t border-gray-200 dark:border-gray-700 pt-4">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Or search ArXiv
                </label>
                <div className="flex gap-2">
                  <input
                    type="text"
                    value={arxivSearch}
                    onChange={(e) => setArxivSearch(e.target.value)}
                    onKeyDown={(e) => e.key === 'Enter' && handleArxivSearch()}
                    placeholder="Search for papers..."
                    className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white"
                  />
                  <button
                    onClick={handleArxivSearch}
                    disabled={loading || !arxivSearch.trim()}
                    className="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 disabled:opacity-50"
                  >
                    Search
                  </button>
                </div>
              </div>

              {arxivResults.length > 0 && (
                <div className="space-y-3 mt-4">
                  {arxivResults.map((paper) => (
                    <div
                      key={paper.arxiv_id}
                      className="p-4 border border-gray-200 dark:border-gray-700 rounded-lg"
                    >
                      <h3 className="font-medium text-gray-900 dark:text-white">
                        {paper.title}
                      </h3>
                      <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                        {paper.authors.slice(0, 3).join(', ')}
                        {paper.authors.length > 3 && ` +${paper.authors.length - 3} more`}
                      </p>
                      <p className="text-xs text-gray-400 mt-1 line-clamp-2">
                        {paper.abstract}
                      </p>
                      <div className="flex justify-between items-center mt-2">
                        <span className="text-xs text-gray-400">
                          {new Date(paper.published).toLocaleDateString()}
                        </span>
                        <button
                          onClick={() => handleArxivImport(paper.arxiv_id)}
                          disabled={loading}
                          className="text-sm text-blue-600 hover:text-blue-700 dark:text-blue-400"
                        >
                          Import
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        )}

        {/* DOI Tab */}
        {activeTab === 'doi' && (
          <div className="space-y-6">
            <div>
              <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">
                Import by DOI
              </h2>
              <p className="text-sm text-gray-500 dark:text-gray-400">
                Import any paper with a DOI from CrossRef.
              </p>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                DOI
              </label>
              <div className="flex gap-2">
                <input
                  type="text"
                  value={doi}
                  onChange={(e) => setDoi(e.target.value)}
                  placeholder="e.g., 10.1038/nature12373 or https://doi.org/10.1038/nature12373"
                  className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white"
                />
                <button
                  onClick={handleDoiImport}
                  disabled={loading || !doi.trim()}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
                >
                  Import
                </button>
              </div>
            </div>
          </div>
        )}

        {/* BibTeX Tab */}
        {activeTab === 'bibtex' && (
          <div className="space-y-6">
            <div>
              <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">
                Import from BibTeX
              </h2>
              <p className="text-sm text-gray-500 dark:text-gray-400">
                Paste your BibTeX entries to import multiple sources at once.
              </p>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                BibTeX Content
              </label>
              <textarea
                value={bibtex}
                onChange={(e) => setBibtex(e.target.value)}
                rows={12}
                placeholder={`@article{example2024,
  title={Example Paper Title},
  author={Smith, John and Doe, Jane},
  journal={Nature},
  year={2024},
  doi={10.1038/example}
}`}
                className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white font-mono text-sm"
              />
              <button
                onClick={handleBibtexImport}
                disabled={loading || !bibtex.trim()}
                className="mt-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
              >
                Import All Entries
              </button>
            </div>

            {bibtexResults && (
              <div className="p-4 bg-gray-50 dark:bg-gray-900 rounded-lg">
                <h3 className="font-medium text-gray-900 dark:text-white mb-2">Import Results</h3>
                <div className="grid grid-cols-3 gap-4 text-center">
                  <div>
                    <div className="text-2xl font-bold text-green-600">{bibtexResults.imported}</div>
                    <div className="text-sm text-gray-500">Imported</div>
                  </div>
                  <div>
                    <div className="text-2xl font-bold text-yellow-600">{bibtexResults.skipped}</div>
                    <div className="text-sm text-gray-500">Skipped</div>
                  </div>
                  <div>
                    <div className="text-2xl font-bold text-red-600">{bibtexResults.failed}</div>
                    <div className="text-sm text-gray-500">Failed</div>
                  </div>
                </div>
              </div>
            )}
          </div>
        )}

        {/* Web Tab */}
        {activeTab === 'web' && (
          <div className="space-y-6">
            <div>
              <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">
                Import Web Article
              </h2>
              <p className="text-sm text-gray-500 dark:text-gray-400">
                Import any web article by URL. Content will be extracted automatically.
              </p>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Article URL
              </label>
              <div className="flex gap-2">
                <input
                  type="url"
                  value={webUrl}
                  onChange={(e) => setWebUrl(e.target.value)}
                  placeholder="https://example.com/article"
                  className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white"
                />
                <button
                  onClick={handleWebImport}
                  disabled={loading || !webUrl.trim()}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
                >
                  Import
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Loading indicator */}
        {loading && (
          <div className="flex items-center justify-center py-8">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/workspace/[id]/project/[projectId]/document/new/page.tsx">
'use client'

import { useState } from 'react'
import { useRouter, useParams } from 'next/navigation'
import Link from 'next/link'

export default function NewDocumentPage() {
  const router = useRouter()
  const params = useParams()
  const workspaceId = params.id as string
  const projectId = params.projectId as string

  const [title, setTitle] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError('')
    setLoading(true)

    try {
      const res = await fetch('/api/documents', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, project_id: projectId }),
      })

      const data = await res.json()

      if (!res.ok) {
        throw new Error(data.error || 'Failed to create document')
      }

      // Redirect to the document editor
      router.push(`/documents/${data.document.id}`)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="max-w-2xl mx-auto">
      <div className="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400 mb-6">
        <Link href="/dashboard" className="hover:text-gray-700 dark:hover:text-gray-200">
          Dashboard
        </Link>
        <span>/</span>
        <Link href={`/workspace/${workspaceId}`} className="hover:text-gray-700 dark:hover:text-gray-200">
          Workspace
        </Link>
        <span>/</span>
        <Link href={`/workspace/${workspaceId}/project/${projectId}`} className="hover:text-gray-700 dark:hover:text-gray-200">
          Project
        </Link>
        <span>/</span>
        <span className="text-gray-900 dark:text-white">New Document</span>
      </div>

      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white mb-6">
          Create Document
        </h1>

        <form onSubmit={handleSubmit} className="space-y-6">
          {error && (
            <div className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-600 dark:text-red-400 text-sm">
              {error}
            </div>
          )}

          <div>
            <label htmlFor="title" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Document Title *
            </label>
            <input
              type="text"
              id="title"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="My Research Document"
              required
            />
          </div>

          <div className="flex justify-end gap-3">
            <Link
              href={`/workspace/${workspaceId}/project/${projectId}`}
              className="px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700"
            >
              Cancel
            </Link>
            <button
              type="submit"
              disabled={loading || !title.trim()}
              className="px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? 'Creating...' : 'Create Document'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/workspace/[id]/project/[projectId]/page.tsx">
import { createClient } from '@/lib/supabase/server'
import { notFound, redirect } from 'next/navigation'
import Link from 'next/link'

export default async function ProjectPage({
  params,
}: {
  params: Promise<{ id: string; projectId: string }>
}) {
  const { id: workspaceId, projectId } = await params
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    redirect('/login')
  }

  // Fetch project with workspace info
  const { data: project, error } = await supabase
    .from('projects')
    .select(`
      *,
      workspaces!inner(name)
    `)
    .eq('id', projectId)
    .eq('workspace_id', workspaceId)
    .single()

  if (error || !project) {
    notFound()
  }

  // Fetch documents in this project
  const { data: documents } = await supabase
    .from('documents')
    .select('*')
    .eq('project_id', projectId)
    .order('updated_at', { ascending: false })

  return (
    <div className="space-y-8">
      {/* Header */}
      <div className="flex justify-between items-start">
        <div>
          <div className="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400 mb-2">
            <Link href="/dashboard" className="hover:text-gray-700 dark:hover:text-gray-200">
              Dashboard
            </Link>
            <span>/</span>
            <Link href={`/workspace/${workspaceId}`} className="hover:text-gray-700 dark:hover:text-gray-200">
              {project.workspaces?.name || 'Workspace'}
            </Link>
            <span>/</span>
            <span className="text-gray-900 dark:text-white">{project.name}</span>
          </div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            {project.name}
          </h1>
          {project.description && (
            <p className="text-gray-600 dark:text-gray-400 mt-1">
              {project.description}
            </p>
          )}
        </div>
        <Link
          href={`/workspace/${workspaceId}/project/${projectId}/document/new`}
          className="inline-flex items-center px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
        >
          <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
          </svg>
          New Document
        </Link>
      </div>

      {/* Stats */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="text-2xl font-bold text-gray-900 dark:text-white">
            {documents?.length || 0}
          </div>
          <div className="text-sm text-gray-500 dark:text-gray-400">
            Documents
          </div>
        </div>
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="text-sm text-gray-500 dark:text-gray-400">
            Last updated
          </div>
          <div className="text-lg font-medium text-gray-900 dark:text-white">
            {new Date(project.updated_at).toLocaleDateString()}
          </div>
        </div>
      </div>

      {/* Documents Grid */}
      <div>
        <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
          Documents
        </h2>

        {documents && documents.length > 0 ? (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {documents.map((doc) => (
              <Link
                key={doc.id}
                href={`/documents/${doc.id}`}
                className="block p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 hover:border-blue-500 dark:hover:border-blue-500 transition-colors"
              >
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  {doc.title}
                </h3>
                <div className="flex items-center mt-4 text-xs text-gray-400">
                  <span>Updated {new Date(doc.updated_at).toLocaleDateString()}</span>
                </div>
              </Link>
            ))}
          </div>
        ) : (
          <div className="text-center py-12 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
            <svg className="w-12 h-12 mx-auto text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
            <h3 className="mt-4 text-lg font-medium text-gray-900 dark:text-white">
              No documents yet
            </h3>
            <p className="mt-2 text-gray-500 dark:text-gray-400">
              Create your first document to start writing
            </p>
            <Link
              href={`/workspace/${workspaceId}/project/${projectId}/document/new`}
              className="mt-4 inline-flex items-center px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
            >
              Create Document
            </Link>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/workspace/[id]/project/new/page.tsx">
'use client'

import { useState } from 'react'
import { useRouter, useParams } from 'next/navigation'
import Link from 'next/link'

export default function NewProjectPage() {
  const router = useRouter()
  const params = useParams()
  const workspaceId = params.id as string

  const [name, setName] = useState('')
  const [description, setDescription] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError('')
    setLoading(true)

    try {
      const res = await fetch('/api/projects', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, description, workspace_id: workspaceId }),
      })

      const data = await res.json()

      if (!res.ok) {
        throw new Error(data.error || 'Failed to create project')
      }

      router.push(`/workspace/${workspaceId}/project/${data.project.id}`)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="max-w-2xl mx-auto">
      <div className="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400 mb-6">
        <Link href="/dashboard" className="hover:text-gray-700 dark:hover:text-gray-200">
          Dashboard
        </Link>
        <span>/</span>
        <Link href={`/workspace/${workspaceId}`} className="hover:text-gray-700 dark:hover:text-gray-200">
          Workspace
        </Link>
        <span>/</span>
        <span className="text-gray-900 dark:text-white">New Project</span>
      </div>

      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white mb-6">
          Create Project
        </h1>

        <form onSubmit={handleSubmit} className="space-y-6">
          {error && (
            <div className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-600 dark:text-red-400 text-sm">
              {error}
            </div>
          )}

          <div>
            <label htmlFor="name" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Project Name *
            </label>
            <input
              type="text"
              id="name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="My Research Project"
              required
            />
          </div>

          <div>
            <label htmlFor="description" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Description
            </label>
            <textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              rows={3}
              className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
              placeholder="A brief description of this project..."
            />
          </div>

          <div className="flex justify-end gap-3">
            <Link
              href={`/workspace/${workspaceId}`}
              className="px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700"
            >
              Cancel
            </Link>
            <button
              type="submit"
              disabled={loading || !name.trim()}
              className="px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? 'Creating...' : 'Create Project'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/workspace/[id]/settings/page.tsx">
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useRouter, useParams } from 'next/navigation'
import Link from 'next/link'

interface Member {
  user_id: string
  role: 'owner' | 'admin' | 'editor' | 'reviewer' | 'viewer'
  invited_at: string
  joined_at: string
  display_name?: string
  avatar_url?: string
  email?: string
}

interface Invitation {
  id: string
  email: string
  role: string
  created_at: string
  expires_at: string
}

interface Workspace {
  id: string
  name: string
  description?: string
  slug: string
  owner_id: string
}

export default function WorkspaceSettingsPage() {
  const router = useRouter()
  const params = useParams()
  const workspaceId = params.id as string

  const [workspace, setWorkspace] = useState<Workspace | null>(null)
  const [members, setMembers] = useState<Member[]>([])
  const [invitations, setInvitations] = useState<Invitation[]>([])
  const [userRole, setUserRole] = useState<string>('viewer')
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState('')

  // Edit workspace state
  const [editName, setEditName] = useState('')
  const [editDescription, setEditDescription] = useState('')
  const [saving, setSaving] = useState(false)

  // Invite dialog state
  const [showInviteDialog, setShowInviteDialog] = useState(false)
  const [inviteEmail, setInviteEmail] = useState('')
  const [inviteRole, setInviteRole] = useState<string>('editor')
  const [inviting, setInviting] = useState(false)
  const [inviteError, setInviteError] = useState('')
  const [inviteSuccess, setInviteSuccess] = useState('')

  const fetchWorkspaceData = useCallback(async () => {
    try {
      // Fetch workspace details
      const wsRes = await fetch(`/api/workspaces/${workspaceId}`)
      if (!wsRes.ok) {
        if (wsRes.status === 404) {
          router.push('/dashboard')
          return
        }
        throw new Error('Failed to fetch workspace')
      }
      const wsData = await wsRes.json()
      setWorkspace(wsData.workspace)
      setUserRole(wsData.role)
      setEditName(wsData.workspace.name)
      setEditDescription(wsData.workspace.description || '')

      // Fetch members
      const membersRes = await fetch(`/api/workspaces/${workspaceId}/members`)
      if (membersRes.ok) {
        const membersData = await membersRes.json()
        setMembers(membersData.members)
      }

      // Fetch invitations
      const invitesRes = await fetch(`/api/workspaces/${workspaceId}/invitations`)
      if (invitesRes.ok) {
        const invitesData = await invitesRes.json()
        setInvitations(invitesData.invitations)
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load workspace')
    } finally {
      setLoading(false)
    }
  }, [workspaceId, router])

  useEffect(() => {
    fetchWorkspaceData()
  }, [fetchWorkspaceData])

  const handleSaveWorkspace = async (e: React.FormEvent) => {
    e.preventDefault()
    setSaving(true)
    try {
      const res = await fetch(`/api/workspaces/${workspaceId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: editName, description: editDescription }),
      })

      if (!res.ok) {
        const data = await res.json()
        throw new Error(data.error || 'Failed to update workspace')
      }

      const data = await res.json()
      setWorkspace(data.workspace)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update')
    } finally {
      setSaving(false)
    }
  }

  const handleInvite = async (e: React.FormEvent) => {
    e.preventDefault()
    setInviteError('')
    setInviteSuccess('')
    setInviting(true)

    try {
      const res = await fetch(`/api/workspaces/${workspaceId}/invitations`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: inviteEmail, role: inviteRole }),
      })

      const data = await res.json()

      if (!res.ok) {
        throw new Error(data.error || 'Failed to send invitation')
      }

      setInviteSuccess(`Invitation sent to ${inviteEmail}`)
      setInviteEmail('')
      setInvitations([data.invitation, ...invitations])

      // Close dialog after a moment
      setTimeout(() => {
        setShowInviteDialog(false)
        setInviteSuccess('')
      }, 2000)
    } catch (err) {
      setInviteError(err instanceof Error ? err.message : 'Failed to invite')
    } finally {
      setInviting(false)
    }
  }

  const handleRevokeInvitation = async (invitationId: string) => {
    if (!confirm('Revoke this invitation?')) return

    try {
      const res = await fetch(`/api/workspaces/${workspaceId}/invitations?invitation_id=${invitationId}`, {
        method: 'DELETE',
      })

      if (!res.ok) {
        throw new Error('Failed to revoke invitation')
      }

      setInvitations(invitations.filter(i => i.id !== invitationId))
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to revoke')
    }
  }

  const handleUpdateRole = async (userId: string, newRole: string) => {
    try {
      const res = await fetch(`/api/workspaces/${workspaceId}/members`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ user_id: userId, role: newRole }),
      })

      if (!res.ok) {
        const data = await res.json()
        throw new Error(data.error || 'Failed to update role')
      }

      setMembers(members.map(m =>
        m.user_id === userId ? { ...m, role: newRole as Member['role'] } : m
      ))
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update role')
    }
  }

  const handleRemoveMember = async (userId: string, displayName?: string) => {
    if (!confirm(`Remove ${displayName || 'this member'} from the workspace?`)) return

    try {
      const res = await fetch(`/api/workspaces/${workspaceId}/members?user_id=${userId}`, {
        method: 'DELETE',
      })

      if (!res.ok) {
        const data = await res.json()
        throw new Error(data.error || 'Failed to remove member')
      }

      setMembers(members.filter(m => m.user_id !== userId))
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to remove member')
    }
  }

  const isAdmin = ['owner', 'admin'].includes(userRole)

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
      </div>
    )
  }

  if (!workspace) {
    return (
      <div className="text-center py-12">
        <p className="text-gray-500 dark:text-gray-400">Workspace not found</p>
      </div>
    )
  }

  return (
    <div className="max-w-4xl mx-auto space-y-8">
      {/* Breadcrumb */}
      <div className="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400">
        <Link href="/dashboard" className="hover:text-gray-700 dark:hover:text-gray-200">
          Dashboard
        </Link>
        <span>/</span>
        <Link href={`/workspace/${workspaceId}`} className="hover:text-gray-700 dark:hover:text-gray-200">
          {workspace.name}
        </Link>
        <span>/</span>
        <span className="text-gray-900 dark:text-white">Settings</span>
      </div>

      <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
        Workspace Settings
      </h1>

      {error && (
        <div className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-600 dark:text-red-400 text-sm">
          {error}
          <button onClick={() => setError('')} className="ml-2 underline">Dismiss</button>
        </div>
      )}

      {/* General Settings */}
      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
        <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
          General
        </h2>

        <form onSubmit={handleSaveWorkspace} className="space-y-4">
          <div>
            <label htmlFor="name" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Workspace Name
            </label>
            <input
              type="text"
              id="name"
              value={editName}
              onChange={(e) => setEditName(e.target.value)}
              disabled={!isAdmin}
              className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:opacity-50"
              required
            />
          </div>

          <div>
            <label htmlFor="description" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Description
            </label>
            <textarea
              id="description"
              value={editDescription}
              onChange={(e) => setEditDescription(e.target.value)}
              disabled={!isAdmin}
              rows={3}
              className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none disabled:opacity-50"
            />
          </div>

          {isAdmin && (
            <div className="flex justify-end">
              <button
                type="submit"
                disabled={saving}
                className="px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50"
              >
                {saving ? 'Saving...' : 'Save Changes'}
              </button>
            </div>
          )}
        </form>
      </div>

      {/* Members Section */}
      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
            Members ({members.length})
          </h2>
          {isAdmin && (
            <button
              onClick={() => setShowInviteDialog(true)}
              className="inline-flex items-center px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
            >
              <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
              </svg>
              Invite Member
            </button>
          )}
        </div>

        <div className="divide-y divide-gray-200 dark:divide-gray-700">
          {members.map((member) => (
            <div key={member.user_id} className="py-4 flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-gray-200 dark:bg-gray-700 rounded-full flex items-center justify-center">
                  {member.avatar_url ? (
                    <img src={member.avatar_url} alt="" className="w-10 h-10 rounded-full" />
                  ) : (
                    <span className="text-gray-500 dark:text-gray-400 text-sm font-medium">
                      {(member.display_name || member.email || 'U')[0].toUpperCase()}
                    </span>
                  )}
                </div>
                <div>
                  <div className="text-sm font-medium text-gray-900 dark:text-white">
                    {member.display_name || member.email || 'Unknown User'}
                  </div>
                  {member.email && member.display_name && (
                    <div className="text-xs text-gray-500 dark:text-gray-400">
                      {member.email}
                    </div>
                  )}
                </div>
              </div>

              <div className="flex items-center gap-3">
                {isAdmin && member.role !== 'owner' ? (
                  <select
                    value={member.role}
                    onChange={(e) => handleUpdateRole(member.user_id, e.target.value)}
                    className="text-sm border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-1.5 bg-white dark:bg-gray-900 text-gray-900 dark:text-white"
                  >
                    <option value="admin">Admin</option>
                    <option value="editor">Editor</option>
                    <option value="reviewer">Reviewer</option>
                    <option value="viewer">Viewer</option>
                  </select>
                ) : (
                  <span className="text-sm text-gray-500 dark:text-gray-400 capitalize px-3 py-1.5">
                    {member.role}
                  </span>
                )}

                {isAdmin && member.role !== 'owner' && (
                  <button
                    onClick={() => handleRemoveMember(member.user_id, member.display_name)}
                    className="text-red-600 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                    title="Remove member"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                  </button>
                )}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Pending Invitations */}
      {isAdmin && invitations.length > 0 && (
        <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
            Pending Invitations ({invitations.length})
          </h2>

          <div className="divide-y divide-gray-200 dark:divide-gray-700">
            {invitations.map((invitation) => (
              <div key={invitation.id} className="py-4 flex items-center justify-between">
                <div>
                  <div className="text-sm font-medium text-gray-900 dark:text-white">
                    {invitation.email}
                  </div>
                  <div className="text-xs text-gray-500 dark:text-gray-400">
                    Invited as {invitation.role} - Expires {new Date(invitation.expires_at).toLocaleDateString()}
                  </div>
                </div>
                <button
                  onClick={() => handleRevokeInvitation(invitation.id)}
                  className="text-sm text-red-600 hover:text-red-700 dark:text-red-400"
                >
                  Revoke
                </button>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Invite Dialog */}
      {showInviteDialog && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md mx-4">
            <div className="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Invite Team Member
              </h3>
              <button
                onClick={() => {
                  setShowInviteDialog(false)
                  setInviteError('')
                  setInviteSuccess('')
                }}
                className="text-gray-400 hover:text-gray-500"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>

            <form onSubmit={handleInvite} className="p-4 space-y-4">
              {inviteError && (
                <div className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-600 dark:text-red-400 text-sm">
                  {inviteError}
                </div>
              )}

              {inviteSuccess && (
                <div className="p-3 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg text-green-600 dark:text-green-400 text-sm">
                  {inviteSuccess}
                </div>
              )}

              <div>
                <label htmlFor="invite-email" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Email Address
                </label>
                <input
                  type="email"
                  id="invite-email"
                  value={inviteEmail}
                  onChange={(e) => setInviteEmail(e.target.value)}
                  className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  placeholder="colleague@example.com"
                  required
                />
              </div>

              <div>
                <label htmlFor="invite-role" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Role
                </label>
                <select
                  id="invite-role"
                  value={inviteRole}
                  onChange={(e) => setInviteRole(e.target.value)}
                  className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                >
                  <option value="admin">Admin - Full access, can manage members</option>
                  <option value="editor">Editor - Can edit documents and sources</option>
                  <option value="reviewer">Reviewer - Can comment and suggest changes</option>
                  <option value="viewer">Viewer - Read-only access</option>
                </select>
              </div>

              <div className="flex justify-end gap-3 pt-4">
                <button
                  type="button"
                  onClick={() => {
                    setShowInviteDialog(false)
                    setInviteError('')
                    setInviteSuccess('')
                  }}
                  className="px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={inviting || !inviteEmail.trim()}
                  className="px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50"
                >
                  {inviting ? 'Sending...' : 'Send Invitation'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/workspace/[id]/page.tsx">
import { createClient } from '@/lib/supabase/server'
import { notFound, redirect } from 'next/navigation'
import Link from 'next/link'

export default async function WorkspacePage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    redirect('/login')
  }

  // Fetch workspace with membership check
  const { data: workspace, error } = await supabase
    .from('workspaces')
    .select(`
      *,
      workspace_members!inner(role, joined_at)
    `)
    .eq('id', id)
    .single()

  if (error || !workspace) {
    notFound()
  }

  const userRole = workspace.workspace_members?.[0]?.role || 'viewer'
  const isAdmin = ['owner', 'admin'].includes(userRole)

  // Fetch projects in this workspace
  const { data: projects } = await supabase
    .from('projects')
    .select('*')
    .eq('workspace_id', id)
    .order('updated_at', { ascending: false })

  // Fetch member count
  const { count: memberCount } = await supabase
    .from('workspace_members')
    .select('*', { count: 'exact', head: true })
    .eq('workspace_id', id)

  return (
    <div className="space-y-8">
      {/* Header */}
      <div className="flex justify-between items-start">
        <div>
          <div className="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400 mb-2">
            <Link href="/dashboard" className="hover:text-gray-700 dark:hover:text-gray-200">
              Dashboard
            </Link>
            <span>/</span>
            <span className="text-gray-900 dark:text-white">{workspace.name}</span>
          </div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            {workspace.name}
          </h1>
          {workspace.description && (
            <p className="text-gray-600 dark:text-gray-400 mt-1">
              {workspace.description}
            </p>
          )}
        </div>
        <div className="flex items-center gap-3">
          {isAdmin && (
            <Link
              href={`/workspace/${id}/settings`}
              className="inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700"
            >
              <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
              </svg>
              Settings
            </Link>
          )}
          <Link
            href={`/workspace/${id}/project/new`}
            className="inline-flex items-center px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
          >
            <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
            </svg>
            New Project
          </Link>
        </div>
      </div>

      {/* Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="text-2xl font-bold text-gray-900 dark:text-white">
            {projects?.length || 0}
          </div>
          <div className="text-sm text-gray-500 dark:text-gray-400">
            Projects
          </div>
        </div>
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="text-2xl font-bold text-gray-900 dark:text-white">
            {memberCount || 1}
          </div>
          <div className="text-sm text-gray-500 dark:text-gray-400">
            Members
          </div>
        </div>
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="text-2xl font-bold text-gray-900 dark:text-white capitalize">
            {userRole}
          </div>
          <div className="text-sm text-gray-500 dark:text-gray-400">
            Your Role
          </div>
        </div>
      </div>

      {/* Projects Grid */}
      <div>
        <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
          Projects
        </h2>

        {projects && projects.length > 0 ? (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {projects.map((project) => (
              <Link
                key={project.id}
                href={`/workspace/${id}/project/${project.id}`}
                className="block p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 hover:border-blue-500 dark:hover:border-blue-500 transition-colors"
              >
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  {project.name}
                </h3>
                {project.description && (
                  <p className="text-sm text-gray-500 dark:text-gray-400 mt-1 line-clamp-2">
                    {project.description}
                  </p>
                )}
                <div className="flex items-center mt-4 text-xs text-gray-400">
                  <span>Updated {new Date(project.updated_at).toLocaleDateString()}</span>
                </div>
              </Link>
            ))}
          </div>
        ) : (
          <div className="text-center py-12 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
            <svg className="w-12 h-12 mx-auto text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
            </svg>
            <h3 className="mt-4 text-lg font-medium text-gray-900 dark:text-white">
              No projects yet
            </h3>
            <p className="mt-2 text-gray-500 dark:text-gray-400">
              Create your first project to start organizing your research
            </p>
            <Link
              href={`/workspace/${id}/project/new`}
              className="mt-4 inline-flex items-center px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
            >
              Create Project
            </Link>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/workspace/new/page.tsx">
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import Link from 'next/link'

export default function NewWorkspacePage() {
  const router = useRouter()
  const [name, setName] = useState('')
  const [description, setDescription] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError('')
    setLoading(true)

    try {
      const res = await fetch('/api/workspaces', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, description }),
      })

      const data = await res.json()

      if (!res.ok) {
        throw new Error(data.error || 'Failed to create workspace')
      }

      router.push(`/workspace/${data.workspace.id}`)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="max-w-2xl mx-auto">
      <div className="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400 mb-6">
        <Link href="/dashboard" className="hover:text-gray-700 dark:hover:text-gray-200">
          Dashboard
        </Link>
        <span>/</span>
        <span className="text-gray-900 dark:text-white">New Workspace</span>
      </div>

      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white mb-6">
          Create Workspace
        </h1>

        <form onSubmit={handleSubmit} className="space-y-6">
          {error && (
            <div className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-600 dark:text-red-400 text-sm">
              {error}
            </div>
          )}

          <div>
            <label htmlFor="name" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Workspace Name *
            </label>
            <input
              type="text"
              id="name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="My Research Lab"
              required
            />
          </div>

          <div>
            <label htmlFor="description" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Description
            </label>
            <textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              rows={3}
              className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
              placeholder="A brief description of this workspace..."
            />
          </div>

          <div className="flex justify-end gap-3">
            <Link
              href="/dashboard"
              className="px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700"
            >
              Cancel
            </Link>
            <button
              type="submit"
              disabled={loading || !name.trim()}
              className="px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? 'Creating...' : 'Create Workspace'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/layout.tsx">
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import Link from 'next/link'

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    redirect('/login')
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      {/* Header */}
      <header className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center space-x-8">
              <Link href="/dashboard" className="text-xl font-bold text-gray-900 dark:text-white">
                ResearchBase
              </Link>
              <nav className="hidden md:flex space-x-4">
                <Link
                  href="/dashboard"
                  className="text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white px-3 py-2 text-sm font-medium"
                >
                  Dashboard
                </Link>
              </nav>
            </div>
            <div className="flex items-center space-x-4">
              <span className="text-sm text-gray-600 dark:text-gray-400">
                {user.email}
              </span>
              <form action="/api/auth/signout" method="POST">
                <button
                  type="submit"
                  className="text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white"
                >
                  Sign out
                </button>
              </form>
            </div>
          </div>
        </div>
      </header>

      {/* Main content */}
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {children}
      </main>
    </div>
  )
}
</file>

<file path="app/src/app/api/agents/[id]/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/agents/[id] - Get agent definition
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { data: agent, error } = await supabase
      .from('agent_definitions')
      .select('*')
      .eq('id', id)
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 404 })
    }

    return NextResponse.json({ agent })
  } catch (error) {
    console.error('Get agent error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/agents/[id] - Update agent definition
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check if it's a default agent
    const { data: existing } = await supabase
      .from('agent_definitions')
      .select('is_default')
      .eq('id', id)
      .single()

    if (existing?.is_default) {
      return NextResponse.json({ error: 'Cannot modify default agents' }, { status: 403 })
    }

    const body = await request.json()
    const updates: Record<string, unknown> = { updated_at: new Date().toISOString() }

    const allowedFields = [
      'name', 'description', 'system_prompt', 'model', 'temperature',
      'max_tokens', 'can_search_sources', 'can_search_entities',
      'can_create_entities', 'can_modify_document'
    ]

    for (const field of allowedFields) {
      if (body[field] !== undefined) {
        updates[field] = body[field]
      }
    }

    const { data: agent, error } = await supabase
      .from('agent_definitions')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ agent })
  } catch (error) {
    console.error('Update agent error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/agents/[id] - Delete agent definition
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check if it's a default agent
    const { data: existing } = await supabase
      .from('agent_definitions')
      .select('is_default')
      .eq('id', id)
      .single()

    if (existing?.is_default) {
      return NextResponse.json({ error: 'Cannot delete default agents' }, { status: 403 })
    }

    const { error } = await supabase
      .from('agent_definitions')
      .delete()
      .eq('id', id)

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Delete agent error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/agents/disagreements/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

/**
 * GET /api/agents/disagreements - List agent disagreements
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const resolved = searchParams.get('resolved')

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    let query = supabase
      .from('agent_disagreements')
      .select(`
        *,
        agent_a:agent_executions!agent_a_execution_id (
          id,
          agent:agent_definitions (id, name, agent_type)
        ),
        agent_b:agent_executions!agent_b_execution_id (
          id,
          agent:agent_definitions (id, name, agent_type)
        )
      `)
      .eq('workspace_id', workspaceId)

    if (resolved === 'true') {
      query = query.not('resolved_at', 'is', null)
    } else if (resolved === 'false') {
      query = query.is('resolved_at', null)
    }

    const { data: disagreements, error } = await query
      .order('created_at', { ascending: false })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ disagreements })
  } catch (error) {
    console.error('List disagreements error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/agents/disagreements - Create or resolve a disagreement
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      workspace_id,
      pipeline_id,
      agent_a_execution_id,
      agent_b_execution_id,
      topic,
      agent_a_position,
      agent_b_position,
      auto_resolve
    } = body

    if (!workspace_id || !agent_a_execution_id || !agent_b_execution_id || !topic) {
      return NextResponse.json({
        error: 'workspace_id, agent_a_execution_id, agent_b_execution_id, and topic required'
      }, { status: 400 })
    }

    // Create the disagreement
    const { data: disagreement, error } = await supabase
      .from('agent_disagreements')
      .insert({
        workspace_id,
        pipeline_id,
        agent_a_execution_id,
        agent_b_execution_id,
        topic,
        agent_a_position,
        agent_b_position
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    // Auto-resolve using arbitration agent
    if (auto_resolve) {
      const response = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1500,
        messages: [{
          role: 'user',
          content: `You are an arbitration agent. Two AI agents have reached different conclusions on a topic. Analyze both positions and provide a resolution.

Topic: ${topic}

Agent A's Position:
${agent_a_position}

Agent B's Position:
${agent_b_position}

Provide a balanced resolution that:
1. Acknowledges the valid points in each position
2. Identifies any errors or weaknesses
3. Synthesizes a final answer or recommendation

Respond with JSON:
{
  "resolution": "Your balanced resolution",
  "agent_a_valid_points": ["List valid points from A"],
  "agent_b_valid_points": ["List valid points from B"],
  "errors_identified": ["Any errors found"],
  "confidence": 0.0-1.0
}`
        }]
      })

      const content = response.content[0]
      if (content.type === 'text') {
        try {
          let jsonStr = content.text.trim()
          if (jsonStr.startsWith('```')) {
            jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
          }
          const parsed = JSON.parse(jsonStr)

          const { data: resolved, error: resolveError } = await supabase
            .from('agent_disagreements')
            .update({
              resolution: parsed.resolution,
              resolved_by: 'arbitration_agent',
              resolved_at: new Date().toISOString()
            })
            .eq('id', disagreement.id)
            .select()
            .single()

          if (!resolveError) {
            return NextResponse.json({
              disagreement: resolved,
              arbitration: parsed
            }, { status: 201 })
          }
        } catch {
          // Continue without auto-resolution
        }
      }
    }

    return NextResponse.json({ disagreement }, { status: 201 })
  } catch (error) {
    console.error('Create disagreement error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/agents/disagreements - Resolve a disagreement manually
 */
export async function PATCH(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { disagreement_id, resolution } = body

    if (!disagreement_id || !resolution) {
      return NextResponse.json({ error: 'disagreement_id and resolution required' }, { status: 400 })
    }

    const { data: disagreement, error } = await supabase
      .from('agent_disagreements')
      .update({
        resolution,
        resolved_by: 'user',
        resolved_at: new Date().toISOString()
      })
      .eq('id', disagreement_id)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ disagreement })
  } catch (error) {
    console.error('Resolve disagreement error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/agents/execute/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

interface AgentDefinition {
  id: string
  name: string
  agent_type: string
  system_prompt: string
  model: string
  temperature: number
  max_tokens: number
  can_search_sources: boolean
  can_search_entities: boolean
  can_create_entities: boolean
  can_modify_document: boolean
}

interface ReasoningStep {
  step_number: number
  step_type: 'thought' | 'action' | 'observation' | 'conclusion'
  content: string
  sources_consulted: string[]
  entities_referenced: string[]
}

/**
 * POST /api/agents/execute - Execute an agent
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      workspace_id,
      agent_id,
      document_id,
      input_data,
      pipeline_id
    } = body

    if (!workspace_id || !agent_id || !input_data) {
      return NextResponse.json({
        error: 'workspace_id, agent_id, and input_data required'
      }, { status: 400 })
    }

    // Get agent definition
    const { data: agent, error: agentError } = await supabase
      .from('agent_definitions')
      .select('*')
      .eq('id', agent_id)
      .single()

    if (agentError || !agent) {
      return NextResponse.json({ error: 'Agent not found' }, { status: 404 })
    }

    const agentDef = agent as AgentDefinition

    // Create execution record
    const { data: execution, error: execError } = await supabase
      .from('agent_executions')
      .insert({
        workspace_id,
        pipeline_id,
        agent_id,
        document_id,
        input_data,
        status: 'running',
        started_at: new Date().toISOString()
      })
      .select()
      .single()

    if (execError) {
      return NextResponse.json({ error: execError.message }, { status: 500 })
    }

    try {
      // Build context based on agent capabilities
      let context = ''

      if (agentDef.can_search_sources) {
        const { data: sources } = await supabase
          .from('sources')
          .select('id, title, abstract')
          .eq('workspace_id', workspace_id)
          .limit(20)

        if (sources && sources.length > 0) {
          context += '\n\nAvailable Sources:\n'
          sources.forEach((s, i) => {
            context += `${i + 1}. [${s.id}] ${s.title}\n   ${s.abstract || 'No abstract'}\n`
          })
        }
      }

      if (agentDef.can_search_entities) {
        const { data: entities } = await supabase
          .from('knowledge_entities')
          .select('id, name, entity_type, description')
          .eq('workspace_id', workspace_id)
          .limit(30)

        if (entities && entities.length > 0) {
          context += '\n\nKnowledge Entities:\n'
          entities.forEach((e, i) => {
            context += `${i + 1}. [${e.entity_type}] ${e.name}: ${e.description || 'No description'}\n`
          })
        }
      }

      // Execute agent with reasoning
      const response = await anthropic.messages.create({
        model: agentDef.model,
        max_tokens: agentDef.max_tokens,
        temperature: agentDef.temperature,
        messages: [{
          role: 'user',
          content: `${agentDef.system_prompt}

${context}

Task Input:
${JSON.stringify(input_data, null, 2)}

Respond with JSON containing your reasoning process and final output:
{
  "reasoning": [
    {"step": 1, "type": "thought", "content": "Initial analysis..."},
    {"step": 2, "type": "action", "content": "Searching for..."},
    {"step": 3, "type": "observation", "content": "Found..."},
    {"step": 4, "type": "conclusion", "content": "Therefore..."}
  ],
  "output": {
    "result": "Your main output here",
    "confidence": 0.0-1.0,
    "sources_used": ["source_id1", "source_id2"],
    "entities_referenced": ["entity_id1", "entity_id2"],
    "suggestions": ["Optional follow-up suggestions"]
  }
}`
        }]
      })

      const responseContent = response.content[0]
      if (responseContent.type !== 'text') {
        throw new Error('Invalid response from agent')
      }

      let jsonStr = responseContent.text.trim()
      if (jsonStr.startsWith('```')) {
        jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
      }

      const parsed = JSON.parse(jsonStr)

      // Save reasoning traces
      const reasoningSteps: ReasoningStep[] = (parsed.reasoning || []).map(
        (r: { step: number; type: string; content: string }, i: number) => ({
          step_number: r.step || i + 1,
          step_type: r.type || 'thought',
          content: r.content,
          sources_consulted: [],
          entities_referenced: []
        })
      )

      for (const step of reasoningSteps) {
        await supabase
          .from('reasoning_traces')
          .insert({
            execution_id: execution.id,
            step_number: step.step_number,
            step_type: step.step_type,
            content: step.content,
            sources_consulted: step.sources_consulted,
            entities_referenced: step.entities_referenced,
            started_at: new Date().toISOString(),
            completed_at: new Date().toISOString()
          })
      }

      // Update execution with results
      const { data: completedExec, error: updateError } = await supabase
        .from('agent_executions')
        .update({
          status: 'completed',
          completed_at: new Date().toISOString(),
          output_data: parsed.output,
          confidence: parsed.output?.confidence,
          token_usage: {
            input_tokens: response.usage?.input_tokens,
            output_tokens: response.usage?.output_tokens
          }
        })
        .eq('id', execution.id)
        .select()
        .single()

      if (updateError) {
        throw updateError
      }

      // Fetch reasoning traces
      const { data: traces } = await supabase
        .from('reasoning_traces')
        .select('*')
        .eq('execution_id', execution.id)
        .order('step_number', { ascending: true })

      return NextResponse.json({
        execution: completedExec,
        reasoning: traces,
        output: parsed.output
      })
    } catch (execError) {
      // Update execution as failed
      await supabase
        .from('agent_executions')
        .update({
          status: 'failed',
          completed_at: new Date().toISOString(),
          error_message: execError instanceof Error ? execError.message : 'Unknown error'
        })
        .eq('id', execution.id)

      throw execError
    }
  } catch (error) {
    console.error('Execute agent error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/agents/executions/[id]/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/agents/executions/[id] - Get execution with reasoning traces
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get execution
    const { data: execution, error: execError } = await supabase
      .from('agent_executions')
      .select(`
        *,
        agent:agent_definitions (id, name, agent_type, description),
        pipeline:agent_pipelines (id, name)
      `)
      .eq('id', id)
      .single()

    if (execError) {
      return NextResponse.json({ error: execError.message }, { status: 404 })
    }

    // Get reasoning traces
    const { data: traces, error: tracesError } = await supabase
      .from('reasoning_traces')
      .select('*')
      .eq('execution_id', id)
      .order('step_number', { ascending: true })

    if (tracesError) {
      return NextResponse.json({ error: tracesError.message }, { status: 500 })
    }

    return NextResponse.json({
      execution,
      reasoning: traces
    })
  } catch (error) {
    console.error('Get execution error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/agents/executions/[id] - Cancel a running execution
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Only cancel running executions
    const { data: execution, error: updateError } = await supabase
      .from('agent_executions')
      .update({
        status: 'failed',
        completed_at: new Date().toISOString(),
        error_message: 'Cancelled by user'
      })
      .eq('id', id)
      .eq('status', 'running')
      .select()
      .single()

    if (updateError) {
      return NextResponse.json({ error: 'Execution not found or not running' }, { status: 404 })
    }

    return NextResponse.json({ execution })
  } catch (error) {
    console.error('Cancel execution error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/agents/executions/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/agents/executions - List agent executions
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const agentId = searchParams.get('agent_id')
    const pipelineId = searchParams.get('pipeline_id')
    const status = searchParams.get('status')
    const limit = parseInt(searchParams.get('limit') || '50')

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    let query = supabase
      .from('agent_executions')
      .select(`
        *,
        agent:agent_definitions (id, name, agent_type),
        pipeline:agent_pipelines (id, name)
      `)
      .eq('workspace_id', workspaceId)

    if (agentId) {
      query = query.eq('agent_id', agentId)
    }

    if (pipelineId) {
      query = query.eq('pipeline_id', pipelineId)
    }

    if (status) {
      query = query.eq('status', status)
    }

    const { data: executions, error } = await query
      .order('created_at', { ascending: false })
      .limit(limit)

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ executions })
  } catch (error) {
    console.error('List executions error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/agents/pipelines/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/agents/pipelines - List agent pipelines
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    const { data: pipelines, error } = await supabase
      .from('agent_pipelines')
      .select('*')
      .eq('workspace_id', workspaceId)
      .order('created_at', { ascending: false })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ pipelines })
  } catch (error) {
    console.error('List pipelines error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/agents/pipelines - Create an agent pipeline
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      workspace_id,
      name,
      description,
      steps,
      parallel_groups,
      trigger_type,
      trigger_config
    } = body

    if (!workspace_id || !name || !steps) {
      return NextResponse.json({ error: 'workspace_id, name, and steps required' }, { status: 400 })
    }

    // Validate steps structure
    if (!Array.isArray(steps) || steps.length === 0) {
      return NextResponse.json({ error: 'steps must be a non-empty array' }, { status: 400 })
    }

    const { data: pipeline, error } = await supabase
      .from('agent_pipelines')
      .insert({
        workspace_id,
        name,
        description,
        steps,
        parallel_groups: parallel_groups || [],
        trigger_type: trigger_type || 'manual',
        trigger_config: trigger_config || {},
        is_active: true,
        created_by: user.id
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ pipeline }, { status: 201 })
  } catch (error) {
    console.error('Create pipeline error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/agents/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/agents - List agent definitions
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const agentType = searchParams.get('type')
    const includeDefaults = searchParams.get('include_defaults') !== 'false'

    let query = supabase
      .from('agent_definitions')
      .select('*')

    if (workspaceId) {
      if (includeDefaults) {
        query = query.or(`workspace_id.eq.${workspaceId},is_default.eq.true`)
      } else {
        query = query.eq('workspace_id', workspaceId)
      }
    } else if (includeDefaults) {
      query = query.eq('is_default', true)
    }

    if (agentType) {
      query = query.eq('agent_type', agentType)
    }

    const { data: agents, error } = await query.order('is_default', { ascending: false })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ agents })
  } catch (error) {
    console.error('List agents error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/agents - Create a custom agent
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      workspace_id,
      name,
      agent_type,
      description,
      system_prompt,
      model,
      temperature,
      max_tokens,
      can_search_sources,
      can_search_entities,
      can_create_entities,
      can_modify_document
    } = body

    if (!workspace_id || !name || !agent_type || !system_prompt) {
      return NextResponse.json({
        error: 'workspace_id, name, agent_type, and system_prompt required'
      }, { status: 400 })
    }

    const { data: agent, error } = await supabase
      .from('agent_definitions')
      .insert({
        workspace_id,
        name,
        agent_type,
        description,
        system_prompt,
        model: model || 'claude-sonnet-4-20250514',
        temperature: temperature ?? 0.7,
        max_tokens: max_tokens || 2000,
        can_search_sources: can_search_sources || false,
        can_search_entities: can_search_entities || false,
        can_create_entities: can_create_entities || false,
        can_modify_document: can_modify_document || false,
        is_default: false,
        created_by: user.id
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ agent }, { status: 201 })
  } catch (error) {
    console.error('Create agent error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/ai/edit/route.ts">
import { createClient } from '@/lib/supabase/server'
import { performAIEdit, AIEditAction } from '@/lib/anthropic'
import { NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { action, text, context, styleReference, personaDescription, documentId } = body

    // Validate action
    const validActions: AIEditAction[] = [
      'summarize', 'rewrite', 'expand', 'shorten', 'define',
      'humanize', 'style_match', 'persona', 'obfuscate', 'continue'
    ]

    if (!action || !validActions.includes(action)) {
      return NextResponse.json({
        error: `Invalid action. Valid actions: ${validActions.join(', ')}`
      }, { status: 400 })
    }

    if (!text || typeof text !== 'string' || text.trim().length === 0) {
      return NextResponse.json({ error: 'Text is required' }, { status: 400 })
    }

    // Perform the AI edit
    const result = await performAIEdit({
      action,
      text: text.trim(),
      context,
      styleReference,
      personaDescription
    })

    if (!result.success) {
      return NextResponse.json({ error: result.error }, { status: 500 })
    }

    // Log the AI job for provenance tracking
    try {
      await supabase.from('ai_jobs').insert({
        user_id: user.id,
        document_id: documentId || null,
        job_type: 'text_edit',
        model: 'claude-sonnet-4-20250514',
        prompt_tokens: result.tokensUsed?.input || 0,
        completion_tokens: result.tokensUsed?.output || 0,
        metadata: {
          action,
          input_length: text.length,
          output_length: result.result?.length || 0
        }
      })
    } catch (logError) {
      // Don't fail the request if logging fails
      console.warn('Failed to log AI job:', logError)
    }

    return NextResponse.json({
      success: true,
      action,
      original: text,
      result: result.result,
      tokensUsed: result.tokensUsed
    })

  } catch (error) {
    console.error('AI edit handler error:', error)
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Internal server error'
    }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/auth/signout/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

export async function POST() {
  const supabase = await createClient()
  await supabase.auth.signOut()
  return NextResponse.redirect(new URL('/login', process.env.NEXT_PUBLIC_SUPABASE_URL || 'http://localhost:3000'), {
    status: 302,
  })
}
</file>

<file path="app/src/app/api/citations/verify/route.ts">
import { createClient } from '@/lib/supabase/server'
import { getAnthropicClient } from '@/lib/anthropic'
import { NextRequest, NextResponse } from 'next/server'

interface VerificationResult {
  citationId: string
  sourceId: string
  status: 'supported' | 'contradicted' | 'partial' | 'unverifiable'
  confidence: number
  explanation: string
  relevantChunks: {
    id: string
    content: string
    similarity: number
  }[]
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { citedText, sourceId, documentId } = body

    if (!citedText || typeof citedText !== 'string') {
      return NextResponse.json({ error: 'Cited text is required' }, { status: 400 })
    }

    if (!sourceId) {
      return NextResponse.json({ error: 'Source ID is required' }, { status: 400 })
    }

    // Get source info
    const { data: source, error: sourceError } = await supabase
      .from('sources')
      .select('id, title')
      .eq('id', sourceId)
      .single()

    if (sourceError || !source) {
      return NextResponse.json({ error: 'Source not found' }, { status: 404 })
    }

    // Get source chunks for this source
    const { data: chunks, error: chunksError } = await supabase
      .from('source_chunks')
      .select('id, content')
      .eq('source_id', sourceId)
      .limit(20)

    if (chunksError) {
      console.error('Error fetching chunks:', chunksError)
      return NextResponse.json({ error: 'Failed to fetch source content' }, { status: 500 })
    }

    if (!chunks || chunks.length === 0) {
      return NextResponse.json({
        verification: {
          status: 'unverifiable',
          confidence: 0,
          explanation: 'Source has not been processed yet. Please process the PDF first.',
          relevantChunks: []
        }
      })
    }

    // Check if Anthropic client is available
    const anthropic = getAnthropicClient()

    if (!anthropic) {
      // Return a basic verification without AI analysis
      return NextResponse.json({
        verification: {
          status: 'unverifiable',
          confidence: 0,
          explanation: 'AI verification not available. Add ANTHROPIC_API_KEY to enable citation verification.',
          relevantChunks: chunks.slice(0, 3).map(c => ({
            id: c.id,
            content: c.content.substring(0, 200) + '...',
            similarity: 0
          }))
        }
      })
    }

    // Build context from chunks
    const context = chunks.map((c, i) => `[Chunk ${i + 1}]: ${c.content}`).join('\n\n')

    // Use Claude to verify the citation
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1024,
      system: `You are a citation verification assistant. Your job is to verify whether a cited claim is supported by the source material provided.

Analyze the claim and the source content, then respond with a JSON object containing:
- status: one of "supported", "contradicted", "partial", or "unverifiable"
  - "supported": The source clearly supports this claim
  - "contradicted": The source contradicts this claim
  - "partial": The source partially supports this claim but with important nuances
  - "unverifiable": Cannot determine from the provided source content
- confidence: a number from 0 to 1 indicating your confidence
- explanation: a brief explanation of your assessment
- relevant_chunks: array of chunk numbers (1-indexed) that are most relevant

Respond ONLY with the JSON object, no other text.`,
      messages: [
        {
          role: 'user',
          content: `Source: "${source.title}"

Source Content:
${context}

---

Cited Claim: "${citedText}"

Verify whether the source supports this claim.`
        }
      ]
    })

    const textContent = response.content.find(c => c.type === 'text')

    if (!textContent || textContent.type !== 'text') {
      return NextResponse.json({ error: 'No response from verification' }, { status: 500 })
    }

    try {
      const verification = JSON.parse(textContent.text)

      // Get relevant chunks based on AI response
      const relevantChunks = (verification.relevant_chunks || [])
        .filter((i: number) => i >= 1 && i <= chunks.length)
        .map((i: number) => ({
          id: chunks[i - 1].id,
          content: chunks[i - 1].content.substring(0, 300) + '...',
          similarity: verification.confidence
        }))

      // Log the verification run
      try {
        await supabase.from('citation_verification_runs').insert({
          document_id: documentId || null,
          run_by: user.id,
          run_type: 'single',
          summary: {
            total: 1,
            supported: verification.status === 'supported' ? 1 : 0,
            contradicted: verification.status === 'contradicted' ? 1 : 0,
            partial: verification.status === 'partial' ? 1 : 0,
            unverifiable: verification.status === 'unverifiable' ? 1 : 0
          }
        })
      } catch (logError) {
        console.warn('Failed to log verification run:', logError)
      }

      return NextResponse.json({
        verification: {
          status: verification.status,
          confidence: verification.confidence,
          explanation: verification.explanation,
          relevantChunks
        }
      })

    } catch (parseError) {
      console.error('Error parsing verification response:', parseError)
      return NextResponse.json({
        verification: {
          status: 'unverifiable',
          confidence: 0,
          explanation: 'Error processing verification response',
          relevantChunks: []
        }
      })
    }

  } catch (error) {
    console.error('Citation verification error:', error)
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Internal server error'
    }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/claims/extract/route.ts">
import { createClient } from '@/lib/supabase/server'
import { getAnthropicClient } from '@/lib/anthropic'
import { NextRequest, NextResponse } from 'next/server'

export interface Claim {
  id: string
  type: 'claim' | 'assumption' | 'definition' | 'evidence'
  text: string
  confidence: number
  startOffset?: number
  endOffset?: number
}

export interface ClaimLink {
  sourceId: string
  targetId: string
  relationship: 'supports' | 'contradicts' | 'depends_on' | 'refines' | 'exemplifies'
  strength: number
}

export interface ClaimGraph {
  claims: Claim[]
  links: ClaimLink[]
  summary: string
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { content, documentId } = body

    if (!content || typeof content !== 'string') {
      return NextResponse.json({ error: 'Content is required' }, { status: 400 })
    }

    // Strip HTML tags for analysis
    const plainText = content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim()

    if (plainText.length < 50) {
      return NextResponse.json({
        graph: {
          claims: [],
          links: [],
          summary: 'Not enough content to extract claims.'
        }
      })
    }

    const anthropic = getAnthropicClient()

    if (!anthropic) {
      return NextResponse.json({
        error: 'Claim extraction requires ANTHROPIC_API_KEY to be configured.'
      }, { status: 500 })
    }

    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 4096,
      system: `You are an expert at analyzing academic and research texts. Extract the logical structure of arguments from the text.

For each piece of content, identify:
1. **Claims**: Main assertions or arguments being made
2. **Assumptions**: Unstated premises the argument relies on
3. **Definitions**: Key terms being defined or used with specific meaning
4. **Evidence**: Facts, data, or citations supporting claims

Also identify relationships between these elements:
- supports: one element provides evidence for another
- contradicts: elements are in tension or conflict
- depends_on: one element requires another to be true
- refines: one element adds nuance to another
- exemplifies: one element is an example of another

Respond with a JSON object:
{
  "claims": [
    {"id": "c1", "type": "claim|assumption|definition|evidence", "text": "...", "confidence": 0.0-1.0}
  ],
  "links": [
    {"sourceId": "c1", "targetId": "c2", "relationship": "supports|contradicts|depends_on|refines|exemplifies", "strength": 0.0-1.0}
  ],
  "summary": "Brief summary of the argument structure"
}

Be thorough but focused. Extract 5-15 key elements. Only output the JSON.`,
      messages: [
        {
          role: 'user',
          content: `Analyze the following text and extract its argument structure:\n\n${plainText.substring(0, 8000)}`
        }
      ]
    })

    const textContent = response.content.find(c => c.type === 'text')

    if (!textContent || textContent.type !== 'text') {
      return NextResponse.json({ error: 'No response from analysis' }, { status: 500 })
    }

    try {
      const graph: ClaimGraph = JSON.parse(textContent.text)

      // Store claims in database if documentId provided
      if (documentId) {
        try {
          // Clear existing claims for this document
          await supabase
            .from('claims')
            .delete()
            .eq('document_id', documentId)

          // Insert new claims
          if (graph.claims.length > 0) {
            const claimRecords = graph.claims.map(claim => ({
              id: claim.id.startsWith('c') ? undefined : claim.id, // Let DB generate ID
              document_id: documentId,
              claim_type: claim.type,
              text: claim.text,
              confidence: claim.confidence,
              metadata: { originalId: claim.id }
            }))

            const { data: insertedClaims, error: insertError } = await supabase
              .from('claims')
              .insert(claimRecords)
              .select('id, metadata')

            if (!insertError && insertedClaims) {
              // Create ID mapping
              const idMap = new Map<string, string>()
              insertedClaims.forEach(c => {
                if (c.metadata?.originalId) {
                  idMap.set(c.metadata.originalId, c.id)
                }
              })

              // Insert links with mapped IDs
              if (graph.links.length > 0) {
                const linkRecords = graph.links
                  .filter(link => idMap.has(link.sourceId) && idMap.has(link.targetId))
                  .map(link => ({
                    source_claim_id: idMap.get(link.sourceId),
                    target_claim_id: idMap.get(link.targetId),
                    link_type: link.relationship,
                    strength: link.strength
                  }))

                if (linkRecords.length > 0) {
                  await supabase.from('claim_links').insert(linkRecords)
                }
              }
            }
          }
        } catch (dbError) {
          console.warn('Failed to store claims in database:', dbError)
        }
      }

      return NextResponse.json({ graph })

    } catch (parseError) {
      console.error('Error parsing claim extraction response:', parseError)
      return NextResponse.json({
        error: 'Failed to parse analysis results'
      }, { status: 500 })
    }

  } catch (error) {
    console.error('Claim extraction error:', error)
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Internal server error'
    }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/diff/semantic/route.ts">
import { createClient } from '@/lib/supabase/server'
import { getAnthropicClient } from '@/lib/anthropic'
import { NextRequest, NextResponse } from 'next/server'

export interface SemanticChange {
  type: 'added' | 'removed' | 'modified' | 'strengthened' | 'weakened'
  category: 'claim' | 'argument' | 'evidence' | 'structure' | 'tone'
  description: string
  importance: 'high' | 'medium' | 'low'
  beforeText?: string
  afterText?: string
}

export interface SemanticDiff {
  changes: SemanticChange[]
  summary: string
  overallAssessment: string
  claimsAdded: number
  claimsRemoved: number
  claimsModified: number
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { beforeContent, afterContent, documentId, branchA, branchB } = body

    if (!beforeContent || !afterContent) {
      return NextResponse.json({
        error: 'Both beforeContent and afterContent are required'
      }, { status: 400 })
    }

    // Strip HTML tags
    const beforeText = beforeContent.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim()
    const afterText = afterContent.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim()

    if (beforeText === afterText) {
      return NextResponse.json({
        diff: {
          changes: [],
          summary: 'No changes detected between versions.',
          overallAssessment: 'The content is identical.',
          claimsAdded: 0,
          claimsRemoved: 0,
          claimsModified: 0
        }
      })
    }

    const anthropic = getAnthropicClient()

    if (!anthropic) {
      return NextResponse.json({
        error: 'Semantic diff requires ANTHROPIC_API_KEY to be configured.'
      }, { status: 500 })
    }

    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 4096,
      system: `You are an expert at analyzing changes in academic and research documents. Compare two versions of a document and identify semantic changes - not just text differences, but changes in meaning, arguments, and claims.

Categorize changes as:
- **added**: New claims, arguments, or evidence introduced
- **removed**: Claims, arguments, or evidence that were deleted
- **modified**: Claims that were changed in meaning
- **strengthened**: Arguments made more forceful or better supported
- **weakened**: Arguments made less certain or lost support

Categories:
- claim: Main assertions or conclusions
- argument: Logical reasoning or supporting points
- evidence: Facts, data, citations
- structure: Organization or flow changes
- tone: Changes in certainty, hedging, or voice

Respond with JSON:
{
  "changes": [
    {
      "type": "added|removed|modified|strengthened|weakened",
      "category": "claim|argument|evidence|structure|tone",
      "description": "Clear description of what changed",
      "importance": "high|medium|low",
      "beforeText": "relevant excerpt from before (if applicable)",
      "afterText": "relevant excerpt from after (if applicable)"
    }
  ],
  "summary": "2-3 sentence summary of the key changes",
  "overallAssessment": "Assessment of whether the changes improve, maintain, or weaken the document",
  "claimsAdded": number,
  "claimsRemoved": number,
  "claimsModified": number
}

Focus on meaningful semantic changes. Only output JSON.`,
      messages: [
        {
          role: 'user',
          content: `Compare these two versions of a document:

=== BEFORE ===
${beforeText.substring(0, 6000)}

=== AFTER ===
${afterText.substring(0, 6000)}

Identify the semantic changes between these versions.`
        }
      ]
    })

    const textContent = response.content.find(c => c.type === 'text')

    if (!textContent || textContent.type !== 'text') {
      return NextResponse.json({ error: 'No response from analysis' }, { status: 500 })
    }

    try {
      const diff: SemanticDiff = JSON.parse(textContent.text)

      // Log the diff if document context provided
      if (documentId) {
        try {
          await supabase.from('ai_jobs').insert({
            user_id: user.id,
            document_id: documentId,
            job_type: 'semantic_diff',
            model: 'claude-sonnet-4-20250514',
            metadata: {
              branchA,
              branchB,
              changesCount: diff.changes.length,
              claimsAdded: diff.claimsAdded,
              claimsRemoved: diff.claimsRemoved,
              claimsModified: diff.claimsModified
            }
          })
        } catch (logError) {
          console.warn('Failed to log semantic diff:', logError)
        }
      }

      return NextResponse.json({ diff })

    } catch (parseError) {
      console.error('Error parsing semantic diff response:', parseError)
      return NextResponse.json({
        error: 'Failed to parse diff results'
      }, { status: 500 })
    }

  } catch (error) {
    console.error('Semantic diff error:', error)
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Internal server error'
    }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/documents/[id]/branches/[branchId]/diff/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

interface SectionDiff {
  type: 'added' | 'removed' | 'modified' | 'unchanged'
  order_index: number
  source_section?: {
    id: string
    title: string | null
    content_text: string | null
  }
  target_section?: {
    id: string
    title: string | null
    content_text: string | null
  }
  changes?: string[] // List of specific changes for modified sections
}

/**
 * GET /api/documents/[id]/branches/[branchId]/diff?compare_to=<branchId>
 * Compare two branches
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; branchId: string }> }
) {
  try {
    const { id, branchId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const compareToBranchId = searchParams.get('compare_to')

    if (!compareToBranchId) {
      return NextResponse.json({ error: 'compare_to parameter required' }, { status: 400 })
    }

    // Get sections from source branch (the one being compared)
    const { data: sourceSections, error: sourceError } = await supabase
      .from('doc_sections')
      .select('id, order_index, title, content_text, content_json')
      .eq('branch_id', branchId)
      .order('order_index')

    if (sourceError) {
      return NextResponse.json({ error: 'Failed to fetch source branch' }, { status: 500 })
    }

    // Get sections from target branch (the one we're comparing to)
    const { data: targetSections, error: targetError } = await supabase
      .from('doc_sections')
      .select('id, order_index, title, content_text, content_json')
      .eq('branch_id', compareToBranchId)
      .order('order_index')

    if (targetError) {
      return NextResponse.json({ error: 'Failed to fetch target branch' }, { status: 500 })
    }

    // Build diff
    const diffs: SectionDiff[] = []
    const targetMap = new Map(targetSections?.map(s => [s.order_index, s]) || [])
    const sourceMap = new Map(sourceSections?.map(s => [s.order_index, s]) || [])

    // Find all unique order indices
    const allIndices = new Set([
      ...(sourceSections?.map(s => s.order_index) || []),
      ...(targetSections?.map(s => s.order_index) || []),
    ])

    for (const index of Array.from(allIndices).sort((a, b) => a - b)) {
      const sourceSection = sourceMap.get(index)
      const targetSection = targetMap.get(index)

      if (sourceSection && !targetSection) {
        // Section added in source
        diffs.push({
          type: 'added',
          order_index: index,
          source_section: {
            id: sourceSection.id,
            title: sourceSection.title,
            content_text: sourceSection.content_text,
          },
        })
      } else if (!sourceSection && targetSection) {
        // Section removed in source (exists in target)
        diffs.push({
          type: 'removed',
          order_index: index,
          target_section: {
            id: targetSection.id,
            title: targetSection.title,
            content_text: targetSection.content_text,
          },
        })
      } else if (sourceSection && targetSection) {
        // Both exist - check if modified
        const contentChanged = sourceSection.content_text !== targetSection.content_text
        const titleChanged = sourceSection.title !== targetSection.title

        if (contentChanged || titleChanged) {
          diffs.push({
            type: 'modified',
            order_index: index,
            source_section: {
              id: sourceSection.id,
              title: sourceSection.title,
              content_text: sourceSection.content_text,
            },
            target_section: {
              id: targetSection.id,
              title: targetSection.title,
              content_text: targetSection.content_text,
            },
            changes: [
              ...(titleChanged ? ['Title changed'] : []),
              ...(contentChanged ? ['Content modified'] : []),
            ],
          })
        } else {
          diffs.push({
            type: 'unchanged',
            order_index: index,
            source_section: {
              id: sourceSection.id,
              title: sourceSection.title,
              content_text: sourceSection.content_text,
            },
          })
        }
      }
    }

    // Summary statistics
    const summary = {
      total_sections: diffs.length,
      added: diffs.filter(d => d.type === 'added').length,
      removed: diffs.filter(d => d.type === 'removed').length,
      modified: diffs.filter(d => d.type === 'modified').length,
      unchanged: diffs.filter(d => d.type === 'unchanged').length,
    }

    return NextResponse.json({
      source_branch_id: branchId,
      target_branch_id: compareToBranchId,
      diffs,
      summary,
    })

  } catch (error) {
    console.error('Branch diff error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/documents/[id]/branches/[branchId]/diff - Get AI-powered diff analysis
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; branchId: string }> }
) {
  try {
    const { id, branchId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { compare_to: compareToBranchId, section_index } = body

    if (!compareToBranchId) {
      return NextResponse.json({ error: 'compare_to required' }, { status: 400 })
    }

    // Get specific sections to compare
    const { data: sourceSection } = await supabase
      .from('doc_sections')
      .select('content_text, title')
      .eq('branch_id', branchId)
      .eq('order_index', section_index)
      .single()

    const { data: targetSection } = await supabase
      .from('doc_sections')
      .select('content_text, title')
      .eq('branch_id', compareToBranchId)
      .eq('order_index', section_index)
      .single()

    if (!sourceSection && !targetSection) {
      return NextResponse.json({ error: 'Sections not found' }, { status: 404 })
    }

    // Use AI to analyze the diff
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1500,
      messages: [
        {
          role: 'user',
          content: `Compare these two versions of a document section and provide a detailed analysis of the changes.

Original version:
"""
${targetSection?.content_text || '(Section does not exist)'}
"""

Modified version:
"""
${sourceSection?.content_text || '(Section deleted)'}
"""

Provide a JSON response:
{
  "summary": "Brief summary of what changed",
  "change_type": "addition" | "deletion" | "revision" | "restructure" | "minor_edit",
  "semantic_changes": [
    {"type": "meaning_changed" | "tone_changed" | "detail_added" | "detail_removed" | "reorganized", "description": "what changed"}
  ],
  "additions": ["list of added content/ideas"],
  "deletions": ["list of removed content/ideas"],
  "suggestions": ["any suggestions for improving the merge"]
}

Only return valid JSON.`,
        },
      ],
    })

    const content = response.content[0]
    if (content.type !== 'text') {
      throw new Error('Unexpected response format')
    }

    let analysis
    try {
      let jsonStr = content.text.trim()
      if (jsonStr.startsWith('```')) jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
      analysis = JSON.parse(jsonStr)
    } catch {
      analysis = {
        summary: 'Unable to analyze changes',
        change_type: 'revision',
        semantic_changes: [],
        additions: [],
        deletions: [],
        suggestions: [],
      }
    }

    return NextResponse.json({
      section_index,
      source_text: sourceSection?.content_text,
      target_text: targetSection?.content_text,
      analysis,
    })

  } catch (error) {
    console.error('AI diff analysis error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/documents/[id]/branches/[branchId]/merge/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

interface MergeConflict {
  section_index: number
  source_content: string | null
  target_content: string | null
  conflict_type: 'both_modified' | 'deleted_modified'
  resolution?: 'keep_source' | 'keep_target' | 'merge' | 'custom'
  merged_content?: string
}

/**
 * POST /api/documents/[id]/branches/[branchId]/merge - Merge branch into target
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; branchId: string }> }
) {
  try {
    const { id, branchId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      target_branch_id,
      resolutions = [], // Array of conflict resolutions
      auto_merge = false,
      merge_message,
    } = body

    if (!target_branch_id) {
      return NextResponse.json({ error: 'target_branch_id required' }, { status: 400 })
    }

    // Get source branch (the one being merged)
    const { data: sourceBranch } = await supabase
      .from('doc_branches')
      .select('*')
      .eq('id', branchId)
      .eq('document_id', id)
      .single()

    if (!sourceBranch) {
      return NextResponse.json({ error: 'Source branch not found' }, { status: 404 })
    }

    // Get target branch
    const { data: targetBranch } = await supabase
      .from('doc_branches')
      .select('*')
      .eq('id', target_branch_id)
      .eq('document_id', id)
      .single()

    if (!targetBranch) {
      return NextResponse.json({ error: 'Target branch not found' }, { status: 404 })
    }

    // Get sections from both branches
    const { data: sourceSections } = await supabase
      .from('doc_sections')
      .select('*')
      .eq('branch_id', branchId)
      .order('order_index')

    const { data: targetSections } = await supabase
      .from('doc_sections')
      .select('*')
      .eq('branch_id', target_branch_id)
      .order('order_index')

    const targetMap = new Map(targetSections?.map(s => [s.order_index, s]) || [])
    const sourceMap = new Map(sourceSections?.map(s => [s.order_index, s]) || [])

    // Detect conflicts
    const conflicts: MergeConflict[] = []

    for (const [index, sourceSection] of sourceMap) {
      const targetSection = targetMap.get(index)

      if (targetSection) {
        // Both have this section - check if both modified from parent
        if (sourceSection.content_text !== targetSection.content_text) {
          conflicts.push({
            section_index: index,
            source_content: sourceSection.content_text,
            target_content: targetSection.content_text,
            conflict_type: 'both_modified',
          })
        }
      }
    }

    // If there are unresolved conflicts and not auto_merge, return conflicts
    if (conflicts.length > 0 && !auto_merge && resolutions.length === 0) {
      return NextResponse.json({
        status: 'conflicts',
        conflicts,
        message: 'Conflicts detected. Please provide resolutions.',
      })
    }

    // Apply resolutions or auto-merge
    interface Resolution {
      section_index: number
      resolution: string
      merged_content?: string
    }
    const resolutionMap = new Map<number, Resolution>(
      resolutions.map((r: Resolution) => [r.section_index, r])
    )

    const mergedSections: Array<{
      order_index: number
      title: string | null
      content_json: unknown
      content_text: string | null
    }> = []

    // Get all unique indices
    const allIndices = new Set([...sourceMap.keys(), ...targetMap.keys()])

    for (const index of Array.from(allIndices).sort((a, b) => a - b)) {
      const sourceSection = sourceMap.get(index)
      const targetSection = targetMap.get(index)
      const resolution = resolutionMap.get(index)

      if (sourceSection && !targetSection) {
        // Added in source - include it
        mergedSections.push({
          order_index: index,
          title: sourceSection.title,
          content_json: sourceSection.content_json,
          content_text: sourceSection.content_text,
        })
      } else if (!sourceSection && targetSection) {
        // Only in target - keep it (unless explicitly removed)
        mergedSections.push({
          order_index: index,
          title: targetSection.title,
          content_json: targetSection.content_json,
          content_text: targetSection.content_text,
        })
      } else if (sourceSection && targetSection) {
        // Both exist
        if (sourceSection.content_text === targetSection.content_text) {
          // No conflict - keep either
          mergedSections.push({
            order_index: index,
            title: sourceSection.title,
            content_json: sourceSection.content_json,
            content_text: sourceSection.content_text,
          })
        } else if (resolution) {
          // Apply resolution
          if (resolution.resolution === 'keep_source') {
            mergedSections.push({
              order_index: index,
              title: sourceSection.title,
              content_json: sourceSection.content_json,
              content_text: sourceSection.content_text,
            })
          } else if (resolution.resolution === 'keep_target') {
            mergedSections.push({
              order_index: index,
              title: targetSection.title,
              content_json: targetSection.content_json,
              content_text: targetSection.content_text,
            })
          } else if (resolution.resolution === 'custom' && resolution.merged_content) {
            mergedSections.push({
              order_index: index,
              title: sourceSection.title,
              content_json: { type: 'doc', content: [{ type: 'paragraph', content: [{ type: 'text', text: resolution.merged_content }] }] },
              content_text: resolution.merged_content,
            })
          }
        } else if (auto_merge) {
          // Auto-merge: prefer source (the branch being merged in)
          mergedSections.push({
            order_index: index,
            title: sourceSection.title,
            content_json: sourceSection.content_json,
            content_text: sourceSection.content_text,
          })
        } else {
          // Unresolved conflict
          return NextResponse.json({
            status: 'conflicts',
            conflicts: [{ section_index: index, source_content: sourceSection.content_text, target_content: targetSection.content_text, conflict_type: 'both_modified' }],
            message: `Unresolved conflict at section ${index}`,
          })
        }
      }
    }

    // Apply the merge - update target branch sections
    // First, delete existing sections
    await supabase
      .from('doc_sections')
      .delete()
      .eq('branch_id', target_branch_id)

    // Insert merged sections
    if (mergedSections.length > 0) {
      const sectionsToInsert = mergedSections.map(s => ({
        document_id: id,
        branch_id: target_branch_id,
        order_index: s.order_index,
        title: s.title,
        content_json: s.content_json,
        content_text: s.content_text,
      }))

      await supabase.from('doc_sections').insert(sectionsToInsert)
    }

    // Mark source branch as merged
    await supabase
      .from('doc_branches')
      .update({
        merged_at: new Date().toISOString(),
        merged_by: user.id,
      })
      .eq('id', branchId)

    // Log activity
    await supabase.rpc('log_activity', {
      p_action: 'document.branch_merge',
      p_document_id: id,
      p_target_type: 'branch',
      p_target_id: branchId,
      p_details: {
        source_branch: sourceBranch.name,
        target_branch: targetBranch.name,
        sections_merged: mergedSections.length,
        conflicts_resolved: resolutions.length,
        message: merge_message,
      },
    })

    return NextResponse.json({
      status: 'merged',
      message: `Successfully merged "${sourceBranch.name}" into "${targetBranch.name}"`,
      sections_merged: mergedSections.length,
    })

  } catch (error) {
    console.error('Merge error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PUT /api/documents/[id]/branches/[branchId]/merge - AI-assisted merge
 */
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; branchId: string }> }
) {
  try {
    const { id, branchId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { source_content, target_content, context } = body

    if (!source_content || !target_content) {
      return NextResponse.json({ error: 'source_content and target_content required' }, { status: 400 })
    }

    // Use AI to suggest a merge
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      messages: [
        {
          role: 'user',
          content: `You are helping merge two versions of a document section. Create a merged version that incorporates the best of both while maintaining coherence.

${context ? `Context: ${context}\n\n` : ''}
Version A (source branch):
"""
${source_content}
"""

Version B (target branch):
"""
${target_content}
"""

Create a merged version that:
1. Preserves all important information from both versions
2. Resolves any contradictions intelligently
3. Maintains a coherent narrative flow
4. Does not duplicate content

Respond with JSON:
{
  "merged_content": "the merged text",
  "changes_from_source": ["what was kept/changed from source"],
  "changes_from_target": ["what was kept/changed from target"],
  "reasoning": "brief explanation of merge decisions"
}

Only return valid JSON.`,
        },
      ],
    })

    const content = response.content[0]
    if (content.type !== 'text') {
      throw new Error('Unexpected response format')
    }

    let suggestion
    try {
      let jsonStr = content.text.trim()
      if (jsonStr.startsWith('```')) jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
      suggestion = JSON.parse(jsonStr)
    } catch {
      suggestion = {
        merged_content: source_content,
        changes_from_source: ['Using source as fallback'],
        changes_from_target: [],
        reasoning: 'Failed to generate merge suggestion',
      }
    }

    return NextResponse.json({ suggestion })

  } catch (error) {
    console.error('AI merge suggestion error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/documents/[id]/branches/[branchId]/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/documents/[id]/branches/[branchId] - Get branch details with content
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; branchId: string }> }
) {
  try {
    const { id, branchId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get branch details
    const { data: branch, error: branchError } = await supabase
      .from('doc_branches')
      .select(`
        *,
        user_profiles!doc_branches_created_by_fkey (
          display_name
        )
      `)
      .eq('id', branchId)
      .eq('document_id', id)
      .single()

    if (branchError || !branch) {
      return NextResponse.json({ error: 'Branch not found' }, { status: 404 })
    }

    // Get sections
    const { data: sections } = await supabase
      .from('doc_sections')
      .select('*')
      .eq('branch_id', branchId)
      .order('order_index')

    const profile = Array.isArray(branch.user_profiles) ? branch.user_profiles[0] : branch.user_profiles

    return NextResponse.json({
      branch: {
        ...branch,
        creator_name: profile?.display_name,
      },
      sections: sections || [],
    })

  } catch (error) {
    console.error('Get branch error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/documents/[id]/branches/[branchId] - Update branch (rename)
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; branchId: string }> }
) {
  try {
    const { id, branchId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { name } = body

    if (!name) {
      return NextResponse.json({ error: 'name is required' }, { status: 400 })
    }

    // Check branch exists
    const { data: existing } = await supabase
      .from('doc_branches')
      .select('is_main')
      .eq('id', branchId)
      .eq('document_id', id)
      .single()

    if (!existing) {
      return NextResponse.json({ error: 'Branch not found' }, { status: 404 })
    }

    // Update branch
    const { data: branch, error: updateError } = await supabase
      .from('doc_branches')
      .update({ name })
      .eq('id', branchId)
      .select()
      .single()

    if (updateError) {
      console.error('Error updating branch:', updateError)
      return NextResponse.json({ error: 'Failed to update branch' }, { status: 500 })
    }

    return NextResponse.json({ branch })

  } catch (error) {
    console.error('Update branch error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/documents/[id]/branches/[branchId] - Delete branch
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; branchId: string }> }
) {
  try {
    const { id, branchId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check branch exists and is not main
    const { data: branch } = await supabase
      .from('doc_branches')
      .select('is_main, name')
      .eq('id', branchId)
      .eq('document_id', id)
      .single()

    if (!branch) {
      return NextResponse.json({ error: 'Branch not found' }, { status: 404 })
    }

    if (branch.is_main) {
      return NextResponse.json({ error: 'Cannot delete main branch' }, { status: 400 })
    }

    // Check no child branches
    const { data: children } = await supabase
      .from('doc_branches')
      .select('id')
      .eq('parent_branch_id', branchId)
      .limit(1)

    if (children && children.length > 0) {
      return NextResponse.json({ error: 'Cannot delete branch with child branches' }, { status: 400 })
    }

    // Delete branch (cascade will delete sections)
    const { error: deleteError } = await supabase
      .from('doc_branches')
      .delete()
      .eq('id', branchId)

    if (deleteError) {
      console.error('Error deleting branch:', deleteError)
      return NextResponse.json({ error: 'Failed to delete branch' }, { status: 500 })
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_action: 'document.branch_delete',
      p_document_id: id,
      p_target_type: 'branch',
      p_target_id: branchId,
      p_details: { name: branch.name },
    })

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Delete branch error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/documents/[id]/branches/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

interface Branch {
  id: string
  document_id: string
  name: string
  parent_branch_id: string | null
  is_main: boolean
  created_by: string | null
  created_at: string
  merged_at: string | null
  merged_by: string | null
}

/**
 * GET /api/documents/[id]/branches - List all branches for a document
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get all branches for the document
    const { data: branches, error } = await supabase
      .from('doc_branches')
      .select(`
        id,
        document_id,
        name,
        parent_branch_id,
        is_main,
        created_by,
        created_at,
        merged_at,
        merged_by,
        user_profiles!doc_branches_created_by_fkey (
          display_name
        )
      `)
      .eq('document_id', id)
      .order('created_at', { ascending: true })

    if (error) {
      console.error('Error fetching branches:', error)
      return NextResponse.json({ error: 'Failed to fetch branches' }, { status: 500 })
    }

    // Get section counts for each branch
    const branchIds = branches.map(b => b.id)
    const { data: sectionCounts } = await supabase
      .from('doc_sections')
      .select('branch_id')
      .in('branch_id', branchIds)

    const countsByBranch: Record<string, number> = {}
    for (const section of sectionCounts || []) {
      countsByBranch[section.branch_id] = (countsByBranch[section.branch_id] || 0) + 1
    }

    // Build branch tree structure
    const branchMap = new Map<string, Branch & { children: string[]; section_count: number; creator_name?: string }>()
    for (const branch of branches) {
      const profile = Array.isArray(branch.user_profiles) ? branch.user_profiles[0] : branch.user_profiles
      branchMap.set(branch.id, {
        ...branch,
        children: [],
        section_count: countsByBranch[branch.id] || 0,
        creator_name: profile?.display_name,
      })
    }

    // Link children to parents
    for (const branch of branchMap.values()) {
      if (branch.parent_branch_id && branchMap.has(branch.parent_branch_id)) {
        branchMap.get(branch.parent_branch_id)!.children.push(branch.id)
      }
    }

    // Find main branch
    const mainBranch = branches.find(b => b.is_main)

    return NextResponse.json({
      branches: Array.from(branchMap.values()),
      main_branch_id: mainBranch?.id,
    })

  } catch (error) {
    console.error('Get branches error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/documents/[id]/branches - Create a new branch
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { name, parent_branch_id, copy_content = true } = body

    if (!name || !parent_branch_id) {
      return NextResponse.json({ error: 'name and parent_branch_id are required' }, { status: 400 })
    }

    // Verify parent branch exists and belongs to this document
    const { data: parentBranch, error: parentError } = await supabase
      .from('doc_branches')
      .select('id, document_id')
      .eq('id', parent_branch_id)
      .eq('document_id', id)
      .single()

    if (parentError || !parentBranch) {
      return NextResponse.json({ error: 'Parent branch not found' }, { status: 404 })
    }

    // Create the new branch
    const { data: branch, error: createError } = await supabase
      .from('doc_branches')
      .insert({
        document_id: id,
        name,
        parent_branch_id,
        is_main: false,
        created_by: user.id,
      })
      .select()
      .single()

    if (createError) {
      console.error('Error creating branch:', createError)
      return NextResponse.json({ error: 'Failed to create branch' }, { status: 500 })
    }

    // Copy sections from parent branch if requested
    if (copy_content) {
      const { data: parentSections } = await supabase
        .from('doc_sections')
        .select('order_index, title, content_json, content_text')
        .eq('branch_id', parent_branch_id)
        .order('order_index')

      if (parentSections && parentSections.length > 0) {
        const newSections = parentSections.map(section => ({
          document_id: id,
          branch_id: branch.id,
          order_index: section.order_index,
          title: section.title,
          content_json: section.content_json,
          content_text: section.content_text,
        }))

        await supabase.from('doc_sections').insert(newSections)
      }
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_action: 'document.branch_create',
      p_document_id: id,
      p_target_type: 'branch',
      p_target_id: branch.id,
      p_details: { name, parent_branch_id, copy_content },
    })

    return NextResponse.json({ branch }, { status: 201 })

  } catch (error) {
    console.error('Create branch error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/documents/[id]/comments/[commentId]/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * PATCH /api/documents/[id]/comments/[commentId] - Update comment (resolve, edit)
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; commentId: string }> }
) {
  try {
    const { id, commentId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { action, content } = body

    // Get existing comment
    const { data: comment, error: fetchError } = await supabase
      .from('document_comments')
      .select('*')
      .eq('id', commentId)
      .eq('document_id', id)
      .single()

    if (fetchError || !comment) {
      return NextResponse.json({ error: 'Comment not found' }, { status: 404 })
    }

    if (action === 'resolve') {
      // Resolve the comment
      const { data: updated, error: updateError } = await supabase
        .from('document_comments')
        .update({
          status: 'resolved',
          resolved_by: user.id,
          resolved_at: new Date().toISOString(),
        })
        .eq('id', commentId)
        .select()
        .single()

      if (updateError) {
        console.error('Error resolving comment:', updateError)
        return NextResponse.json({ error: 'Failed to resolve comment' }, { status: 500 })
      }

      // Log activity
      await supabase.rpc('log_activity', {
        p_action: 'comment.resolve',
        p_document_id: id,
        p_target_type: 'comment',
        p_target_id: commentId,
        p_details: {},
      })

      return NextResponse.json({ comment: updated })

    } else if (action === 'reject') {
      // Reject the suggestion
      const { data: updated, error: updateError } = await supabase
        .from('document_comments')
        .update({
          status: 'rejected',
          resolved_by: user.id,
          resolved_at: new Date().toISOString(),
        })
        .eq('id', commentId)
        .select()
        .single()

      if (updateError) {
        console.error('Error rejecting suggestion:', updateError)
        return NextResponse.json({ error: 'Failed to reject suggestion' }, { status: 500 })
      }

      // Log activity
      await supabase.rpc('log_activity', {
        p_action: 'suggestion.reject',
        p_document_id: id,
        p_target_type: 'comment',
        p_target_id: commentId,
        p_details: {},
      })

      return NextResponse.json({ comment: updated })

    } else if (action === 'accept' && comment.comment_type === 'suggestion') {
      // Accept the suggestion (the actual text replacement should be done client-side)
      const { data: updated, error: updateError } = await supabase
        .from('document_comments')
        .update({
          status: 'resolved',
          resolved_by: user.id,
          resolved_at: new Date().toISOString(),
        })
        .eq('id', commentId)
        .select()
        .single()

      if (updateError) {
        console.error('Error accepting suggestion:', updateError)
        return NextResponse.json({ error: 'Failed to accept suggestion' }, { status: 500 })
      }

      // Log activity
      await supabase.rpc('log_activity', {
        p_action: 'suggestion.accept',
        p_document_id: id,
        p_target_type: 'comment',
        p_target_id: commentId,
        p_details: { suggested_text: comment.suggested_text },
      })

      return NextResponse.json({
        comment: updated,
        apply_suggestion: {
          start_offset: comment.start_offset,
          end_offset: comment.end_offset,
          suggested_text: comment.suggested_text,
        }
      })

    } else if (content) {
      // Edit comment content (only author can edit)
      if (comment.author_id !== user.id) {
        return NextResponse.json({ error: 'Only author can edit comment' }, { status: 403 })
      }

      const { data: updated, error: updateError } = await supabase
        .from('document_comments')
        .update({ content })
        .eq('id', commentId)
        .select()
        .single()

      if (updateError) {
        console.error('Error updating comment:', updateError)
        return NextResponse.json({ error: 'Failed to update comment' }, { status: 500 })
      }

      return NextResponse.json({ comment: updated })

    } else {
      return NextResponse.json({ error: 'Invalid action' }, { status: 400 })
    }

  } catch (error) {
    console.error('Update comment error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/documents/[id]/comments/[commentId] - Delete comment
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; commentId: string }> }
) {
  try {
    const { id, commentId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get comment to check ownership
    const { data: comment, error: fetchError } = await supabase
      .from('document_comments')
      .select('author_id')
      .eq('id', commentId)
      .eq('document_id', id)
      .single()

    if (fetchError || !comment) {
      return NextResponse.json({ error: 'Comment not found' }, { status: 404 })
    }

    // Only author can delete (admins handled by RLS)
    if (comment.author_id !== user.id) {
      // Check if user is admin/owner (simplified check)
      // Full check would need to join through document -> project -> workspace
      return NextResponse.json({ error: 'Only author can delete comment' }, { status: 403 })
    }

    const { error: deleteError } = await supabase
      .from('document_comments')
      .delete()
      .eq('id', commentId)

    if (deleteError) {
      console.error('Error deleting comment:', deleteError)
      return NextResponse.json({ error: 'Failed to delete comment' }, { status: 500 })
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_action: 'comment.delete',
      p_document_id: id,
      p_target_type: 'comment',
      p_target_id: commentId,
      p_details: {},
    })

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Delete comment error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/documents/[id]/comments/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/documents/[id]/comments - List document comments
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const branchId = searchParams.get('branch_id')
    const status = searchParams.get('status') // 'open', 'resolved', 'all'

    // Build query
    let query = supabase
      .from('document_comments')
      .select(`
        id,
        document_id,
        branch_id,
        section_id,
        parent_id,
        comment_type,
        status,
        start_offset,
        end_offset,
        suggested_text,
        content,
        author_id,
        resolved_by,
        resolved_at,
        created_at,
        updated_at,
        user_profiles!document_comments_author_id_fkey (
          display_name,
          avatar_url
        )
      `)
      .eq('document_id', id)
      .is('parent_id', null) // Only get top-level comments
      .order('created_at', { ascending: false })

    if (branchId) {
      query = query.eq('branch_id', branchId)
    }

    if (status && status !== 'all') {
      query = query.eq('status', status)
    }

    const { data: comments, error } = await query

    if (error) {
      console.error('Error fetching comments:', error)
      return NextResponse.json({ error: 'Failed to fetch comments' }, { status: 500 })
    }

    // Get replies for each comment
    const commentIds = comments.map(c => c.id)
    const { data: replies } = await supabase
      .from('document_comments')
      .select(`
        id,
        parent_id,
        content,
        author_id,
        created_at,
        user_profiles!document_comments_author_id_fkey (
          display_name,
          avatar_url
        )
      `)
      .in('parent_id', commentIds)
      .order('created_at', { ascending: true })

    // Group replies by parent
    type Reply = NonNullable<typeof replies>[number]
    const repliesByParent: Record<string, Reply[]> = {}
    for (const reply of replies || []) {
      const parentId = reply.parent_id
      if (parentId) {
        if (!repliesByParent[parentId]) {
          repliesByParent[parentId] = []
        }
        repliesByParent[parentId].push(reply)
      }
    }

    // Attach replies to comments
    const result = comments.map(c => ({
      ...c,
      author: c.user_profiles,
      replies: repliesByParent[c.id] || [],
    }))

    return NextResponse.json({ comments: result })

  } catch (error) {
    console.error('Get comments error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/documents/[id]/comments - Create comment or suggestion
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      branch_id,
      section_id,
      parent_id,
      comment_type = 'comment',
      content,
      start_offset,
      end_offset,
      suggested_text,
    } = body

    if (!branch_id || !content) {
      return NextResponse.json({ error: 'branch_id and content are required' }, { status: 400 })
    }

    // Validate comment type
    const validTypes = ['comment', 'suggestion', 'question', 'approval']
    if (!validTypes.includes(comment_type)) {
      return NextResponse.json({ error: 'Invalid comment_type' }, { status: 400 })
    }

    // If it's a suggestion, suggested_text is required
    if (comment_type === 'suggestion' && !suggested_text) {
      return NextResponse.json({ error: 'suggested_text is required for suggestions' }, { status: 400 })
    }

    const { data: comment, error: createError } = await supabase
      .from('document_comments')
      .insert({
        document_id: id,
        branch_id,
        section_id,
        parent_id,
        comment_type,
        content,
        start_offset,
        end_offset,
        suggested_text,
        author_id: user.id,
      })
      .select(`
        *,
        user_profiles!document_comments_author_id_fkey (
          display_name,
          avatar_url
        )
      `)
      .single()

    if (createError) {
      console.error('Error creating comment:', createError)
      return NextResponse.json({ error: 'Failed to create comment' }, { status: 500 })
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_action: comment_type === 'suggestion' ? 'suggestion.create' : 'comment.create',
      p_document_id: id,
      p_target_type: 'comment',
      p_target_id: comment.id,
      p_details: { comment_type, has_selection: !!start_offset },
    })

    return NextResponse.json({
      comment: {
        ...comment,
        author: comment.user_profiles,
        replies: [],
      }
    }, { status: 201 })

  } catch (error) {
    console.error('Create comment error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/evidence/find/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

interface EvidenceResult {
  id: string
  content: string
  sourceId: string
  sourceTitle: string
  chunkIndex: number
  similarity: number
  pageNumber?: number
}

// POST - Find evidence for a claim/query
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { query, projectId, limit = 5, threshold = 0.5 } = body

    if (!query) {
      return NextResponse.json({ error: 'Query is required' }, { status: 400 })
    }

    // Generate embedding for the query using Voyage AI
    const voyageApiKey = process.env.VOYAGE_API_KEY
    if (!voyageApiKey) {
      return NextResponse.json({ error: 'Voyage API key not configured' }, { status: 500 })
    }

    const embeddingResponse = await fetch('https://api.voyageai.com/v1/embeddings', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${voyageApiKey}`
      },
      body: JSON.stringify({
        model: 'voyage-2',
        input: [query],
        input_type: 'query'
      })
    })

    if (!embeddingResponse.ok) {
      const errorText = await embeddingResponse.text()
      console.error('Voyage API error:', errorText)
      return NextResponse.json({ error: 'Failed to generate query embedding' }, { status: 500 })
    }

    const embeddingData = await embeddingResponse.json()
    const queryEmbedding = embeddingData.data[0].embedding

    // Search for similar chunks using pgvector
    const { data: chunks, error: searchError } = await supabase.rpc('match_source_chunks', {
      query_embedding: queryEmbedding,
      match_threshold: threshold,
      match_count: limit,
      p_project_id: projectId || null
    })

    if (searchError) {
      console.error('Search error:', searchError)
      // If the function doesn't exist, fall back to direct query
      const { data: fallbackChunks, error: fallbackError } = await supabase
        .from('source_chunks')
        .select(`
          id,
          content,
          chunk_index,
          source_id,
          sources!inner(id, title, project_id)
        `)
        .limit(limit)

      if (fallbackError) {
        return NextResponse.json({ error: 'Search failed' }, { status: 500 })
      }

      // Format fallback results (without similarity scores)
      const results: EvidenceResult[] = (fallbackChunks || []).map((chunk: any) => ({
        id: chunk.id,
        content: chunk.content,
        sourceId: chunk.source_id,
        sourceTitle: chunk.sources?.title || 'Unknown Source',
        chunkIndex: chunk.chunk_index,
        similarity: 0.5, // Default score
        pageNumber: Math.floor(chunk.chunk_index / 3) + 1 // Estimate page
      }))

      return NextResponse.json({ evidence: results })
    }

    // Format results with source information
    const results: EvidenceResult[] = await Promise.all(
      (chunks || []).map(async (chunk: any) => {
        // Fetch source title
        const { data: source } = await supabase
          .from('sources')
          .select('title')
          .eq('id', chunk.source_id)
          .single()

        return {
          id: chunk.id,
          content: chunk.content,
          sourceId: chunk.source_id,
          sourceTitle: source?.title || 'Unknown Source',
          chunkIndex: chunk.chunk_index,
          similarity: chunk.similarity,
          pageNumber: Math.floor(chunk.chunk_index / 3) + 1 // Estimate page from chunk index
        }
      })
    )

    return NextResponse.json({ evidence: results })

  } catch (error) {
    console.error('Evidence find error:', error)
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Internal server error'
    }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/guardrails/analyze/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

interface GuardrailWarning {
  type: 'unsupported_claim' | 'hallucination' | 'speculation' | 'outdated_reference' | 'bias' | 'jargon'
  severity: 'low' | 'medium' | 'high'
  start_offset: number
  end_offset: number
  text: string
  message: string
  suggestion?: string
}

interface GuardrailSuggestion {
  type: 'add_citation' | 'strengthen_argument' | 'clarify' | 'simplify'
  start_offset: number
  end_offset: number
  text: string
  message: string
  action?: string
}

interface AnalysisResult {
  warnings: GuardrailWarning[]
  suggestions: GuardrailSuggestion[]
  metrics: {
    readability_score: number
    confidence_score: number
    citation_coverage: number
  }
}

/**
 * POST /api/guardrails/analyze - Analyze text for potential issues
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      text,
      document_id,
      sensitivity = 'medium', // 'strict' | 'medium' | 'relaxed'
      checks = ['claims', 'speculation', 'citations', 'readability']
    } = body

    if (!text || text.trim().length === 0) {
      return NextResponse.json({ error: 'text is required' }, { status: 400 })
    }

    // Truncate very long text
    const maxLength = 10000
    const truncatedText = text.length > maxLength ? text.slice(0, maxLength) : text

    // Build the analysis prompt based on requested checks
    const checkDescriptions: Record<string, string> = {
      claims: 'Identify factual claims that lack supporting evidence or citations',
      speculation: 'Flag speculative statements or opinions presented as facts',
      citations: 'Find statements that would benefit from citations',
      readability: 'Identify jargon, complex sentences, or unclear phrasing',
      bias: 'Detect potential bias or one-sided arguments',
    }

    const activeChecks = checks
      .filter((c: string) => checkDescriptions[c])
      .map((c: string) => `- ${c}: ${checkDescriptions[c]}`)
      .join('\n')

    const sensitivityInstructions: Record<string, string> = {
      strict: 'Be very thorough. Flag even minor issues and potential problems.',
      medium: 'Balance thoroughness with practicality. Flag clear issues and notable concerns.',
      relaxed: 'Only flag significant issues that clearly need attention.',
    }

    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      messages: [
        {
          role: 'user',
          content: `You are an AI writing assistant that analyzes academic and research text for potential issues. Analyze the following text and identify any problems.

Sensitivity level: ${sensitivity}
${sensitivityInstructions[sensitivity] || sensitivityInstructions.medium}

Checks to perform:
${activeChecks}

Text to analyze:
"""
${truncatedText}
"""

Respond with a JSON object containing:
{
  "warnings": [
    {
      "type": "unsupported_claim" | "hallucination" | "speculation" | "outdated_reference" | "bias" | "jargon",
      "severity": "low" | "medium" | "high",
      "text": "the exact problematic text",
      "message": "explanation of the issue",
      "suggestion": "how to fix it (optional)"
    }
  ],
  "suggestions": [
    {
      "type": "add_citation" | "strengthen_argument" | "clarify" | "simplify",
      "text": "the text that could be improved",
      "message": "what improvement is suggested"
    }
  ],
  "metrics": {
    "readability_score": 0-100 (higher is more readable),
    "confidence_score": 0-100 (how confident are the claims),
    "citation_coverage": 0-100 (what percentage of claims have citations)
  }
}

Only return valid JSON, no other text.`,
        },
      ],
    })

    // Parse the response
    const content = response.content[0]
    if (content.type !== 'text') {
      throw new Error('Unexpected response format')
    }

    let result: AnalysisResult
    try {
      // Extract JSON from the response (handle markdown code blocks)
      let jsonStr = content.text.trim()
      if (jsonStr.startsWith('```json')) {
        jsonStr = jsonStr.slice(7)
      }
      if (jsonStr.startsWith('```')) {
        jsonStr = jsonStr.slice(3)
      }
      if (jsonStr.endsWith('```')) {
        jsonStr = jsonStr.slice(0, -3)
      }
      result = JSON.parse(jsonStr.trim())
    } catch {
      console.error('Failed to parse guardrails response:', content.text)
      result = {
        warnings: [],
        suggestions: [],
        metrics: {
          readability_score: 70,
          confidence_score: 50,
          citation_coverage: 0,
        },
      }
    }

    // Find offsets for each warning/suggestion in the original text
    const enrichedWarnings = result.warnings.map(w => {
      const index = text.indexOf(w.text)
      return {
        ...w,
        start_offset: index >= 0 ? index : 0,
        end_offset: index >= 0 ? index + w.text.length : 0,
      }
    }).filter(w => w.start_offset > 0 || w.end_offset > 0)

    const enrichedSuggestions = result.suggestions.map(s => {
      const index = text.indexOf(s.text)
      return {
        ...s,
        start_offset: index >= 0 ? index : 0,
        end_offset: index >= 0 ? index + s.text.length : 0,
      }
    }).filter(s => s.start_offset > 0 || s.end_offset > 0)

    // Log the analysis if document_id provided
    if (document_id) {
      await supabase.rpc('log_activity', {
        p_action: 'guardrails.analyze',
        p_document_id: document_id,
        p_target_type: 'document',
        p_target_id: document_id,
        p_details: {
          sensitivity,
          checks,
          warning_count: enrichedWarnings.length,
          suggestion_count: enrichedSuggestions.length,
        },
      })
    }

    return NextResponse.json({
      warnings: enrichedWarnings,
      suggestions: enrichedSuggestions,
      metrics: result.metrics,
    })

  } catch (error) {
    console.error('Guardrails analysis error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/guardrails/fact-check/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

interface FactCheckResult {
  claim: string
  start_offset: number
  end_offset: number
  verdict: 'supported' | 'unsupported' | 'partially_supported' | 'needs_verification' | 'opinion'
  confidence: number // 0-1
  explanation: string
  sources_checked?: string[]
  suggested_verification?: string
}

/**
 * POST /api/guardrails/fact-check - Check factual claims against knowledge
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { text, claims, project_id } = body

    // Either analyze full text or check specific claims
    if (!text && (!claims || claims.length === 0)) {
      return NextResponse.json({ error: 'text or claims required' }, { status: 400 })
    }

    let claimsToCheck: string[] = claims || []

    // If full text provided, extract claims first
    if (text && !claims) {
      const extractResponse = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1000,
        messages: [
          {
            role: 'user',
            content: `Extract factual claims from this text that can be fact-checked. Focus on specific, verifiable claims (statistics, dates, scientific facts, etc.).

Text:
"""
${text.slice(0, 5000)}
"""

Respond with a JSON array of claim strings:
["claim 1", "claim 2", ...]

Only return the JSON array, nothing else.`,
          },
        ],
      })

      const extractContent = extractResponse.content[0]
      if (extractContent.type === 'text') {
        try {
          let jsonStr = extractContent.text.trim()
          if (jsonStr.startsWith('```')) jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
          claimsToCheck = JSON.parse(jsonStr)
        } catch {
          claimsToCheck = []
        }
      }
    }

    if (claimsToCheck.length === 0) {
      return NextResponse.json({
        results: [],
        message: 'No factual claims found to verify',
      })
    }

    // Limit to 10 claims for performance
    claimsToCheck = claimsToCheck.slice(0, 10)

    // Check claims against project sources if available
    let sourceContext = ''
    if (project_id) {
      const { data: sources } = await supabase
        .from('sources')
        .select('title, content')
        .eq('project_id', project_id)
        .not('content', 'is', null)
        .limit(5)

      if (sources && sources.length > 0) {
        sourceContext = `\n\nAvailable sources for verification:\n${sources.map(s => `- ${s.title}: ${s.content?.slice(0, 500)}...`).join('\n')}`
      }
    }

    // Fact-check the claims
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      messages: [
        {
          role: 'user',
          content: `Fact-check the following claims. For each claim, assess its accuracy based on your knowledge.
${sourceContext}

Claims to check:
${claimsToCheck.map((c, i) => `${i + 1}. "${c}"`).join('\n')}

For each claim, respond with JSON array:
[
  {
    "claim": "the claim text",
    "verdict": "supported" | "unsupported" | "partially_supported" | "needs_verification" | "opinion",
    "confidence": 0.0-1.0,
    "explanation": "why this verdict",
    "suggested_verification": "how to verify this claim (if needed)"
  }
]

Verdicts:
- supported: Claim is accurate according to established knowledge
- unsupported: Claim contradicts established knowledge
- partially_supported: Claim is partially accurate but has issues
- needs_verification: Cannot determine accuracy, needs external verification
- opinion: This is an opinion/value judgment, not a factual claim

Only return the JSON array.`,
        },
      ],
    })

    const content = response.content[0]
    if (content.type !== 'text') {
      throw new Error('Unexpected response format')
    }

    let results: Omit<FactCheckResult, 'start_offset' | 'end_offset'>[]
    try {
      let jsonStr = content.text.trim()
      if (jsonStr.startsWith('```')) jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
      results = JSON.parse(jsonStr)
    } catch {
      console.error('Failed to parse fact-check results:', content.text)
      results = []
    }

    // Add offsets if original text provided
    const enrichedResults: FactCheckResult[] = results.map(r => {
      let startOffset = 0
      let endOffset = 0

      if (text) {
        const index = text.indexOf(r.claim)
        if (index >= 0) {
          startOffset = index
          endOffset = index + r.claim.length
        }
      }

      return {
        ...r,
        start_offset: startOffset,
        end_offset: endOffset,
      }
    })

    // Summary statistics
    const summary = {
      total: enrichedResults.length,
      supported: enrichedResults.filter(r => r.verdict === 'supported').length,
      unsupported: enrichedResults.filter(r => r.verdict === 'unsupported').length,
      needs_verification: enrichedResults.filter(r => r.verdict === 'needs_verification').length,
      average_confidence: enrichedResults.length > 0
        ? enrichedResults.reduce((sum, r) => sum + r.confidence, 0) / enrichedResults.length
        : 0,
    }

    return NextResponse.json({
      results: enrichedResults,
      summary,
    })

  } catch (error) {
    console.error('Fact-check error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/guardrails/suggest-citations/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

interface CitationSuggestion {
  claim_text: string
  start_offset: number
  end_offset: number
  reason: string
  suggested_search_terms: string[]
  matching_sources?: Array<{
    id: string
    title: string
    relevance: number
  }>
}

/**
 * POST /api/guardrails/suggest-citations - Find claims that need citations
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { text, project_id, include_source_search = true } = body

    if (!text || text.trim().length === 0) {
      return NextResponse.json({ error: 'text is required' }, { status: 400 })
    }

    // Truncate very long text
    const maxLength = 8000
    const truncatedText = text.length > maxLength ? text.slice(0, maxLength) : text

    // Use Claude to identify claims needing citations
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1500,
      messages: [
        {
          role: 'user',
          content: `Analyze the following text and identify factual claims that should have citations but don't appear to have them. Focus on:
- Statistical claims or specific numbers
- Research findings or study results
- Historical facts or dates
- Quotes or attributed statements
- Scientific or technical claims
- Controversial or debatable statements presented as fact

Text to analyze:
"""
${truncatedText}
"""

Respond with a JSON array of claims needing citations:
[
  {
    "claim_text": "exact text of the claim",
    "reason": "why this needs a citation",
    "suggested_search_terms": ["term1", "term2"]
  }
]

Only return valid JSON array, no other text. If no claims need citations, return [].`,
        },
      ],
    })

    const content = response.content[0]
    if (content.type !== 'text') {
      throw new Error('Unexpected response format')
    }

    let claims: Array<{ claim_text: string; reason: string; suggested_search_terms: string[] }> = []
    try {
      let jsonStr = content.text.trim()
      if (jsonStr.startsWith('```json')) jsonStr = jsonStr.slice(7)
      if (jsonStr.startsWith('```')) jsonStr = jsonStr.slice(3)
      if (jsonStr.endsWith('```')) jsonStr = jsonStr.slice(0, -3)
      claims = JSON.parse(jsonStr.trim())
    } catch {
      console.error('Failed to parse citation suggestions:', content.text)
      claims = []
    }

    // Enrich with offsets
    const suggestions: CitationSuggestion[] = claims.map(claim => {
      const index = text.indexOf(claim.claim_text)
      return {
        ...claim,
        start_offset: index >= 0 ? index : 0,
        end_offset: index >= 0 ? index + claim.claim_text.length : 0,
      }
    }).filter(s => s.start_offset > 0 || s.end_offset > 0)

    // Optionally search for matching sources in the project
    if (include_source_search && project_id && suggestions.length > 0) {
      // Get embeddings for the claims and search
      // For now, we'll do a simple text search
      for (const suggestion of suggestions) {
        const searchTerms = suggestion.suggested_search_terms.join(' ')

        const { data: sources } = await supabase
          .from('sources')
          .select('id, title')
          .eq('project_id', project_id)
          .textSearch('title', searchTerms, { type: 'websearch' })
          .limit(3)

        if (sources && sources.length > 0) {
          suggestion.matching_sources = sources.map((s, i) => ({
            id: s.id,
            title: s.title,
            relevance: 1 - (i * 0.2), // Simple relevance scoring
          }))
        }
      }
    }

    return NextResponse.json({ suggestions })

  } catch (error) {
    console.error('Citation suggestion error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/guardrails/writing/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

interface WritingIssue {
  type: 'readability' | 'tone' | 'jargon' | 'passive_voice' | 'complex_sentence' | 'redundancy'
  severity: 'low' | 'medium' | 'high'
  start_offset: number
  end_offset: number
  original_text: string
  message: string
  suggestion?: string
  replacement?: string
}

interface WritingMetrics {
  flesch_reading_ease: number // 0-100, higher is easier
  average_sentence_length: number
  passive_voice_percentage: number
  jargon_count: number
  tone: 'formal' | 'informal' | 'academic' | 'conversational' | 'mixed'
}

/**
 * POST /api/guardrails/writing - Analyze writing quality and style
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      text,
      target_audience = 'academic', // 'academic' | 'general' | 'technical' | 'business'
      checks = ['readability', 'tone', 'jargon', 'passive_voice', 'complexity']
    } = body

    if (!text || text.trim().length === 0) {
      return NextResponse.json({ error: 'text is required' }, { status: 400 })
    }

    const maxLength = 8000
    const truncatedText = text.length > maxLength ? text.slice(0, maxLength) : text

    // Calculate basic metrics locally
    const sentences = truncatedText.split(/[.!?]+/).filter((s: string) => s.trim().length > 0)
    const words = truncatedText.split(/\s+/).filter((w: string) => w.length > 0)
    const avgSentenceLength = sentences.length > 0 ? words.length / sentences.length : 0

    // Use Claude for detailed analysis
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      messages: [
        {
          role: 'user',
          content: `Analyze the following text for writing quality and style issues. The target audience is: ${target_audience}

Checks to perform: ${checks.join(', ')}

Text to analyze:
"""
${truncatedText}
"""

Respond with a JSON object:
{
  "issues": [
    {
      "type": "readability" | "tone" | "jargon" | "passive_voice" | "complex_sentence" | "redundancy",
      "severity": "low" | "medium" | "high",
      "original_text": "the problematic text",
      "message": "what's wrong",
      "suggestion": "how to improve",
      "replacement": "suggested replacement text (if applicable)"
    }
  ],
  "metrics": {
    "flesch_reading_ease": 0-100,
    "passive_voice_percentage": 0-100,
    "jargon_count": number,
    "tone": "formal" | "informal" | "academic" | "conversational" | "mixed"
  },
  "summary": "brief overall assessment"
}

Only return valid JSON, no other text.`,
        },
      ],
    })

    const content = response.content[0]
    if (content.type !== 'text') {
      throw new Error('Unexpected response format')
    }

    interface AnalysisResult {
      issues: Array<{
        type: WritingIssue['type']
        severity: WritingIssue['severity']
        original_text: string
        message: string
        suggestion?: string
        replacement?: string
      }>
      metrics: Omit<WritingMetrics, 'average_sentence_length'>
      summary: string
    }

    let result: AnalysisResult
    try {
      let jsonStr = content.text.trim()
      if (jsonStr.startsWith('```json')) jsonStr = jsonStr.slice(7)
      if (jsonStr.startsWith('```')) jsonStr = jsonStr.slice(3)
      if (jsonStr.endsWith('```')) jsonStr = jsonStr.slice(0, -3)
      result = JSON.parse(jsonStr.trim())
    } catch {
      console.error('Failed to parse writing analysis:', content.text)
      result = {
        issues: [],
        metrics: {
          flesch_reading_ease: 50,
          passive_voice_percentage: 0,
          jargon_count: 0,
          tone: 'mixed',
        },
        summary: 'Unable to analyze text',
      }
    }

    // Enrich issues with offsets
    const enrichedIssues: WritingIssue[] = result.issues.map(issue => {
      const index = text.indexOf(issue.original_text)
      return {
        ...issue,
        start_offset: index >= 0 ? index : 0,
        end_offset: index >= 0 ? index + issue.original_text.length : 0,
      }
    }).filter(i => i.start_offset > 0 || i.end_offset > 0)

    return NextResponse.json({
      issues: enrichedIssues,
      metrics: {
        ...result.metrics,
        average_sentence_length: Math.round(avgSentenceLength * 10) / 10,
      },
      summary: result.summary,
    })

  } catch (error) {
    console.error('Writing analysis error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/guardrails/writing/simplify - Simplify complex text
 */
export async function PUT(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { text, target_level = 'general' } = body

    if (!text || text.trim().length === 0) {
      return NextResponse.json({ error: 'text is required' }, { status: 400 })
    }

    const levelDescriptions: Record<string, string> = {
      simple: 'elementary school level, very simple words and short sentences',
      general: 'general public, avoid jargon, clear and straightforward',
      technical: 'technically literate audience, can use some jargon but explain complex concepts',
      academic: 'academic audience, maintain precision but improve clarity',
    }

    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      messages: [
        {
          role: 'user',
          content: `Simplify the following text for ${target_level} audience (${levelDescriptions[target_level] || levelDescriptions.general}).

Maintain the core meaning and any important nuances, but:
- Use simpler vocabulary where possible
- Break up complex sentences
- Replace jargon with plain language
- Make the text more accessible

Original text:
"""
${text}
"""

Respond with JSON:
{
  "simplified": "the simplified text",
  "changes": [
    {"original": "complex phrase", "simplified": "simple phrase", "reason": "why changed"}
  ]
}

Only return valid JSON.`,
        },
      ],
    })

    const content = response.content[0]
    if (content.type !== 'text') {
      throw new Error('Unexpected response format')
    }

    let result: { simplified: string; changes: Array<{ original: string; simplified: string; reason: string }> }
    try {
      let jsonStr = content.text.trim()
      if (jsonStr.startsWith('```json')) jsonStr = jsonStr.slice(7)
      if (jsonStr.startsWith('```')) jsonStr = jsonStr.slice(3)
      if (jsonStr.endsWith('```')) jsonStr = jsonStr.slice(0, -3)
      result = JSON.parse(jsonStr.trim())
    } catch {
      result = {
        simplified: text,
        changes: [],
      }
    }

    return NextResponse.json(result)

  } catch (error) {
    console.error('Simplification error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/import/arxiv/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

interface ArxivEntry {
  id: string
  title: string
  summary: string
  authors: string[]
  published: string
  updated: string
  pdfUrl: string
  categories: string[]
  doi?: string
}

/**
 * Parse ArXiv Atom XML response
 */
function parseArxivResponse(xml: string): ArxivEntry[] {
  const entries: ArxivEntry[] = []

  // Simple regex-based parsing (more robust than DOM parsing for this format)
  const entryMatches = xml.matchAll(/<entry>([\s\S]*?)<\/entry>/g)

  for (const entryMatch of entryMatches) {
    const entryXml = entryMatch[1]

    // Extract ID (e.g., http://arxiv.org/abs/2301.12345v1 -> 2301.12345)
    const idMatch = entryXml.match(/<id>http:\/\/arxiv\.org\/abs\/([^<]+)<\/id>/)
    const id = idMatch?.[1]?.replace(/v\d+$/, '') || ''

    // Extract title (clean up whitespace)
    const titleMatch = entryXml.match(/<title>([\s\S]*?)<\/title>/)
    const title = titleMatch?.[1]?.replace(/\s+/g, ' ').trim() || ''

    // Extract summary/abstract
    const summaryMatch = entryXml.match(/<summary>([\s\S]*?)<\/summary>/)
    const summary = summaryMatch?.[1]?.replace(/\s+/g, ' ').trim() || ''

    // Extract authors
    const authors: string[] = []
    const authorMatches = entryXml.matchAll(/<author>\s*<name>([^<]+)<\/name>/g)
    for (const authorMatch of authorMatches) {
      authors.push(authorMatch[1].trim())
    }

    // Extract dates
    const publishedMatch = entryXml.match(/<published>([^<]+)<\/published>/)
    const published = publishedMatch?.[1] || ''

    const updatedMatch = entryXml.match(/<updated>([^<]+)<\/updated>/)
    const updated = updatedMatch?.[1] || ''

    // Extract PDF link
    const pdfMatch = entryXml.match(/<link[^>]+title="pdf"[^>]+href="([^"]+)"/)
    const pdfUrl = pdfMatch?.[1] || `https://arxiv.org/pdf/${id}.pdf`

    // Extract categories
    const categories: string[] = []
    const categoryMatches = entryXml.matchAll(/<category[^>]+term="([^"]+)"/g)
    for (const catMatch of categoryMatches) {
      categories.push(catMatch[1])
    }

    // Extract DOI if available
    const doiMatch = entryXml.match(/<arxiv:doi[^>]*>([^<]+)<\/arxiv:doi>/)
    const doi = doiMatch?.[1]

    if (id) {
      entries.push({
        id,
        title,
        summary,
        authors,
        published,
        updated,
        pdfUrl,
        categories,
        doi,
      })
    }
  }

  return entries
}

/**
 * POST /api/import/arxiv - Import paper from ArXiv
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { arxiv_id, project_id } = body

    if (!arxiv_id) {
      return NextResponse.json({ error: 'arxiv_id is required' }, { status: 400 })
    }

    // Clean up the ArXiv ID (handle various formats)
    let cleanId = arxiv_id.trim()
    cleanId = cleanId.replace(/^(https?:\/\/)?(arxiv\.org\/abs\/)?/, '')
    cleanId = cleanId.replace(/\.pdf$/, '')
    cleanId = cleanId.replace(/v\d+$/, '') // Remove version suffix

    // Fetch from ArXiv API
    const apiUrl = `http://export.arxiv.org/api/query?id_list=${cleanId}`
    const response = await fetch(apiUrl)

    if (!response.ok) {
      return NextResponse.json({ error: 'Failed to fetch from ArXiv' }, { status: 502 })
    }

    const xml = await response.text()
    const entries = parseArxivResponse(xml)

    if (entries.length === 0) {
      return NextResponse.json({ error: 'Paper not found on ArXiv' }, { status: 404 })
    }

    const paper = entries[0]

    // Check if source already exists
    const { data: existing } = await supabase
      .from('sources')
      .select('id')
      .eq('source_type', 'arxiv')
      .eq('external_id', paper.id)
      .single()

    if (existing) {
      return NextResponse.json({
        source: existing,
        imported: false,
        message: 'Paper already exists in your library',
      })
    }

    // Create source record
    const { data: source, error: createError } = await supabase
      .from('sources')
      .insert({
        project_id,
        title: paper.title,
        source_type: 'arxiv',
        external_id: paper.id,
        url: `https://arxiv.org/abs/${paper.id}`,
        pdf_url: paper.pdfUrl,
        metadata: {
          arxiv_id: paper.id,
          authors: paper.authors,
          abstract: paper.summary,
          categories: paper.categories,
          published: paper.published,
          updated: paper.updated,
          doi: paper.doi,
        },
      })
      .select()
      .single()

    if (createError) {
      console.error('Error creating source:', createError)
      return NextResponse.json({ error: 'Failed to create source' }, { status: 500 })
    }

    // Optionally trigger PDF download and processing
    // This would be done async via a background job in production

    return NextResponse.json({
      source,
      imported: true,
      message: 'Paper imported successfully',
    }, { status: 201 })

  } catch (error) {
    console.error('ArXiv import error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * GET /api/import/arxiv?query=...&max_results=10 - Search ArXiv
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const query = searchParams.get('query')
    const maxResults = parseInt(searchParams.get('max_results') || '10', 10)

    if (!query) {
      return NextResponse.json({ error: 'query is required' }, { status: 400 })
    }

    // Build search query
    const encodedQuery = encodeURIComponent(query)
    const apiUrl = `http://export.arxiv.org/api/query?search_query=all:${encodedQuery}&start=0&max_results=${Math.min(maxResults, 50)}`

    const response = await fetch(apiUrl)

    if (!response.ok) {
      return NextResponse.json({ error: 'Failed to search ArXiv' }, { status: 502 })
    }

    const xml = await response.text()
    const entries = parseArxivResponse(xml)

    // Format results
    const results = entries.map(entry => ({
      arxiv_id: entry.id,
      title: entry.title,
      authors: entry.authors,
      abstract: entry.summary.slice(0, 500) + (entry.summary.length > 500 ? '...' : ''),
      published: entry.published,
      categories: entry.categories,
      pdf_url: entry.pdfUrl,
      url: `https://arxiv.org/abs/${entry.id}`,
    }))

    return NextResponse.json({ results })

  } catch (error) {
    console.error('ArXiv search error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/import/bibtex/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

interface BibEntry {
  type: string
  key: string
  title?: string
  author?: string
  year?: string
  journal?: string
  booktitle?: string
  publisher?: string
  volume?: string
  number?: string
  pages?: string
  doi?: string
  url?: string
  abstract?: string
  keywords?: string
  [key: string]: string | undefined
}

/**
 * Parse BibTeX string into entries
 */
function parseBibtex(bibtex: string): BibEntry[] {
  const entries: BibEntry[] = []

  // Match @type{key, ...}
  const entryRegex = /@(\w+)\s*\{\s*([^,\s]+)\s*,([^@]*)/g
  let match

  while ((match = entryRegex.exec(bibtex)) !== null) {
    const type = match[1].toLowerCase()
    const key = match[2].trim()
    const fieldsStr = match[3]

    const entry: BibEntry = { type, key }

    // Parse fields
    // Handle both field = {value} and field = "value" formats
    const fieldRegex = /(\w+)\s*=\s*(?:\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}|"([^"]*)"|(\d+))/g
    let fieldMatch

    while ((fieldMatch = fieldRegex.exec(fieldsStr)) !== null) {
      const fieldName = fieldMatch[1].toLowerCase()
      const value = fieldMatch[2] || fieldMatch[3] || fieldMatch[4] || ''
      entry[fieldName] = value.trim()
    }

    entries.push(entry)
  }

  return entries
}

/**
 * Parse BibTeX author string into array of names
 */
function parseAuthors(authorStr: string): string[] {
  if (!authorStr) return []

  // Split by ' and '
  const authors = authorStr.split(/\s+and\s+/i)

  return authors.map(author => {
    // Handle "Last, First" format
    if (author.includes(',')) {
      const parts = author.split(',').map(p => p.trim())
      return [parts[1], parts[0]].filter(Boolean).join(' ')
    }
    return author.trim()
  }).filter(Boolean)
}

/**
 * POST /api/import/bibtex - Import sources from BibTeX
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { bibtex, project_id } = body

    if (!bibtex) {
      return NextResponse.json({ error: 'bibtex content is required' }, { status: 400 })
    }

    // Parse BibTeX
    const entries = parseBibtex(bibtex)

    if (entries.length === 0) {
      return NextResponse.json({ error: 'No valid BibTeX entries found' }, { status: 400 })
    }

    const results = {
      imported: 0,
      skipped: 0,
      failed: 0,
      sources: [] as Array<{ id: string; title: string }>,
      errors: [] as Array<{ key: string; error: string }>,
    }

    for (const entry of entries) {
      try {
        // Skip if no title
        if (!entry.title) {
          results.skipped++
          continue
        }

        // Check for duplicates by DOI or title
        if (entry.doi) {
          const { data: existing } = await supabase
            .from('sources')
            .select('id')
            .eq('external_id', entry.doi)
            .single()

          if (existing) {
            results.skipped++
            continue
          }
        }

        // Determine source type
        let sourceType = 'paper'
        if (entry.type === 'book') sourceType = 'book'
        else if (entry.type === 'inproceedings' || entry.type === 'conference') sourceType = 'conference'
        else if (entry.type === 'misc' || entry.type === 'online') sourceType = 'web'
        else if (entry.type === 'phdthesis' || entry.type === 'mastersthesis') sourceType = 'thesis'

        // Build URL
        let url = entry.url
        if (!url && entry.doi) {
          url = `https://doi.org/${entry.doi}`
        }

        // Create source
        const { data: source, error: createError } = await supabase
          .from('sources')
          .insert({
            project_id,
            title: entry.title,
            source_type: sourceType,
            external_id: entry.doi || `bibtex:${entry.key}`,
            url,
            metadata: {
              bibtex_key: entry.key,
              bibtex_type: entry.type,
              authors: parseAuthors(entry.author || ''),
              year: entry.year,
              journal: entry.journal || entry.booktitle,
              publisher: entry.publisher,
              volume: entry.volume,
              number: entry.number,
              pages: entry.pages,
              doi: entry.doi,
              abstract: entry.abstract,
              keywords: entry.keywords?.split(',').map(k => k.trim()),
            },
          })
          .select('id, title')
          .single()

        if (createError) {
          results.failed++
          results.errors.push({ key: entry.key, error: createError.message })
        } else {
          results.imported++
          results.sources.push(source)
        }
      } catch (err) {
        results.failed++
        results.errors.push({
          key: entry.key,
          error: err instanceof Error ? err.message : 'Unknown error',
        })
      }
    }

    return NextResponse.json({
      total: entries.length,
      ...results,
    }, { status: results.imported > 0 ? 201 : 200 })

  } catch (error) {
    console.error('BibTeX import error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/import/doi/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

interface CrossRefWork {
  DOI: string
  URL: string
  title: string[]
  author?: Array<{
    given?: string
    family?: string
    name?: string
  }>
  abstract?: string
  'container-title'?: string[]
  publisher?: string
  published?: {
    'date-parts'?: number[][]
  }
  type?: string
  ISSN?: string[]
  subject?: string[]
  license?: Array<{
    URL: string
    'content-version'?: string
  }>
  link?: Array<{
    URL: string
    'content-type'?: string
  }>
}

/**
 * POST /api/import/doi - Import paper by DOI
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { doi, project_id } = body

    if (!doi) {
      return NextResponse.json({ error: 'doi is required' }, { status: 400 })
    }

    // Clean up the DOI (handle various formats)
    let cleanDoi = doi.trim()
    cleanDoi = cleanDoi.replace(/^(https?:\/\/)?(dx\.)?doi\.org\//, '')
    cleanDoi = cleanDoi.replace(/^doi:/, '')

    // Fetch from CrossRef API
    const apiUrl = `https://api.crossref.org/works/${encodeURIComponent(cleanDoi)}`
    const response = await fetch(apiUrl, {
      headers: {
        'User-Agent': 'ResearchBase/1.0 (mailto:support@researchbase.pro)',
      },
    })

    if (!response.ok) {
      if (response.status === 404) {
        return NextResponse.json({ error: 'DOI not found' }, { status: 404 })
      }
      return NextResponse.json({ error: 'Failed to resolve DOI' }, { status: 502 })
    }

    const data = await response.json()
    const work: CrossRefWork = data.message

    // Check if source already exists
    const { data: existing } = await supabase
      .from('sources')
      .select('id')
      .eq('source_type', 'doi')
      .eq('external_id', work.DOI)
      .single()

    if (existing) {
      return NextResponse.json({
        source: existing,
        imported: false,
        message: 'Paper already exists in your library',
      })
    }

    // Extract authors
    const authors = work.author?.map(a => {
      if (a.name) return a.name
      return [a.given, a.family].filter(Boolean).join(' ')
    }) || []

    // Extract publication date
    const dateParts = work.published?.['date-parts']?.[0]
    const publishedDate = dateParts
      ? new Date(dateParts[0], (dateParts[1] || 1) - 1, dateParts[2] || 1).toISOString()
      : null

    // Find PDF link if available
    const pdfLink = work.link?.find(l =>
      l['content-type']?.includes('pdf') || l.URL?.includes('.pdf')
    )

    // Create source record
    const { data: source, error: createError } = await supabase
      .from('sources')
      .insert({
        project_id,
        title: work.title?.[0] || 'Untitled',
        source_type: 'doi',
        external_id: work.DOI,
        url: work.URL || `https://doi.org/${work.DOI}`,
        pdf_url: pdfLink?.URL,
        metadata: {
          doi: work.DOI,
          authors,
          abstract: work.abstract,
          journal: work['container-title']?.[0],
          publisher: work.publisher,
          published: publishedDate,
          type: work.type,
          issn: work.ISSN,
          subjects: work.subject,
        },
      })
      .select()
      .single()

    if (createError) {
      console.error('Error creating source:', createError)
      return NextResponse.json({ error: 'Failed to create source' }, { status: 500 })
    }

    return NextResponse.json({
      source,
      imported: true,
      message: 'Paper imported successfully',
    }, { status: 201 })

  } catch (error) {
    console.error('DOI import error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * GET /api/import/doi?doi=... - Lookup DOI metadata without importing
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const doi = searchParams.get('doi')

    if (!doi) {
      return NextResponse.json({ error: 'doi is required' }, { status: 400 })
    }

    // Clean up the DOI
    let cleanDoi = doi.trim()
    cleanDoi = cleanDoi.replace(/^(https?:\/\/)?(dx\.)?doi\.org\//, '')
    cleanDoi = cleanDoi.replace(/^doi:/, '')

    // Fetch from CrossRef API
    const apiUrl = `https://api.crossref.org/works/${encodeURIComponent(cleanDoi)}`
    const response = await fetch(apiUrl, {
      headers: {
        'User-Agent': 'ResearchBase/1.0 (mailto:support@researchbase.pro)',
      },
    })

    if (!response.ok) {
      if (response.status === 404) {
        return NextResponse.json({ error: 'DOI not found' }, { status: 404 })
      }
      return NextResponse.json({ error: 'Failed to resolve DOI' }, { status: 502 })
    }

    const data = await response.json()
    const work: CrossRefWork = data.message

    // Extract authors
    const authors = work.author?.map(a => {
      if (a.name) return a.name
      return [a.given, a.family].filter(Boolean).join(' ')
    }) || []

    // Extract publication date
    const dateParts = work.published?.['date-parts']?.[0]
    const publishedDate = dateParts
      ? `${dateParts[0]}${dateParts[1] ? '-' + String(dateParts[1]).padStart(2, '0') : ''}${dateParts[2] ? '-' + String(dateParts[2]).padStart(2, '0') : ''}`
      : null

    return NextResponse.json({
      doi: work.DOI,
      title: work.title?.[0],
      authors,
      abstract: work.abstract,
      journal: work['container-title']?.[0],
      publisher: work.publisher,
      published: publishedDate,
      type: work.type,
      url: work.URL || `https://doi.org/${work.DOI}`,
    })

  } catch (error) {
    console.error('DOI lookup error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/import/web/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * Simplified article extraction (server-side)
 * In production, you might want to use Mozilla's Readability via JSDOM
 */
function extractArticle(html: string, url: string): {
  title: string
  content: string
  excerpt: string
  author?: string
  publishedDate?: string
  siteName?: string
} {
  // Extract title
  let title = ''
  const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i)
  if (titleMatch) title = titleMatch[1].trim()

  // Try Open Graph title
  const ogTitleMatch = html.match(/<meta[^>]+property="og:title"[^>]+content="([^"]+)"/i)
  if (ogTitleMatch) title = ogTitleMatch[1]

  // Extract author
  let author: string | undefined
  const authorMatch = html.match(/<meta[^>]+name="author"[^>]+content="([^"]+)"/i)
  if (authorMatch) author = authorMatch[1]

  // Extract published date
  let publishedDate: string | undefined
  const dateMatch = html.match(/<meta[^>]+property="article:published_time"[^>]+content="([^"]+)"/i)
    || html.match(/<time[^>]+datetime="([^"]+)"/i)
  if (dateMatch) publishedDate = dateMatch[1]

  // Extract site name
  let siteName: string | undefined
  const siteMatch = html.match(/<meta[^>]+property="og:site_name"[^>]+content="([^"]+)"/i)
  if (siteMatch) siteName = siteMatch[1]

  // Extract description/excerpt
  let excerpt = ''
  const descMatch = html.match(/<meta[^>]+name="description"[^>]+content="([^"]+)"/i)
    || html.match(/<meta[^>]+property="og:description"[^>]+content="([^"]+)"/i)
  if (descMatch) excerpt = descMatch[1]

  // Extract main content (simplified - real implementation would use Readability)
  let content = ''

  // Try to find article element
  const articleMatch = html.match(/<article[^>]*>([\s\S]*?)<\/article>/i)
  if (articleMatch) {
    content = articleMatch[1]
  } else {
    // Try main element
    const mainMatch = html.match(/<main[^>]*>([\s\S]*?)<\/main>/i)
    if (mainMatch) {
      content = mainMatch[1]
    } else {
      // Fallback to body
      const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i)
      if (bodyMatch) {
        content = bodyMatch[1]
      }
    }
  }

  // Clean content
  content = content
    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
    .replace(/<nav[^>]*>[\s\S]*?<\/nav>/gi, '')
    .replace(/<footer[^>]*>[\s\S]*?<\/footer>/gi, '')
    .replace(/<header[^>]*>[\s\S]*?<\/header>/gi, '')
    .replace(/<aside[^>]*>[\s\S]*?<\/aside>/gi, '')
    .replace(/<[^>]+>/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()

  // Truncate content for storage
  if (content.length > 50000) {
    content = content.slice(0, 50000) + '...'
  }

  return {
    title,
    content,
    excerpt,
    author,
    publishedDate,
    siteName,
  }
}

/**
 * POST /api/import/web - Import web article
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { url, project_id } = body

    if (!url) {
      return NextResponse.json({ error: 'url is required' }, { status: 400 })
    }

    // Validate URL
    let parsedUrl: URL
    try {
      parsedUrl = new URL(url)
    } catch {
      return NextResponse.json({ error: 'Invalid URL' }, { status: 400 })
    }

    // Check if already imported
    const { data: existing } = await supabase
      .from('sources')
      .select('id')
      .eq('url', url)
      .single()

    if (existing) {
      return NextResponse.json({
        source: existing,
        imported: false,
        message: 'Article already exists in your library',
      })
    }

    // Fetch the page
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; ResearchBase/1.0)',
        'Accept': 'text/html',
      },
    })

    if (!response.ok) {
      return NextResponse.json({ error: `Failed to fetch URL: ${response.status}` }, { status: 502 })
    }

    const html = await response.text()

    // Extract article content
    const article = extractArticle(html, url)

    if (!article.title) {
      article.title = parsedUrl.hostname + parsedUrl.pathname
    }

    // Create source
    const { data: source, error: createError } = await supabase
      .from('sources')
      .insert({
        project_id,
        title: article.title,
        source_type: 'web',
        url,
        content: article.content,
        metadata: {
          site_name: article.siteName || parsedUrl.hostname,
          author: article.author,
          published_date: article.publishedDate,
          excerpt: article.excerpt,
          imported_at: new Date().toISOString(),
        },
      })
      .select()
      .single()

    if (createError) {
      console.error('Error creating source:', createError)
      return NextResponse.json({ error: 'Failed to create source' }, { status: 500 })
    }

    return NextResponse.json({
      source,
      imported: true,
      message: 'Article imported successfully',
      article: {
        title: article.title,
        excerpt: article.excerpt,
        author: article.author,
        siteName: article.siteName,
      },
    }, { status: 201 })

  } catch (error) {
    console.error('Web import error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * GET /api/import/web?url=... - Preview article metadata without importing
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const url = searchParams.get('url')

    if (!url) {
      return NextResponse.json({ error: 'url is required' }, { status: 400 })
    }

    // Validate URL
    let parsedUrl: URL
    try {
      parsedUrl = new URL(url)
    } catch {
      return NextResponse.json({ error: 'Invalid URL' }, { status: 400 })
    }

    // Fetch the page
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; ResearchBase/1.0)',
        'Accept': 'text/html',
      },
    })

    if (!response.ok) {
      return NextResponse.json({ error: `Failed to fetch URL: ${response.status}` }, { status: 502 })
    }

    const html = await response.text()
    const article = extractArticle(html, url)

    return NextResponse.json({
      url,
      title: article.title || parsedUrl.hostname + parsedUrl.pathname,
      excerpt: article.excerpt,
      author: article.author,
      publishedDate: article.publishedDate,
      siteName: article.siteName || parsedUrl.hostname,
    })

  } catch (error) {
    console.error('Web preview error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/invitations/[token]/accept/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * POST /api/invitations/[token]/accept - Accept workspace invitation
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ token: string }> }
) {
  try {
    const { token } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Please sign in to accept this invitation' }, { status: 401 })
    }

    // Get invitation
    const { data: invitation, error: inviteError } = await supabase
      .from('workspace_invitations')
      .select('*')
      .eq('token', token)
      .single()

    if (inviteError || !invitation) {
      return NextResponse.json({ error: 'Invalid invitation' }, { status: 404 })
    }

    // Check if already accepted
    if (invitation.accepted_at) {
      return NextResponse.json({ error: 'Invitation already accepted' }, { status: 400 })
    }

    // Check if expired
    if (new Date(invitation.expires_at) < new Date()) {
      return NextResponse.json({ error: 'Invitation has expired' }, { status: 400 })
    }

    // Check if email matches (optional - can be configured)
    // For now, we allow any authenticated user to accept
    // In production, you might want to verify email matches

    // Check if already a member
    const { data: existingMember } = await supabase
      .from('workspace_members')
      .select('user_id')
      .eq('workspace_id', invitation.workspace_id)
      .eq('user_id', user.id)
      .single()

    if (existingMember) {
      // Mark invitation as accepted even if already a member
      await supabase
        .from('workspace_invitations')
        .update({ accepted_at: new Date().toISOString() })
        .eq('id', invitation.id)

      return NextResponse.json({ error: 'You are already a member of this workspace' }, { status: 400 })
    }

    // Add user to workspace
    const { error: memberError } = await supabase
      .from('workspace_members')
      .insert({
        workspace_id: invitation.workspace_id,
        user_id: user.id,
        role: invitation.role,
        invited_at: invitation.created_at,
        joined_at: new Date().toISOString(),
      })

    if (memberError) {
      console.error('Error adding member:', memberError)
      return NextResponse.json({ error: 'Failed to accept invitation' }, { status: 500 })
    }

    // Mark invitation as accepted
    await supabase
      .from('workspace_invitations')
      .update({ accepted_at: new Date().toISOString() })
      .eq('id', invitation.id)

    // Log activity
    await supabase.rpc('log_activity', {
      p_action: 'workspace.invite_accept',
      p_workspace_id: invitation.workspace_id,
      p_target_type: 'member',
      p_target_id: user.id,
      p_details: { role: invitation.role, invitation_id: invitation.id },
    })

    // Get workspace name for response
    const { data: workspace } = await supabase
      .from('workspaces')
      .select('id, name, slug')
      .eq('id', invitation.workspace_id)
      .single()

    return NextResponse.json({
      success: true,
      workspace: {
        id: workspace?.id,
        name: workspace?.name,
        slug: workspace?.slug,
        role: invitation.role,
      }
    })

  } catch (error) {
    console.error('Accept invitation error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * GET /api/invitations/[token]/accept - Get invitation details (for preview)
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ token: string }> }
) {
  try {
    const { token } = await params
    const supabase = await createClient()

    // Get invitation with workspace name
    const { data: invitation, error } = await supabase
      .from('workspace_invitations')
      .select(`
        id,
        email,
        role,
        expires_at,
        accepted_at,
        workspaces (
          id,
          name,
          slug
        )
      `)
      .eq('token', token)
      .single()

    if (error || !invitation) {
      return NextResponse.json({ error: 'Invalid invitation' }, { status: 404 })
    }

    if (invitation.accepted_at) {
      return NextResponse.json({ error: 'Invitation already accepted' }, { status: 400 })
    }

    if (new Date(invitation.expires_at) < new Date()) {
      return NextResponse.json({ error: 'Invitation has expired' }, { status: 400 })
    }

    return NextResponse.json({
      invitation: {
        email: invitation.email,
        role: invitation.role,
        expires_at: invitation.expires_at,
        workspace: invitation.workspaces,
      }
    })

  } catch (error) {
    console.error('Get invitation error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/knowledge/contradictions/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

interface DetectedContradiction {
  claim_a: {
    entity_id?: string
    text: string
    document_id?: string
  }
  claim_b: {
    entity_id?: string
    text: string
    document_id?: string
  }
  description: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  analysis: {
    type: string
    explanation: string
    possible_resolutions: string[]
  }
}

/**
 * GET /api/knowledge/contradictions - List contradictions in a workspace
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const status = searchParams.get('status')
    const severity = searchParams.get('severity')
    const limit = parseInt(searchParams.get('limit') || '50')
    const offset = parseInt(searchParams.get('offset') || '0')

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    let query = supabase
      .from('contradictions')
      .select(`
        *,
        claim_a:knowledge_entities!claim_a_entity_id(id, name, entity_type, description),
        claim_b:knowledge_entities!claim_b_entity_id(id, name, entity_type, description),
        document_a:documents!document_a_id(id, title),
        document_b:documents!document_b_id(id, title),
        resolver:auth.users!resolved_by(id, email)
      `, { count: 'exact' })
      .eq('workspace_id', workspaceId)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1)

    if (status) {
      query = query.eq('status', status)
    }

    if (severity) {
      query = query.eq('severity', severity)
    }

    const { data: contradictions, error, count } = await query

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({
      contradictions,
      total: count,
      limit,
      offset,
    })

  } catch (error) {
    console.error('List contradictions error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/knowledge/contradictions - Detect contradictions between claims
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      workspace_id,
      claims, // Array of claim texts to analyze
      entity_ids, // Optional: specific entities to check
      document_ids, // Optional: documents to extract claims from
      save_results = true,
    } = body

    if (!workspace_id) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin', 'editor'].includes(member.role)) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    // Gather claims to analyze
    let claimsToAnalyze: Array<{ id?: string; text: string; document_id?: string }> = []

    if (claims && claims.length > 0) {
      claimsToAnalyze = claims.map((c: string | { text: string }) => typeof c === 'string' ? { text: c } : c)
    }

    if (entity_ids && entity_ids.length > 0) {
      const { data: entities } = await supabase
        .from('knowledge_entities')
        .select('id, name, description')
        .eq('workspace_id', workspace_id)
        .eq('entity_type', 'claim')
        .in('id', entity_ids)

      if (entities) {
        for (const entity of entities) {
          claimsToAnalyze.push({
            id: entity.id,
            text: entity.description || entity.name,
          })
        }
      }
    }

    if (document_ids && document_ids.length > 0) {
      // Get claims from documents
      const { data: mentions } = await supabase
        .from('entity_mentions')
        .select(`
          entity_id,
          document_id,
          context_text,
          entity:knowledge_entities!entity_id(id, name, description, entity_type)
        `)
        .in('document_id', document_ids)

      if (mentions) {
        for (const mention of mentions) {
          // Supabase returns joined data - may be object or array depending on relation
          const entityData = mention.entity as unknown
          const entity = Array.isArray(entityData) ? entityData[0] : entityData
          if (entity && typeof entity === 'object' && 'entity_type' in entity && entity.entity_type === 'claim') {
            const e = entity as { id: string; name: string; description: string | null; entity_type: string }
            claimsToAnalyze.push({
              id: e.id,
              text: mention.context_text || e.description || e.name,
              document_id: mention.document_id,
            })
          }
        }
      }
    }

    if (claimsToAnalyze.length < 2) {
      return NextResponse.json({
        contradictions: [],
        message: 'Need at least 2 claims to detect contradictions'
      })
    }

    // Use AI to detect contradictions
    const claimsText = claimsToAnalyze.map((c, i) => `[${i + 1}] ${c.text}`).join('\n')

    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 3000,
      messages: [
        {
          role: 'user',
          content: `Analyze these research claims for contradictions, conflicts, or inconsistencies:

${claimsText}

Identify any pairs of claims that:
1. Directly contradict each other
2. Present conflicting findings
3. Make incompatible assertions
4. Have logical inconsistencies

For each contradiction found, assess:
- Severity: low (minor discrepancy), medium (significant disagreement), high (major conflict), critical (fundamental incompatibility)
- Type of contradiction (direct, implied, methodological, etc.)

Respond with JSON:
{
  "contradictions": [
    {
      "claim_a_index": 1,
      "claim_b_index": 2,
      "description": "Clear description of the contradiction",
      "severity": "low|medium|high|critical",
      "analysis": {
        "type": "type of contradiction",
        "explanation": "detailed explanation",
        "possible_resolutions": ["how this might be resolved"]
      }
    }
  ],
  "summary": "Overall assessment of claim consistency"
}

Return empty contradictions array if no contradictions found.
Only return valid JSON.`,
        },
      ],
    })

    const aiContent = response.content[0]
    if (aiContent.type !== 'text') {
      throw new Error('Unexpected response format')
    }

    let detection: {
      contradictions: Array<{
        claim_a_index: number
        claim_b_index: number
        description: string
        severity: 'low' | 'medium' | 'high' | 'critical'
        analysis: {
          type: string
          explanation: string
          possible_resolutions: string[]
        }
      }>
      summary: string
    }

    try {
      let jsonStr = aiContent.text.trim()
      if (jsonStr.startsWith('```')) jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
      detection = JSON.parse(jsonStr)
    } catch {
      return NextResponse.json({
        error: 'Failed to parse AI detection',
        raw_response: aiContent.text,
      }, { status: 500 })
    }

    // Map detected contradictions back to claims
    const detectedContradictions: DetectedContradiction[] = detection.contradictions.map(c => ({
      claim_a: {
        entity_id: claimsToAnalyze[c.claim_a_index - 1]?.id,
        text: claimsToAnalyze[c.claim_a_index - 1]?.text || '',
        document_id: claimsToAnalyze[c.claim_a_index - 1]?.document_id,
      },
      claim_b: {
        entity_id: claimsToAnalyze[c.claim_b_index - 1]?.id,
        text: claimsToAnalyze[c.claim_b_index - 1]?.text || '',
        document_id: claimsToAnalyze[c.claim_b_index - 1]?.document_id,
      },
      description: c.description,
      severity: c.severity,
      analysis: c.analysis,
    }))

    // Save to database if requested
    if (save_results && detectedContradictions.length > 0) {
      for (const contradiction of detectedContradictions) {
        // Only save if we have entity IDs for both claims
        if (contradiction.claim_a.entity_id && contradiction.claim_b.entity_id) {
          await supabase.from('contradictions').insert({
            workspace_id,
            claim_a_entity_id: contradiction.claim_a.entity_id,
            claim_b_entity_id: contradiction.claim_b.entity_id,
            description: contradiction.description,
            severity: contradiction.severity,
            status: 'detected',
            document_a_id: contradiction.claim_a.document_id || null,
            document_b_id: contradiction.claim_b.document_id || null,
            analysis: contradiction.analysis,
            resolution_suggestion: contradiction.analysis.possible_resolutions?.join('; '),
          })
        }
      }
    }

    return NextResponse.json({
      contradictions: detectedContradictions,
      summary: detection.summary,
      saved: save_results && detectedContradictions.some(c => c.claim_a.entity_id && c.claim_b.entity_id),
    })

  } catch (error) {
    console.error('Contradiction detection error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/knowledge/contradictions - Update contradiction status
 */
export async function PATCH(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { contradiction_id, status, resolution_notes } = body

    if (!contradiction_id) {
      return NextResponse.json({ error: 'contradiction_id required' }, { status: 400 })
    }

    // Get contradiction to check workspace
    const { data: contradiction } = await supabase
      .from('contradictions')
      .select('workspace_id')
      .eq('id', contradiction_id)
      .single()

    if (!contradiction) {
      return NextResponse.json({ error: 'Contradiction not found' }, { status: 404 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', contradiction.workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin', 'editor'].includes(member.role)) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    const updates: Record<string, unknown> = {}
    if (status) updates.status = status
    if (resolution_notes) updates.resolution_notes = resolution_notes

    if (status === 'resolved' || status === 'dismissed') {
      updates.resolved_by = user.id
      updates.resolved_at = new Date().toISOString()
    }

    const { data: updated, error } = await supabase
      .from('contradictions')
      .update(updates)
      .eq('id', contradiction_id)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ contradiction: updated })

  } catch (error) {
    console.error('Update contradiction error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/knowledge/entities/[id]/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/knowledge/entities/[id] - Get entity details with mentions
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get entity with related data
    const { data: entity, error } = await supabase
      .from('knowledge_entities')
      .select(`
        *,
        mentions:entity_mentions(
          id,
          document_id,
          section_id,
          mention_text,
          context_text,
          confidence,
          created_at,
          document:documents(id, title)
        ),
        outgoing_relationships:entity_relationships!source_entity_id(
          id,
          target_entity_id,
          relationship_type,
          description,
          confidence,
          target:knowledge_entities!target_entity_id(id, name, entity_type)
        ),
        incoming_relationships:entity_relationships!target_entity_id(
          id,
          source_entity_id,
          relationship_type,
          description,
          confidence,
          source:knowledge_entities!source_entity_id(id, name, entity_type)
        )
      `)
      .eq('id', id)
      .single()

    if (error) {
      return NextResponse.json({ error: 'Entity not found' }, { status: 404 })
    }

    return NextResponse.json({ entity })

  } catch (error) {
    console.error('Get entity error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/knowledge/entities/[id] - Update entity
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get entity to check workspace
    const { data: existingEntity } = await supabase
      .from('knowledge_entities')
      .select('workspace_id')
      .eq('id', id)
      .single()

    if (!existingEntity) {
      return NextResponse.json({ error: 'Entity not found' }, { status: 404 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', existingEntity.workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin', 'editor'].includes(member.role)) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    const body = await request.json()
    const { name, description, aliases, properties } = body

    const updates: Record<string, unknown> = {}
    if (name !== undefined) {
      updates.name = name
      updates.normalized_name = name.toLowerCase().trim().replace(/\s+/g, ' ')
    }
    if (description !== undefined) updates.description = description
    if (aliases !== undefined) updates.aliases = aliases
    if (properties !== undefined) updates.properties = properties

    const { data: entity, error } = await supabase
      .from('knowledge_entities')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ entity })

  } catch (error) {
    console.error('Update entity error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/knowledge/entities/[id] - Delete entity
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get entity to check workspace
    const { data: entity } = await supabase
      .from('knowledge_entities')
      .select('workspace_id')
      .eq('id', id)
      .single()

    if (!entity) {
      return NextResponse.json({ error: 'Entity not found' }, { status: 404 })
    }

    // Verify workspace access - only admin/owner can delete
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', entity.workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin'].includes(member.role)) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    const { error } = await supabase
      .from('knowledge_entities')
      .delete()
      .eq('id', id)

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Delete entity error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/knowledge/entities/[id] - Merge with another entity
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { merge_with_id } = body

    if (!merge_with_id) {
      return NextResponse.json({ error: 'merge_with_id required' }, { status: 400 })
    }

    // Get both entities
    const { data: primaryEntity } = await supabase
      .from('knowledge_entities')
      .select('*')
      .eq('id', id)
      .single()

    const { data: secondaryEntity } = await supabase
      .from('knowledge_entities')
      .select('*')
      .eq('id', merge_with_id)
      .single()

    if (!primaryEntity || !secondaryEntity) {
      return NextResponse.json({ error: 'Entity not found' }, { status: 404 })
    }

    if (primaryEntity.workspace_id !== secondaryEntity.workspace_id) {
      return NextResponse.json({ error: 'Cannot merge entities from different workspaces' }, { status: 400 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', primaryEntity.workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin'].includes(member.role)) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    // Merge aliases
    const mergedAliases = [...new Set([
      ...(primaryEntity.aliases || []),
      ...(secondaryEntity.aliases || []),
      secondaryEntity.name, // Add secondary name as alias
    ])]

    // Update primary entity
    await supabase
      .from('knowledge_entities')
      .update({
        aliases: mergedAliases,
        description: primaryEntity.description || secondaryEntity.description,
      })
      .eq('id', id)

    // Move mentions from secondary to primary
    await supabase
      .from('entity_mentions')
      .update({ entity_id: id })
      .eq('entity_id', merge_with_id)

    // Update relationships - source
    await supabase
      .from('entity_relationships')
      .update({ source_entity_id: id })
      .eq('source_entity_id', merge_with_id)

    // Update relationships - target
    await supabase
      .from('entity_relationships')
      .update({ target_entity_id: id })
      .eq('target_entity_id', merge_with_id)

    // Update contradictions
    await supabase
      .from('contradictions')
      .update({ claim_a_entity_id: id })
      .eq('claim_a_entity_id', merge_with_id)

    await supabase
      .from('contradictions')
      .update({ claim_b_entity_id: id })
      .eq('claim_b_entity_id', merge_with_id)

    // Delete secondary entity
    await supabase
      .from('knowledge_entities')
      .delete()
      .eq('id', merge_with_id)

    // Get updated entity
    const { data: mergedEntity } = await supabase
      .from('knowledge_entities')
      .select('*')
      .eq('id', id)
      .single()

    return NextResponse.json({
      entity: mergedEntity,
      merged_from: secondaryEntity.name,
    })

  } catch (error) {
    console.error('Merge entity error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/knowledge/entities/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/knowledge/entities - List entities in a workspace
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const entityType = searchParams.get('type')
    const search = searchParams.get('search')
    const limit = parseInt(searchParams.get('limit') || '50')
    const offset = parseInt(searchParams.get('offset') || '0')

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    let query = supabase
      .from('knowledge_entities')
      .select('*, mention_count:entity_mentions(count)', { count: 'exact' })
      .eq('workspace_id', workspaceId)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1)

    if (entityType) {
      query = query.eq('entity_type', entityType)
    }

    if (search) {
      query = query.or(`name.ilike.%${search}%,description.ilike.%${search}%`)
    }

    const { data: entities, error, count } = await query

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({
      entities,
      total: count,
      limit,
      offset,
    })

  } catch (error) {
    console.error('List entities error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/knowledge/entities - Create a new entity manually
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { workspace_id, name, entity_type, description, aliases, properties } = body

    if (!workspace_id || !name || !entity_type) {
      return NextResponse.json({ error: 'workspace_id, name, and entity_type required' }, { status: 400 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin', 'editor'].includes(member.role)) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    const normalizedName = name.toLowerCase().trim().replace(/\s+/g, ' ')

    // Check for existing entity
    const { data: existing } = await supabase
      .from('knowledge_entities')
      .select('id')
      .eq('workspace_id', workspace_id)
      .eq('normalized_name', normalizedName)
      .eq('entity_type', entity_type)
      .single()

    if (existing) {
      return NextResponse.json({ error: 'Entity already exists', existing_id: existing.id }, { status: 409 })
    }

    const { data: entity, error } = await supabase
      .from('knowledge_entities')
      .insert({
        workspace_id,
        name,
        normalized_name: normalizedName,
        entity_type,
        description,
        aliases: aliases || [],
        properties: properties || {},
        confidence: 1.0, // Manual entries are high confidence
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ entity }, { status: 201 })

  } catch (error) {
    console.error('Create entity error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/knowledge/extract/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

interface ExtractedEntity {
  name: string
  type: 'person' | 'organization' | 'concept' | 'claim' | 'methodology' | 'finding' | 'dataset' | 'location' | 'event' | 'term' | 'other'
  description?: string
  aliases?: string[]
  confidence: number
  mentions: Array<{
    text: string
    context?: string
    start_offset?: number
    end_offset?: number
  }>
}

interface ExtractedRelationship {
  source_name: string
  target_name: string
  relationship_type: 'supports' | 'contradicts' | 'related_to' | 'derived_from' | 'part_of' | 'authored_by' | 'references' | 'defines' | 'uses' | 'causes' | 'precedes' | 'equivalent_to'
  description?: string
  confidence: number
  evidence_text?: string
}

/**
 * POST /api/knowledge/extract - Extract entities and relationships from document
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { document_id, section_id, content, workspace_id, save_results = true } = body

    if (!content || !workspace_id) {
      return NextResponse.json({ error: 'content and workspace_id required' }, { status: 400 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin', 'editor'].includes(member.role)) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    // Use AI to extract entities and relationships
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 4000,
      messages: [
        {
          role: 'user',
          content: `Analyze this research text and extract all meaningful entities and relationships between them.

Text to analyze:
"""
${content}
"""

Extract:
1. **Entities**: People, organizations, concepts, claims, methodologies, findings, datasets, locations, events, and key terms
2. **Relationships**: How entities relate to each other (supports, contradicts, related_to, derived_from, part_of, authored_by, references, defines, uses, causes, precedes, equivalent_to)

Be thorough but precise. Only include entities that are significant to the research content.

Respond with JSON:
{
  "entities": [
    {
      "name": "Entity Name",
      "type": "person|organization|concept|claim|methodology|finding|dataset|location|event|term|other",
      "description": "Brief description of this entity in context",
      "aliases": ["alternative names or abbreviations"],
      "confidence": 0.0-1.0,
      "mentions": [
        {
          "text": "exact text where entity appears",
          "context": "surrounding sentence for context"
        }
      ]
    }
  ],
  "relationships": [
    {
      "source_name": "Entity A",
      "target_name": "Entity B",
      "relationship_type": "supports|contradicts|related_to|derived_from|part_of|authored_by|references|defines|uses|causes|precedes|equivalent_to",
      "description": "How they relate",
      "confidence": 0.0-1.0,
      "evidence_text": "text supporting this relationship"
    }
  ]
}

Only return valid JSON.`,
        },
      ],
    })

    const aiContent = response.content[0]
    if (aiContent.type !== 'text') {
      throw new Error('Unexpected response format')
    }

    let extraction: { entities: ExtractedEntity[]; relationships: ExtractedRelationship[] }
    try {
      let jsonStr = aiContent.text.trim()
      if (jsonStr.startsWith('```')) jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
      extraction = JSON.parse(jsonStr)
    } catch {
      return NextResponse.json({
        error: 'Failed to parse AI extraction',
        raw_response: aiContent.text,
      }, { status: 500 })
    }

    // If save_results is true, persist to database
    if (save_results) {
      const entityIdMap = new Map<string, string>()

      // Insert or update entities
      for (const entity of extraction.entities) {
        const normalizedName = entity.name.toLowerCase().trim().replace(/\s+/g, ' ')

        // Check for existing entity
        const { data: existing } = await supabase
          .from('knowledge_entities')
          .select('id')
          .eq('workspace_id', workspace_id)
          .eq('normalized_name', normalizedName)
          .eq('entity_type', entity.type)
          .single()

        let entityId: string

        if (existing) {
          entityId = existing.id
          // Update aliases if new ones found - just update directly
          if (entity.aliases && entity.aliases.length > 0) {
            const { data: currentEntity } = await supabase
              .from('knowledge_entities')
              .select('aliases')
              .eq('id', entityId)
              .single()

            const existingAliases = (currentEntity?.aliases || []) as string[]
            const newAliases = [...new Set([...existingAliases, ...entity.aliases])]

            await supabase
              .from('knowledge_entities')
              .update({ aliases: newAliases })
              .eq('id', entityId)
          }
        } else {
          // Insert new entity
          const { data: newEntity, error: insertError } = await supabase
            .from('knowledge_entities')
            .insert({
              workspace_id,
              name: entity.name,
              normalized_name: normalizedName,
              entity_type: entity.type,
              description: entity.description,
              aliases: entity.aliases || [],
              confidence: entity.confidence,
            })
            .select('id')
            .single()

          if (insertError) {
            console.error('Entity insert error:', insertError)
            continue
          }
          entityId = newEntity.id
        }

        entityIdMap.set(entity.name.toLowerCase(), entityId)

        // Insert mentions
        if (document_id && entity.mentions) {
          // Get branch_id for the document
          const { data: branch } = await supabase
            .from('doc_branches')
            .select('id')
            .eq('document_id', document_id)
            .eq('is_main', true)
            .single()

          if (branch) {
            for (const mention of entity.mentions) {
              await supabase.from('entity_mentions').insert({
                entity_id: entityId,
                document_id,
                branch_id: branch.id,
                section_id: section_id || null,
                mention_text: mention.text,
                context_text: mention.context,
                start_offset: mention.start_offset,
                end_offset: mention.end_offset,
                extraction_method: 'ai',
                confidence: entity.confidence,
              })
            }
          }
        }
      }

      // Insert relationships
      for (const rel of extraction.relationships) {
        const sourceId = entityIdMap.get(rel.source_name.toLowerCase())
        const targetId = entityIdMap.get(rel.target_name.toLowerCase())

        if (sourceId && targetId) {
          await supabase.from('entity_relationships').upsert({
            workspace_id,
            source_entity_id: sourceId,
            target_entity_id: targetId,
            relationship_type: rel.relationship_type,
            description: rel.description,
            confidence: rel.confidence,
            evidence_document_id: document_id || null,
            evidence_text: rel.evidence_text,
          }, {
            onConflict: 'source_entity_id,target_entity_id,relationship_type',
          })
        }
      }
    }

    return NextResponse.json({
      entities: extraction.entities,
      relationships: extraction.relationships,
      saved: save_results,
      entity_count: extraction.entities.length,
      relationship_count: extraction.relationships.length,
    })

  } catch (error) {
    console.error('Entity extraction error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/knowledge/graph/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

interface GraphNode {
  id: string
  name: string
  type: string
  description?: string
  mention_count?: number
}

interface GraphEdge {
  id: string
  source: string
  target: string
  type: string
  weight: number
  description?: string
}

/**
 * GET /api/knowledge/graph - Get knowledge graph data for visualization
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const centerId = searchParams.get('center_id') // Optional: focus on specific entity
    const depth = parseInt(searchParams.get('depth') || '2')
    const limit = parseInt(searchParams.get('limit') || '100')
    const entityTypes = searchParams.get('entity_types')?.split(',')
    const relationshipTypes = searchParams.get('relationship_types')?.split(',')
    const documentId = searchParams.get('document_id') // Filter by document

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    // Use the database function for graph traversal if we have a center
    if (centerId) {
      const { data: graphData, error } = await supabase.rpc('get_entity_graph', {
        p_workspace_id: workspaceId,
        p_center_entity_id: centerId,
        p_depth: depth,
        p_limit: limit,
      })

      if (error) {
        console.error('Graph RPC error:', error)
        // Fall back to manual query
      } else if (graphData) {
        return NextResponse.json(graphData)
      }
    }

    // Manual query for full graph or filtered views
    let entitiesQuery = supabase
      .from('knowledge_entities')
      .select('id, name, entity_type, description')
      .eq('workspace_id', workspaceId)
      .limit(limit)

    if (entityTypes && entityTypes.length > 0) {
      entitiesQuery = entitiesQuery.in('entity_type', entityTypes)
    }

    // If filtering by document, only get entities with mentions in that document
    if (documentId) {
      const { data: mentionedEntities } = await supabase
        .from('entity_mentions')
        .select('entity_id')
        .eq('document_id', documentId)

      if (mentionedEntities && mentionedEntities.length > 0) {
        const entityIds = mentionedEntities.map(m => m.entity_id)
        entitiesQuery = entitiesQuery.in('id', entityIds)
      } else {
        return NextResponse.json({ nodes: [], edges: [] })
      }
    }

    const { data: entities, error: entitiesError } = await entitiesQuery

    if (entitiesError) {
      return NextResponse.json({ error: entitiesError.message }, { status: 500 })
    }

    // Get mention counts for each entity
    const entityIds = entities?.map(e => e.id) || []
    const mentionCounts = new Map<string, number>()

    if (entityIds.length > 0) {
      const { data: counts } = await supabase
        .from('entity_mentions')
        .select('entity_id')
        .in('entity_id', entityIds)

      if (counts) {
        for (const mention of counts) {
          const current = mentionCounts.get(mention.entity_id) || 0
          mentionCounts.set(mention.entity_id, current + 1)
        }
      }
    }

    // Build nodes
    const nodes: GraphNode[] = (entities || []).map(e => ({
      id: e.id,
      name: e.name,
      type: e.entity_type,
      description: e.description,
      mention_count: mentionCounts.get(e.id) || 0,
    }))

    // Get relationships
    let relationshipsQuery = supabase
      .from('entity_relationships')
      .select('id, source_entity_id, target_entity_id, relationship_type, weight, description')
      .eq('workspace_id', workspaceId)

    if (entityIds.length > 0) {
      relationshipsQuery = relationshipsQuery.or(
        `source_entity_id.in.(${entityIds.join(',')}),target_entity_id.in.(${entityIds.join(',')})`
      )
    }

    if (relationshipTypes && relationshipTypes.length > 0) {
      relationshipsQuery = relationshipsQuery.in('relationship_type', relationshipTypes)
    }

    const { data: relationships, error: relationshipsError } = await relationshipsQuery

    if (relationshipsError) {
      return NextResponse.json({ error: relationshipsError.message }, { status: 500 })
    }

    // Filter edges to only include those where both nodes exist
    const nodeIds = new Set(nodes.map(n => n.id))
    const edges: GraphEdge[] = (relationships || [])
      .filter(r => nodeIds.has(r.source_entity_id) && nodeIds.has(r.target_entity_id))
      .map(r => ({
        id: r.id,
        source: r.source_entity_id,
        target: r.target_entity_id,
        type: r.relationship_type,
        weight: r.weight,
        description: r.description,
      }))

    return NextResponse.json({
      nodes,
      edges,
      stats: {
        node_count: nodes.length,
        edge_count: edges.length,
        entity_types: [...new Set(nodes.map(n => n.type))],
        relationship_types: [...new Set(edges.map(e => e.type))],
      },
    })

  } catch (error) {
    console.error('Get graph error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/knowledge/graph - Save graph snapshot
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { workspace_id, name, description } = body

    if (!workspace_id || !name) {
      return NextResponse.json({ error: 'workspace_id and name required' }, { status: 400 })
    }

    // Verify workspace access - only admin/owner can create snapshots
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin'].includes(member.role)) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    // Get current graph state
    const { data: entities } = await supabase
      .from('knowledge_entities')
      .select('*')
      .eq('workspace_id', workspace_id)

    const { data: relationships } = await supabase
      .from('entity_relationships')
      .select('*')
      .eq('workspace_id', workspace_id)

    const snapshotData = {
      entities: entities || [],
      relationships: relationships || [],
      created_at: new Date().toISOString(),
    }

    const { data: snapshot, error } = await supabase
      .from('graph_snapshots')
      .insert({
        workspace_id,
        name,
        description,
        entity_count: (entities || []).length,
        relationship_count: (relationships || []).length,
        snapshot_data: snapshotData,
        created_by: user.id,
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ snapshot }, { status: 201 })

  } catch (error) {
    console.error('Create snapshot error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/knowledge/query/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

/**
 * POST /api/knowledge/query - Natural language queries over knowledge graph
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { workspace_id, query } = body

    if (!workspace_id || !query) {
      return NextResponse.json({ error: 'workspace_id and query required' }, { status: 400 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!member) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    // Get knowledge graph context
    const { data: entities } = await supabase
      .from('knowledge_entities')
      .select('id, name, entity_type, description')
      .eq('workspace_id', workspace_id)
      .limit(100)

    const { data: relationships } = await supabase
      .from('entity_relationships')
      .select(`
        source_entity_id,
        target_entity_id,
        relationship_type,
        description,
        source:knowledge_entities!source_entity_id(name),
        target:knowledge_entities!target_entity_id(name)
      `)
      .eq('workspace_id', workspace_id)
      .limit(200)

    const { data: contradictions } = await supabase
      .from('contradictions')
      .select(`
        description,
        severity,
        status,
        claim_a:knowledge_entities!claim_a_entity_id(name),
        claim_b:knowledge_entities!claim_b_entity_id(name)
      `)
      .eq('workspace_id', workspace_id)
      .eq('status', 'detected')
      .limit(20)

    // Build context for AI
    const entitiesContext = entities?.map(e =>
      `- ${e.name} (${e.entity_type}): ${e.description || 'No description'}`
    ).join('\n') || 'No entities found'

    const relationshipsContext = relationships?.map(r => {
      const sourceName = Array.isArray(r.source) ? r.source[0]?.name : (r.source as { name: string } | null)?.name
      const targetName = Array.isArray(r.target) ? r.target[0]?.name : (r.target as { name: string } | null)?.name
      return `- ${sourceName} ${r.relationship_type} ${targetName}${r.description ? `: ${r.description}` : ''}`
    }).join('\n') || 'No relationships found'

    const contradictionsContext = contradictions?.map(c => {
      const claimAName = Array.isArray(c.claim_a) ? c.claim_a[0]?.name : (c.claim_a as { name: string } | null)?.name
      const claimBName = Array.isArray(c.claim_b) ? c.claim_b[0]?.name : (c.claim_b as { name: string } | null)?.name
      return `- [${c.severity}] ${claimAName} vs ${claimBName}: ${c.description}`
    }).join('\n') || 'No contradictions detected'

    // Query the AI
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      messages: [
        {
          role: 'user',
          content: `You are a research assistant with access to a knowledge graph. Answer the user's question based on the following knowledge:

ENTITIES:
${entitiesContext}

RELATIONSHIPS:
${relationshipsContext}

DETECTED CONTRADICTIONS:
${contradictionsContext}

USER QUESTION: ${query}

Provide a clear, structured answer based on the knowledge graph data. If the information needed isn't in the knowledge graph, say so. Include specific entity names and relationships in your answer.

Format your response as JSON:
{
  "answer": "Your detailed answer here",
  "relevant_entities": ["Entity names that are relevant to the answer"],
  "relevant_relationships": ["Relationship descriptions relevant to the answer"],
  "contradictions_noted": ["Any contradictions that affect this answer"],
  "confidence": "high" | "medium" | "low",
  "gaps": ["Information gaps that would improve the answer"]
}

Only return valid JSON.`,
        },
      ],
    })

    const aiContent = response.content[0]
    if (aiContent.type !== 'text') {
      throw new Error('Unexpected response format')
    }

    let result
    try {
      let jsonStr = aiContent.text.trim()
      if (jsonStr.startsWith('```')) jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
      result = JSON.parse(jsonStr)
    } catch {
      result = {
        answer: aiContent.text,
        relevant_entities: [],
        relevant_relationships: [],
        contradictions_noted: [],
        confidence: 'low',
        gaps: ['Failed to parse structured response'],
      }
    }

    // Find entity IDs for relevant entities
    const relevantEntityIds = entities
      ?.filter(e => result.relevant_entities?.includes(e.name))
      .map(e => e.id) || []

    return NextResponse.json({
      query,
      result,
      relevant_entity_ids: relevantEntityIds,
      context_size: {
        entities: entities?.length || 0,
        relationships: relationships?.length || 0,
        contradictions: contradictions?.length || 0,
      },
    })

  } catch (error) {
    console.error('Knowledge query error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/knowledge/relationships/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/knowledge/relationships - List relationships in a workspace
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const entityId = searchParams.get('entity_id')
    const relationshipType = searchParams.get('type')
    const limit = parseInt(searchParams.get('limit') || '100')
    const offset = parseInt(searchParams.get('offset') || '0')

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    let query = supabase
      .from('entity_relationships')
      .select(`
        *,
        source:knowledge_entities!source_entity_id(id, name, entity_type),
        target:knowledge_entities!target_entity_id(id, name, entity_type),
        evidence_document:documents(id, title)
      `, { count: 'exact' })
      .eq('workspace_id', workspaceId)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1)

    if (entityId) {
      query = query.or(`source_entity_id.eq.${entityId},target_entity_id.eq.${entityId}`)
    }

    if (relationshipType) {
      query = query.eq('relationship_type', relationshipType)
    }

    const { data: relationships, error, count } = await query

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({
      relationships,
      total: count,
      limit,
      offset,
    })

  } catch (error) {
    console.error('List relationships error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/knowledge/relationships - Create a new relationship
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      workspace_id,
      source_entity_id,
      target_entity_id,
      relationship_type,
      description,
      evidence_document_id,
      evidence_text,
      weight = 1.0,
      confidence = 1.0,
    } = body

    if (!workspace_id || !source_entity_id || !target_entity_id || !relationship_type) {
      return NextResponse.json({
        error: 'workspace_id, source_entity_id, target_entity_id, and relationship_type required',
      }, { status: 400 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin', 'editor'].includes(member.role)) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    // Verify both entities exist in this workspace
    const { data: sourceEntity } = await supabase
      .from('knowledge_entities')
      .select('id')
      .eq('id', source_entity_id)
      .eq('workspace_id', workspace_id)
      .single()

    const { data: targetEntity } = await supabase
      .from('knowledge_entities')
      .select('id')
      .eq('id', target_entity_id)
      .eq('workspace_id', workspace_id)
      .single()

    if (!sourceEntity || !targetEntity) {
      return NextResponse.json({ error: 'One or both entities not found in workspace' }, { status: 404 })
    }

    const { data: relationship, error } = await supabase
      .from('entity_relationships')
      .upsert({
        workspace_id,
        source_entity_id,
        target_entity_id,
        relationship_type,
        description,
        evidence_document_id,
        evidence_text,
        weight,
        confidence,
      }, {
        onConflict: 'source_entity_id,target_entity_id,relationship_type',
      })
      .select(`
        *,
        source:knowledge_entities!source_entity_id(id, name, entity_type),
        target:knowledge_entities!target_entity_id(id, name, entity_type)
      `)
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ relationship }, { status: 201 })

  } catch (error) {
    console.error('Create relationship error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/knowledge/relationships - Delete a relationship
 */
export async function DELETE(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const relationshipId = searchParams.get('id')

    if (!relationshipId) {
      return NextResponse.json({ error: 'id required' }, { status: 400 })
    }

    // Get relationship to check workspace
    const { data: relationship } = await supabase
      .from('entity_relationships')
      .select('workspace_id')
      .eq('id', relationshipId)
      .single()

    if (!relationship) {
      return NextResponse.json({ error: 'Relationship not found' }, { status: 404 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', relationship.workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin', 'editor'].includes(member.role)) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    const { error } = await supabase
      .from('entity_relationships')
      .delete()
      .eq('id', relationshipId)

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Delete relationship error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/notifications/preferences/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/notifications/preferences - Get user's notification preferences
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')

    let query = supabase
      .from('notification_preferences')
      .select('*')
      .eq('user_id', user.id)

    if (workspaceId) {
      query = query.eq('workspace_id', workspaceId)
    }

    const { data: preferences, error } = await query

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    // Return default preferences if none exist
    if (!preferences || preferences.length === 0) {
      return NextResponse.json({
        preferences: [{
          user_id: user.id,
          workspace_id: workspaceId,
          email_weekly_summary: true,
          email_contradictions: true,
          email_mentions: true,
          email_document_changes: false,
          inapp_contradictions: true,
          inapp_mentions: true,
          inapp_document_changes: true,
          digest_day: 'monday',
          digest_time: '09:00',
        }],
        is_default: true,
      })
    }

    return NextResponse.json({ preferences, is_default: false })

  } catch (error) {
    console.error('Get preferences error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PUT /api/notifications/preferences - Update notification preferences
 */
export async function PUT(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      workspace_id,
      email_weekly_summary,
      email_contradictions,
      email_mentions,
      email_document_changes,
      inapp_contradictions,
      inapp_mentions,
      inapp_document_changes,
      digest_day,
      digest_time,
    } = body

    const updates: Record<string, unknown> = {}
    if (email_weekly_summary !== undefined) updates.email_weekly_summary = email_weekly_summary
    if (email_contradictions !== undefined) updates.email_contradictions = email_contradictions
    if (email_mentions !== undefined) updates.email_mentions = email_mentions
    if (email_document_changes !== undefined) updates.email_document_changes = email_document_changes
    if (inapp_contradictions !== undefined) updates.inapp_contradictions = inapp_contradictions
    if (inapp_mentions !== undefined) updates.inapp_mentions = inapp_mentions
    if (inapp_document_changes !== undefined) updates.inapp_document_changes = inapp_document_changes
    if (digest_day !== undefined) updates.digest_day = digest_day
    if (digest_time !== undefined) updates.digest_time = digest_time

    // Upsert preferences
    const { data: preferences, error } = await supabase
      .from('notification_preferences')
      .upsert({
        user_id: user.id,
        workspace_id: workspace_id || null,
        ...updates,
      }, {
        onConflict: 'user_id,workspace_id',
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ preferences })

  } catch (error) {
    console.error('Update preferences error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/notifications/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/notifications - Get user's notifications
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const status = searchParams.get('status')
    const limit = parseInt(searchParams.get('limit') || '20')
    const offset = parseInt(searchParams.get('offset') || '0')

    let query = supabase
      .from('notifications')
      .select('*', { count: 'exact' })
      .eq('user_id', user.id)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1)

    if (status) {
      query = query.eq('status', status)
    }

    const { data: notifications, error, count } = await query

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    // Get unread count
    const { count: unreadCount } = await supabase
      .from('notifications')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('status', 'unread')

    return NextResponse.json({
      notifications,
      total: count,
      unread_count: unreadCount,
      limit,
      offset,
    })

  } catch (error) {
    console.error('Get notifications error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/notifications - Update notification status
 */
export async function PATCH(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { notification_id, notification_ids, status, mark_all_read } = body

    if (mark_all_read) {
      // Mark all as read
      const { error } = await supabase
        .from('notifications')
        .update({ status: 'read', read_at: new Date().toISOString() })
        .eq('user_id', user.id)
        .eq('status', 'unread')

      if (error) {
        return NextResponse.json({ error: error.message }, { status: 500 })
      }

      return NextResponse.json({ success: true, marked_all_read: true })
    }

    if (!notification_id && !notification_ids) {
      return NextResponse.json({ error: 'notification_id or notification_ids required' }, { status: 400 })
    }

    const ids = notification_ids || [notification_id]

    const updates: Record<string, unknown> = { status }
    if (status === 'read') {
      updates.read_at = new Date().toISOString()
    }

    const { data: updated, error } = await supabase
      .from('notifications')
      .update(updates)
      .in('id', ids)
      .eq('user_id', user.id)
      .select()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ notifications: updated })

  } catch (error) {
    console.error('Update notifications error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/notifications - Delete notifications
 */
export async function DELETE(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const notificationId = searchParams.get('id')
    const deleteRead = searchParams.get('delete_read') === 'true'

    if (deleteRead) {
      // Delete all read notifications
      const { error } = await supabase
        .from('notifications')
        .delete()
        .eq('user_id', user.id)
        .eq('status', 'read')

      if (error) {
        return NextResponse.json({ error: error.message }, { status: 500 })
      }

      return NextResponse.json({ success: true, deleted_read: true })
    }

    if (!notificationId) {
      return NextResponse.json({ error: 'id required' }, { status: 400 })
    }

    const { error } = await supabase
      .from('notifications')
      .delete()
      .eq('id', notificationId)
      .eq('user_id', user.id)

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Delete notifications error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/research/arguments/[id]/nodes/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/research/arguments/[id]/nodes - Get nodes for an argument map
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: mapId } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { data: nodes, error } = await supabase
      .from('argument_nodes')
      .select(`
        *,
        source:sources (id, title),
        entity:knowledge_entities (id, name)
      `)
      .eq('map_id', mapId)
      .order('created_at', { ascending: true })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ nodes })
  } catch (error) {
    console.error('List argument nodes error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/research/arguments/[id]/nodes - Add a node to an argument map
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: mapId } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      parent_id,
      argument_type,
      stance,
      content,
      strength,
      source_id,
      entity_id,
      position_x,
      position_y
    } = body

    if (!argument_type || !content) {
      return NextResponse.json({ error: 'argument_type and content required' }, { status: 400 })
    }

    const { data: node, error } = await supabase
      .from('argument_nodes')
      .insert({
        map_id: mapId,
        parent_id,
        argument_type,
        stance: stance || 'neutral',
        content,
        strength: strength || 0.5,
        source_id,
        entity_id,
        position_x: position_x || 0,
        position_y: position_y || 0
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ node }, { status: 201 })
  } catch (error) {
    console.error('Create argument node error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/research/arguments/[id]/nodes - Update a node
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    await params // mapId not needed for update
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { node_id, ...updates } = body

    if (!node_id) {
      return NextResponse.json({ error: 'node_id required' }, { status: 400 })
    }

    const { data: node, error } = await supabase
      .from('argument_nodes')
      .update(updates)
      .eq('id', node_id)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ node })
  } catch (error) {
    console.error('Update argument node error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/research/arguments/[id]/nodes - Delete a node
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    await params // mapId not needed for delete
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const nodeId = searchParams.get('node_id')

    if (!nodeId) {
      return NextResponse.json({ error: 'node_id required' }, { status: 400 })
    }

    const { error } = await supabase
      .from('argument_nodes')
      .delete()
      .eq('id', nodeId)

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Delete argument node error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/research/arguments/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

/**
 * GET /api/research/arguments - List argument maps
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const documentId = searchParams.get('document_id')

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    let query = supabase
      .from('argument_maps')
      .select(`
        *,
        nodes:argument_nodes (count)
      `)
      .eq('workspace_id', workspaceId)

    if (documentId) {
      query = query.eq('document_id', documentId)
    }

    const { data: maps, error } = await query.order('created_at', { ascending: false })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ maps })
  } catch (error) {
    console.error('List argument maps error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/research/arguments - Create an argument map
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      workspace_id,
      document_id,
      title,
      description,
      central_claim,
      auto_generate
    } = body

    if (!workspace_id || !title) {
      return NextResponse.json({ error: 'workspace_id and title required' }, { status: 400 })
    }

    // Create the argument map
    const { data: map, error } = await supabase
      .from('argument_maps')
      .insert({
        workspace_id,
        document_id,
        title,
        description,
        central_claim,
        created_by: user.id
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    // Auto-generate argument structure from document
    if (auto_generate && document_id) {
      const { data: doc } = await supabase
        .from('documents')
        .select('content')
        .eq('id', document_id)
        .single()

      if (doc?.content) {
        // Extract text from Yjs content
        const text = typeof doc.content === 'string'
          ? doc.content
          : JSON.stringify(doc.content).substring(0, 10000)

        const response = await anthropic.messages.create({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 3000,
          messages: [{
            role: 'user',
            content: `Analyze this document and extract its argument structure.

Document content:
${text}

Respond with JSON only:
{
  "central_claim": "Main thesis or argument",
  "nodes": [
    {
      "type": "claim" | "premise" | "evidence" | "counterargument" | "rebuttal" | "conclusion",
      "stance": "pro" | "con" | "neutral",
      "content": "The argument content",
      "strength": 0.0-1.0,
      "parent_index": null | number
    }
  ]
}`
          }]
        })

        const content = response.content[0]
        if (content.type === 'text') {
          try {
            let jsonStr = content.text.trim()
            if (jsonStr.startsWith('```')) {
              jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
            }
            const parsed = JSON.parse(jsonStr)

            // Update central claim if generated
            if (parsed.central_claim && !central_claim) {
              await supabase
                .from('argument_maps')
                .update({ central_claim: parsed.central_claim })
                .eq('id', map.id)
            }

            // Insert nodes
            if (parsed.nodes && Array.isArray(parsed.nodes)) {
              const nodeIds: string[] = []

              for (let i = 0; i < parsed.nodes.length; i++) {
                const node = parsed.nodes[i]
                const { data: insertedNode } = await supabase
                  .from('argument_nodes')
                  .insert({
                    map_id: map.id,
                    parent_id: node.parent_index !== null && node.parent_index !== undefined
                      ? nodeIds[node.parent_index]
                      : null,
                    argument_type: node.type,
                    stance: node.stance,
                    content: node.content,
                    strength: node.strength,
                    position_x: (i % 3) * 200,
                    position_y: Math.floor(i / 3) * 150
                  })
                  .select()
                  .single()

                if (insertedNode) {
                  nodeIds.push(insertedNode.id)
                }
              }
            }
          } catch {
            // Continue without auto-generation
          }
        }
      }
    }

    // Fetch the complete map with nodes
    const { data: completeMap } = await supabase
      .from('argument_maps')
      .select(`
        *,
        nodes:argument_nodes (*)
      `)
      .eq('id', map.id)
      .single()

    return NextResponse.json({ map: completeMap || map }, { status: 201 })
  } catch (error) {
    console.error('Create argument map error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/research/fallacies/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

const FALLACY_TYPES = [
  'ad_hominem',
  'straw_man',
  'false_dichotomy',
  'slippery_slope',
  'appeal_to_authority',
  'appeal_to_emotion',
  'circular_reasoning',
  'hasty_generalization',
  'red_herring',
  'false_cause',
  'equivocation',
  'loaded_question',
  'bandwagon',
  'tu_quoque',
  'no_true_scotsman'
]

/**
 * GET /api/research/fallacies - List detected fallacies
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const documentId = searchParams.get('document_id')
    const fallacyType = searchParams.get('type')

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    let query = supabase
      .from('detected_fallacies')
      .select('*')
      .eq('workspace_id', workspaceId)

    if (documentId) {
      query = query.eq('document_id', documentId)
    }

    if (fallacyType) {
      query = query.eq('fallacy_type', fallacyType)
    }

    const { data: fallacies, error } = await query.order('detected_at', { ascending: false })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ fallacies, types: FALLACY_TYPES })
  } catch (error) {
    console.error('List fallacies error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/research/fallacies - Detect fallacies in content
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { workspace_id, document_id, argument_node_id, content } = body

    if (!workspace_id || !content) {
      return NextResponse.json({ error: 'workspace_id and content required' }, { status: 400 })
    }

    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      messages: [{
        role: 'user',
        content: `Analyze this text for logical fallacies.

Text to analyze:
${content}

Known fallacy types: ${FALLACY_TYPES.join(', ')}

Respond with JSON only:
{
  "fallacies": [
    {
      "type": "fallacy_type from the list",
      "description": "Explanation of why this is a fallacy",
      "excerpt": "The specific text containing the fallacy",
      "severity": "low" | "medium" | "high",
      "suggestion": "How to fix or avoid this fallacy"
    }
  ],
  "overall_quality": 0.0-1.0,
  "summary": "Brief summary of argument quality"
}`
      }]
    })

    const responseContent = response.content[0]
    if (responseContent.type !== 'text') {
      return NextResponse.json({ error: 'Failed to analyze content' }, { status: 500 })
    }

    let jsonStr = responseContent.text.trim()
    if (jsonStr.startsWith('```')) {
      jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
    }

    const parsed = JSON.parse(jsonStr)
    const detectedFallacies = []

    // Save detected fallacies
    for (const fallacy of parsed.fallacies || []) {
      const { data: saved, error: saveError } = await supabase
        .from('detected_fallacies')
        .insert({
          workspace_id,
          document_id,
          argument_node_id,
          fallacy_type: fallacy.type,
          description: fallacy.description,
          excerpt: fallacy.excerpt,
          severity: fallacy.severity,
          suggestion: fallacy.suggestion
        })
        .select()
        .single()

      if (!saveError && saved) {
        detectedFallacies.push(saved)
      }
    }

    return NextResponse.json({
      fallacies: detectedFallacies,
      overall_quality: parsed.overall_quality,
      summary: parsed.summary
    }, { status: 201 })
  } catch (error) {
    console.error('Detect fallacies error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/research/hypotheses/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

/**
 * GET /api/research/hypotheses - List hypotheses
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const documentId = searchParams.get('document_id')
    const status = searchParams.get('status')

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    let query = supabase
      .from('hypotheses')
      .select('*')
      .eq('workspace_id', workspaceId)

    if (documentId) {
      query = query.eq('document_id', documentId)
    }

    if (status) {
      query = query.eq('status', status)
    }

    const { data: hypotheses, error } = await query.order('created_at', { ascending: false })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ hypotheses })
  } catch (error) {
    console.error('List hypotheses error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/research/hypotheses - Create or evaluate a hypothesis
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      workspace_id,
      document_id,
      statement,
      rationale,
      evaluate_against_sources
    } = body

    if (!workspace_id || !statement) {
      return NextResponse.json({ error: 'workspace_id and statement required' }, { status: 400 })
    }

    let supportingEvidence: unknown[] = []
    let contradictingEvidence: unknown[] = []
    let confidence: number | null = null

    // Optionally evaluate against sources
    if (evaluate_against_sources) {
      // Get sources with embeddings
      const { data: sources } = await supabase
        .from('sources')
        .select('id, title, abstract')
        .eq('workspace_id', workspace_id)
        .limit(20)

      if (sources && sources.length > 0) {
        const response = await anthropic.messages.create({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 2000,
          messages: [{
            role: 'user',
            content: `Evaluate this hypothesis against available sources.

Hypothesis: ${statement}
${rationale ? `Rationale: ${rationale}` : ''}

Available Sources:
${sources.map((s, i) => `${i + 1}. ${s.title}\n   Abstract: ${s.abstract || 'No abstract'}`).join('\n\n')}

Respond with JSON only:
{
  "supporting_evidence": [
    {"source_index": 1, "excerpt": "relevant text", "strength": 0.0-1.0}
  ],
  "contradicting_evidence": [
    {"source_index": 2, "excerpt": "contradicting text", "strength": 0.0-1.0}
  ],
  "overall_confidence": 0.0-1.0,
  "assessment": "Brief assessment of hypothesis viability"
}`
          }]
        })

        const content = response.content[0]
        if (content.type === 'text') {
          try {
            let jsonStr = content.text.trim()
            if (jsonStr.startsWith('```')) {
              jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
            }
            const parsed = JSON.parse(jsonStr)

            supportingEvidence = (parsed.supporting_evidence || []).map((e: { source_index: number; excerpt: string; strength: number }) => ({
              source_id: sources[e.source_index - 1]?.id,
              source_title: sources[e.source_index - 1]?.title,
              excerpt: e.excerpt,
              strength: e.strength
            }))

            contradictingEvidence = (parsed.contradicting_evidence || []).map((e: { source_index: number; excerpt: string; strength: number }) => ({
              source_id: sources[e.source_index - 1]?.id,
              source_title: sources[e.source_index - 1]?.title,
              excerpt: e.excerpt,
              strength: e.strength
            }))

            confidence = parsed.overall_confidence
          } catch {
            // Continue without evaluation
          }
        }
      }
    }

    const { data: hypothesis, error } = await supabase
      .from('hypotheses')
      .insert({
        workspace_id,
        document_id,
        statement,
        rationale,
        status: 'proposed',
        confidence,
        supporting_evidence: supportingEvidence,
        contradicting_evidence: contradictingEvidence,
        created_by: user.id
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ hypothesis }, { status: 201 })
  } catch (error) {
    console.error('Create hypothesis error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/research/literature-review/[id]/screen/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

/**
 * POST /api/research/literature-review/[id]/screen - Screen sources against criteria
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: reviewId } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { source_id, decision, notes, auto_screen } = body

    // Get review with criteria
    const { data: review, error: reviewError } = await supabase
      .from('literature_reviews')
      .select('*')
      .eq('id', reviewId)
      .single()

    if (reviewError || !review) {
      return NextResponse.json({ error: 'Review not found' }, { status: 404 })
    }

    // Manual screening
    if (!auto_screen && source_id && decision) {
      const { data: screened, error } = await supabase
        .from('review_sources')
        .update({
          screening_decision: decision,
          screening_notes: notes,
          screened_by: user.id,
          screened_at: new Date().toISOString()
        })
        .eq('review_id', reviewId)
        .eq('source_id', source_id)
        .select()
        .single()

      if (error) {
        return NextResponse.json({ error: error.message }, { status: 500 })
      }

      // Update counts
      await updateReviewCounts(supabase, reviewId)

      return NextResponse.json({ source: screened })
    }

    // Auto-screening with AI
    if (auto_screen) {
      // Get pending sources
      const { data: pendingSources, error: sourcesError } = await supabase
        .from('review_sources')
        .select(`
          *,
          source:sources (id, title, abstract, authors, publication_year)
        `)
        .eq('review_id', reviewId)
        .eq('screening_decision', 'pending')
        .limit(10)

      if (sourcesError) {
        return NextResponse.json({ error: sourcesError.message }, { status: 500 })
      }

      if (!pendingSources || pendingSources.length === 0) {
        return NextResponse.json({ message: 'No pending sources to screen' })
      }

      const results = []

      for (const reviewSource of pendingSources) {
        const source = reviewSource.source as { title?: string; abstract?: string; authors?: string[]; publication_year?: number } | null
        if (!source) continue

        const response = await anthropic.messages.create({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 1000,
          messages: [{
            role: 'user',
            content: `Screen this source for a systematic literature review.

Research Question: ${review.research_question || 'Not specified'}

Inclusion Criteria:
${JSON.stringify(review.inclusion_criteria, null, 2)}

Exclusion Criteria:
${JSON.stringify(review.exclusion_criteria, null, 2)}

Source to Screen:
Title: ${source.title || 'Unknown'}
Authors: ${source.authors?.join(', ') || 'Unknown'}
Year: ${source.publication_year || 'Unknown'}
Abstract: ${source.abstract || 'No abstract available'}

Respond with JSON only:
{
  "decision": "include" | "exclude" | "maybe",
  "confidence": 0.0-1.0,
  "reasoning": "Brief explanation",
  "criteria_met": ["I1", "I2"],
  "criteria_failed": ["E1"]
}`
          }]
        })

        const content = response.content[0]
        if (content.type !== 'text') continue

        try {
          let jsonStr = content.text.trim()
          if (jsonStr.startsWith('```')) {
            jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
          }
          const parsed = JSON.parse(jsonStr)

          const { error: updateError } = await supabase
            .from('review_sources')
            .update({
              screening_decision: parsed.decision,
              screening_notes: `AI Screening (${(parsed.confidence * 100).toFixed(0)}% confidence): ${parsed.reasoning}\nCriteria met: ${parsed.criteria_met?.join(', ') || 'None'}\nCriteria failed: ${parsed.criteria_failed?.join(', ') || 'None'}`,
              screened_at: new Date().toISOString()
            })
            .eq('id', reviewSource.id)

          if (!updateError) {
            results.push({
              source_id: reviewSource.source_id,
              decision: parsed.decision,
              confidence: parsed.confidence,
              reasoning: parsed.reasoning
            })
          }
        } catch {
          // Skip sources that fail to parse
        }
      }

      // Update counts
      await updateReviewCounts(supabase, reviewId)

      return NextResponse.json({ screened: results, count: results.length })
    }

    return NextResponse.json({ error: 'Invalid request' }, { status: 400 })
  } catch (error) {
    console.error('Screen sources error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

async function updateReviewCounts(supabase: Awaited<ReturnType<typeof createClient>>, reviewId: string) {
  const { data: counts } = await supabase
    .from('review_sources')
    .select('screening_decision')
    .eq('review_id', reviewId)

  if (counts) {
    const screened = counts.filter(c => c.screening_decision !== 'pending').length
    const included = counts.filter(c => c.screening_decision === 'include').length
    const excluded = counts.filter(c => c.screening_decision === 'exclude').length

    await supabase
      .from('literature_reviews')
      .update({
        screened_count: screened,
        included_count: included,
        excluded_count: excluded,
        updated_at: new Date().toISOString()
      })
      .eq('id', reviewId)
  }
}
</file>

<file path="app/src/app/api/research/literature-review/[id]/sources/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/research/literature-review/[id]/sources - Get sources for a review
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: reviewId } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const decision = searchParams.get('decision')

    let query = supabase
      .from('review_sources')
      .select(`
        *,
        source:sources (*)
      `)
      .eq('review_id', reviewId)

    if (decision) {
      query = query.eq('screening_decision', decision)
    }

    const { data: sources, error } = await query.order('created_at', { ascending: false })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ sources })
  } catch (error) {
    console.error('List review sources error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/research/literature-review/[id]/sources - Add sources to a review
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: reviewId } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { source_ids } = body

    if (!source_ids || !Array.isArray(source_ids) || source_ids.length === 0) {
      return NextResponse.json({ error: 'source_ids array required' }, { status: 400 })
    }

    // Add sources to review
    const reviewSources = source_ids.map((source_id: string) => ({
      review_id: reviewId,
      source_id,
      screening_decision: 'pending'
    }))

    const { data: added, error } = await supabase
      .from('review_sources')
      .upsert(reviewSources, { onConflict: 'review_id,source_id' })
      .select()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    // Update review statistics
    const { count } = await supabase
      .from('review_sources')
      .select('*', { count: 'exact', head: true })
      .eq('review_id', reviewId)

    await supabase
      .from('literature_reviews')
      .update({ total_sources: count || 0, updated_at: new Date().toISOString() })
      .eq('id', reviewId)

    return NextResponse.json({ sources: added, total: count }, { status: 201 })
  } catch (error) {
    console.error('Add review sources error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/research/literature-review/[id]/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/research/literature-review/[id] - Get a literature review
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { data: review, error } = await supabase
      .from('literature_reviews')
      .select(`
        *,
        review_sources (
          id,
          source_id,
          screening_decision,
          screening_notes,
          quality_score,
          extracted_data,
          extraction_complete,
          source:sources (id, title, authors, publication_year)
        )
      `)
      .eq('id', id)
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 404 })
    }

    return NextResponse.json({ review })
  } catch (error) {
    console.error('Get review error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/research/literature-review/[id] - Update a literature review
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      title,
      description,
      research_question,
      current_stage,
      inclusion_criteria,
      exclusion_criteria,
      quality_criteria
    } = body

    const updates: Record<string, unknown> = { updated_at: new Date().toISOString() }
    if (title !== undefined) updates.title = title
    if (description !== undefined) updates.description = description
    if (research_question !== undefined) updates.research_question = research_question
    if (current_stage !== undefined) updates.current_stage = current_stage
    if (inclusion_criteria !== undefined) updates.inclusion_criteria = inclusion_criteria
    if (exclusion_criteria !== undefined) updates.exclusion_criteria = exclusion_criteria
    if (quality_criteria !== undefined) updates.quality_criteria = quality_criteria

    const { data: review, error } = await supabase
      .from('literature_reviews')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ review })
  } catch (error) {
    console.error('Update review error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/research/literature-review/[id] - Delete a literature review
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { error } = await supabase
      .from('literature_reviews')
      .delete()
      .eq('id', id)

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Delete review error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/research/literature-review/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

/**
 * GET /api/research/literature-review - List literature reviews
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    const { data: reviews, error } = await supabase
      .from('literature_reviews')
      .select('*')
      .eq('workspace_id', workspaceId)
      .order('created_at', { ascending: false })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ reviews })
  } catch (error) {
    console.error('List reviews error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/research/literature-review - Create a literature review
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { workspace_id, title, description, research_question, inclusion_criteria, exclusion_criteria } = body

    if (!workspace_id || !title) {
      return NextResponse.json({ error: 'workspace_id and title required' }, { status: 400 })
    }

    // Generate PRISMA-compliant criteria if not provided
    let generatedCriteria = { inclusion: inclusion_criteria, exclusion: exclusion_criteria }

    if (research_question && (!inclusion_criteria || !exclusion_criteria)) {
      const response = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1500,
        messages: [{
          role: 'user',
          content: `Generate inclusion and exclusion criteria for a systematic literature review.

Research Question: ${research_question}

Provide PRISMA-compliant criteria in JSON:
{
  "inclusion_criteria": [
    {"id": "I1", "category": "Population/Topic", "criterion": "..."},
    {"id": "I2", "category": "Study Type", "criterion": "..."}
  ],
  "exclusion_criteria": [
    {"id": "E1", "category": "Language", "criterion": "..."},
    {"id": "E2", "category": "Quality", "criterion": "..."}
  ]
}

Only return valid JSON.`
        }]
      })

      const content = response.content[0]
      if (content.type === 'text') {
        try {
          let jsonStr = content.text.trim()
          if (jsonStr.startsWith('```')) jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
          const parsed = JSON.parse(jsonStr)
          generatedCriteria = {
            inclusion: parsed.inclusion_criteria || [],
            exclusion: parsed.exclusion_criteria || []
          }
        } catch {
          // Use defaults
        }
      }
    }

    const { data: review, error } = await supabase
      .from('literature_reviews')
      .insert({
        workspace_id,
        title,
        description,
        research_question,
        inclusion_criteria: generatedCriteria.inclusion || [],
        exclusion_criteria: generatedCriteria.exclusion || [],
        created_by: user.id,
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ review }, { status: 201 })
  } catch (error) {
    console.error('Create review error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/research/templates/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/research/templates - List research templates
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const templateType = searchParams.get('type')
    const includePublic = searchParams.get('include_public') !== 'false'

    let query = supabase
      .from('research_templates')
      .select('*')

    if (workspaceId) {
      if (includePublic) {
        query = query.or(`workspace_id.eq.${workspaceId},is_public.eq.true`)
      } else {
        query = query.eq('workspace_id', workspaceId)
      }
    } else if (includePublic) {
      query = query.eq('is_public', true)
    }

    if (templateType) {
      query = query.eq('template_type', templateType)
    }

    const { data: templates, error } = await query.order('use_count', { ascending: false })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ templates })
  } catch (error) {
    console.error('List templates error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/research/templates - Create a research template
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      workspace_id,
      name,
      description,
      template_type,
      structure,
      default_content,
      ai_prompts,
      is_public
    } = body

    if (!name || !template_type || !structure) {
      return NextResponse.json({ error: 'name, template_type, and structure required' }, { status: 400 })
    }

    const { data: template, error } = await supabase
      .from('research_templates')
      .insert({
        workspace_id,
        name,
        description,
        template_type,
        structure,
        default_content: default_content || {},
        ai_prompts: ai_prompts || {},
        is_public: is_public || false,
        created_by: user.id
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ template }, { status: 201 })
  } catch (error) {
    console.error('Create template error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/research/writing/[id]/feedback/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

/**
 * GET /api/research/writing/[id]/feedback - Get feedback for a writing project
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: projectId } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const stage = searchParams.get('stage')
    const resolved = searchParams.get('resolved')

    let query = supabase
      .from('writing_feedback')
      .select('*')
      .eq('project_id', projectId)

    if (stage) {
      query = query.eq('stage', stage)
    }

    if (resolved !== null) {
      query = query.eq('resolved', resolved === 'true')
    }

    const { data: feedback, error } = await query.order('created_at', { ascending: false })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ feedback })
  } catch (error) {
    console.error('List feedback error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/research/writing/[id]/feedback - Add or generate feedback
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: projectId } = await params
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      stage,
      feedback_type,
      content,
      section_id,
      start_offset,
      end_offset,
      auto_generate,
      document_content
    } = body

    // Get project
    const { data: project, error: projectError } = await supabase
      .from('writing_projects')
      .select('*, document:documents (id, title, content)')
      .eq('id', projectId)
      .single()

    if (projectError || !project) {
      return NextResponse.json({ error: 'Project not found' }, { status: 404 })
    }

    const currentStage = stage || project.current_stage

    // Manual feedback
    if (!auto_generate && content) {
      const { data: feedback, error } = await supabase
        .from('writing_feedback')
        .insert({
          project_id: projectId,
          stage: currentStage,
          feedback_type: feedback_type || 'self_note',
          content,
          section_id,
          start_offset,
          end_offset,
          created_by: user.id
        })
        .select()
        .single()

      if (error) {
        return NextResponse.json({ error: error.message }, { status: 500 })
      }

      return NextResponse.json({ feedback }, { status: 201 })
    }

    // AI-generated feedback
    if (auto_generate) {
      const textContent = document_content ||
        (typeof project.document?.content === 'string'
          ? project.document.content
          : JSON.stringify(project.document?.content || ''))

      const stagePrompts: Record<string, string> = {
        draft: 'Focus on structure, argument flow, and completeness. Identify missing sections or weak arguments.',
        review: 'Focus on clarity, citation accuracy, and logical consistency. Identify claims that need better support.',
        revision: 'Focus on readability, conciseness, and polish. Suggest sentence-level improvements.',
        finalize: 'Focus on formatting, consistency, and final checks before submission.'
      }

      const response = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 3000,
        messages: [{
          role: 'user',
          content: `Provide detailed writing feedback for this academic document.

Stage: ${currentStage}
Focus: ${stagePrompts[currentStage] || 'General feedback'}

Target: ${project.target_journal || project.target_conference || 'Academic publication'}
Word count target: ${project.word_count_target || 'Not specified'}

Document content:
${textContent.substring(0, 15000)}

Respond with JSON only:
{
  "feedback_items": [
    {
      "type": "structure" | "clarity" | "citation" | "argument" | "style" | "formatting",
      "severity": "suggestion" | "warning" | "critical",
      "content": "Detailed feedback",
      "location": "Where in the document (section/paragraph description)",
      "suggestion": "Specific improvement recommendation"
    }
  ],
  "summary": {
    "strengths": ["List of strengths"],
    "areas_for_improvement": ["List of areas needing work"],
    "readiness_score": 0.0-1.0,
    "recommended_next_steps": ["Prioritized action items"]
  }
}`
        }]
      })

      const responseContent = response.content[0]
      if (responseContent.type !== 'text') {
        return NextResponse.json({ error: 'Failed to generate feedback' }, { status: 500 })
      }

      let jsonStr = responseContent.text.trim()
      if (jsonStr.startsWith('```')) {
        jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
      }

      const parsed = JSON.parse(jsonStr)
      const savedFeedback = []

      // Save each feedback item
      for (const item of parsed.feedback_items || []) {
        const { data: saved, error: saveError } = await supabase
          .from('writing_feedback')
          .insert({
            project_id: projectId,
            stage: currentStage,
            feedback_type: 'ai_suggestion',
            content: `[${item.type.toUpperCase()}] ${item.content}\n\nLocation: ${item.location}\n\nSuggestion: ${item.suggestion}`,
            created_by: user.id
          })
          .select()
          .single()

        if (!saveError && saved) {
          savedFeedback.push({ ...saved, severity: item.severity, type: item.type })
        }
      }

      return NextResponse.json({
        feedback: savedFeedback,
        summary: parsed.summary
      }, { status: 201 })
    }

    return NextResponse.json({ error: 'Invalid request' }, { status: 400 })
  } catch (error) {
    console.error('Create feedback error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/research/writing/[id]/feedback - Mark feedback as resolved
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    await params // projectId not needed
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { feedback_id, resolved } = body

    if (!feedback_id) {
      return NextResponse.json({ error: 'feedback_id required' }, { status: 400 })
    }

    const { data: feedback, error } = await supabase
      .from('writing_feedback')
      .update({
        resolved: resolved !== false,
        resolved_at: resolved !== false ? new Date().toISOString() : null
      })
      .eq('id', feedback_id)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ feedback })
  } catch (error) {
    console.error('Update feedback error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/research/writing/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/research/writing - List writing projects
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')
    const stage = searchParams.get('stage')

    if (!workspaceId) {
      return NextResponse.json({ error: 'workspace_id required' }, { status: 400 })
    }

    let query = supabase
      .from('writing_projects')
      .select(`
        *,
        document:documents (id, title)
      `)
      .eq('workspace_id', workspaceId)

    if (stage) {
      query = query.eq('current_stage', stage)
    }

    const { data: projects, error } = await query.order('created_at', { ascending: false })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ projects })
  } catch (error) {
    console.error('List writing projects error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/research/writing - Create a writing project
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const {
      workspace_id,
      document_id,
      title,
      target_journal,
      target_conference,
      deadline,
      word_count_target,
      checklist
    } = body

    if (!workspace_id || !document_id || !title) {
      return NextResponse.json({ error: 'workspace_id, document_id, and title required' }, { status: 400 })
    }

    // Default checklist for academic writing
    const defaultChecklist = checklist || [
      { id: '1', label: 'Abstract complete', category: 'Structure' },
      { id: '2', label: 'Introduction sets context', category: 'Structure' },
      { id: '3', label: 'Methods clearly described', category: 'Structure' },
      { id: '4', label: 'Results presented logically', category: 'Structure' },
      { id: '5', label: 'Discussion addresses implications', category: 'Structure' },
      { id: '6', label: 'All claims cited', category: 'Citations' },
      { id: '7', label: 'Citation style consistent', category: 'Citations' },
      { id: '8', label: 'Bibliography complete', category: 'Citations' },
      { id: '9', label: 'Grammar and spelling checked', category: 'Polish' },
      { id: '10', label: 'Formatting meets guidelines', category: 'Polish' }
    ]

    const { data: project, error } = await supabase
      .from('writing_projects')
      .insert({
        workspace_id,
        document_id,
        title,
        target_journal,
        target_conference,
        deadline,
        word_count_target,
        checklist: defaultChecklist,
        completed_items: [],
        current_stage: 'draft',
        created_by: user.id
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ project }, { status: 201 })
  } catch (error) {
    console.error('Create writing project error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/research/writing - Update a writing project
 */
export async function PATCH(request: NextRequest) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { project_id, ...updates } = body

    if (!project_id) {
      return NextResponse.json({ error: 'project_id required' }, { status: 400 })
    }

    updates.updated_at = new Date().toISOString()

    const { data: project, error } = await supabase
      .from('writing_projects')
      .update(updates)
      .eq('id', project_id)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ project })
  } catch (error) {
    console.error('Update writing project error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/safety/assess/route.ts">
import { createClient } from '@/lib/supabase/server'
import { getAnthropicClient } from '@/lib/anthropic'
import { NextRequest, NextResponse } from 'next/server'

export interface SafetyIssue {
  type: 'unsupported_claim' | 'outdated_reference' | 'unverifiable' | 'speculation' | 'overgeneralization' | 'missing_context'
  severity: 'high' | 'medium' | 'low'
  text: string
  suggestion: string
  location?: string
}

export interface SafetyAssessment {
  overallScore: number // 0-100
  riskLevel: 'low' | 'moderate' | 'high' | 'critical'
  issues: SafetyIssue[]
  summary: string
  recommendations: string[]
  stats: {
    totalClaims: number
    supportedClaims: number
    unsupportedClaims: number
    speculativeClaims: number
    citationsCoverage: number
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { content, documentId, projectId } = body

    if (!content || typeof content !== 'string') {
      return NextResponse.json({ error: 'Content is required' }, { status: 400 })
    }

    // Strip HTML tags
    const plainText = content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim()

    if (plainText.length < 100) {
      return NextResponse.json({
        assessment: {
          overallScore: 100,
          riskLevel: 'low',
          issues: [],
          summary: 'Document too short for meaningful assessment.',
          recommendations: ['Add more content for a thorough safety assessment.'],
          stats: {
            totalClaims: 0,
            supportedClaims: 0,
            unsupportedClaims: 0,
            speculativeClaims: 0,
            citationsCoverage: 0
          }
        }
      })
    }

    const anthropic = getAnthropicClient()

    if (!anthropic) {
      return NextResponse.json({
        error: 'Safety assessment requires ANTHROPIC_API_KEY to be configured.'
      }, { status: 500 })
    }

    // Get source count for context
    let sourcesCount = 0
    if (projectId) {
      const { count } = await supabase
        .from('sources')
        .select('*', { count: 'exact', head: true })
        .eq('project_id', projectId)
      sourcesCount = count || 0
    }

    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 4096,
      system: `You are an expert at assessing the reliability and safety of academic and research documents. Analyze documents for potential issues that could lead to misinformation or unreliable conclusions.

Identify issues such as:
- **unsupported_claim**: Assertions without evidence or citations
- **outdated_reference**: References to potentially outdated information
- **unverifiable**: Claims that cannot be independently verified
- **speculation**: Speculative statements presented as fact
- **overgeneralization**: Broad claims from limited evidence
- **missing_context**: Important context or caveats omitted

For each issue, assign severity:
- **high**: Could significantly mislead readers
- **medium**: May cause confusion or minor misunderstanding
- **low**: Minor issue, style improvement suggested

Calculate an overall safety score (0-100):
- 90-100: Very reliable, well-supported
- 70-89: Generally reliable with minor issues
- 50-69: Moderate concerns, needs improvement
- 30-49: Significant concerns
- 0-29: Critical issues, major revision needed

Respond with JSON:
{
  "overallScore": number,
  "riskLevel": "low|moderate|high|critical",
  "issues": [
    {
      "type": "unsupported_claim|outdated_reference|unverifiable|speculation|overgeneralization|missing_context",
      "severity": "high|medium|low",
      "text": "the problematic text excerpt",
      "suggestion": "how to fix it"
    }
  ],
  "summary": "2-3 sentence assessment summary",
  "recommendations": ["specific improvement suggestions"],
  "stats": {
    "totalClaims": number,
    "supportedClaims": number,
    "unsupportedClaims": number,
    "speculativeClaims": number,
    "citationsCoverage": percentage 0-100
  }
}

Be constructive and specific. Only output JSON.`,
      messages: [
        {
          role: 'user',
          content: `Assess the safety and reliability of this document:

${plainText.substring(0, 10000)}

${sourcesCount > 0 ? `Note: This project has ${sourcesCount} source documents uploaded for reference.` : 'Note: No source documents have been uploaded for this project.'}`
        }
      ]
    })

    const textContent = response.content.find(c => c.type === 'text')

    if (!textContent || textContent.type !== 'text') {
      return NextResponse.json({ error: 'No response from assessment' }, { status: 500 })
    }

    try {
      const assessment: SafetyAssessment = JSON.parse(textContent.text)

      // Store assessment in database
      if (documentId) {
        try {
          await supabase.from('doc_risk_assessments').insert({
            document_id: documentId,
            assessed_by: user.id,
            safety_score: assessment.overallScore,
            hallucination_flags: assessment.issues.filter(i =>
              i.type === 'unsupported_claim' || i.type === 'speculation'
            ).length,
            unsupported_claims: assessment.stats.unsupportedClaims,
            outdated_refs: assessment.issues.filter(i =>
              i.type === 'outdated_reference'
            ).length,
            details: assessment
          })
        } catch (dbError) {
          console.warn('Failed to store assessment:', dbError)
        }
      }

      return NextResponse.json({ assessment })

    } catch (parseError) {
      console.error('Error parsing safety assessment:', parseError)
      return NextResponse.json({
        error: 'Failed to parse assessment results'
      }, { status: 500 })
    }

  } catch (error) {
    console.error('Safety assessment error:', error)
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Internal server error'
    }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/search/saved/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/search/saved - List saved searches
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')

    let query = supabase
      .from('saved_searches')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false })

    if (workspaceId) {
      query = query.eq('workspace_id', workspaceId)
    }

    const { data: searches, error } = await query

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ searches })

  } catch (error) {
    console.error('List saved searches error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/search/saved - Save a search
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { name, query, workspace_id, filters, notify_on_new = false } = body

    if (!name || !query) {
      return NextResponse.json({ error: 'name and query required' }, { status: 400 })
    }

    const { data: search, error } = await supabase
      .from('saved_searches')
      .insert({
        user_id: user.id,
        workspace_id,
        name,
        query,
        filters: filters || {},
        notify_on_new,
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ search }, { status: 201 })

  } catch (error) {
    console.error('Save search error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/search/saved - Delete a saved search
 */
export async function DELETE(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const searchId = searchParams.get('id')

    if (!searchId) {
      return NextResponse.json({ error: 'id required' }, { status: 400 })
    }

    const { error } = await supabase
      .from('saved_searches')
      .delete()
      .eq('id', searchId)
      .eq('user_id', user.id)

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Delete saved search error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/search/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

interface SearchResult {
  id: string
  type: 'document' | 'source' | 'entity' | 'section' | 'claim'
  title: string
  excerpt: string
  workspace_id: string
  workspace_name?: string
  document_id?: string
  document_title?: string
  relevance: number
  created_at: string
  metadata?: Record<string, unknown>
}

/**
 * GET /api/search - Global search across all content
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const query = searchParams.get('q')
    const workspaceId = searchParams.get('workspace_id')
    const types = searchParams.get('types')?.split(',') || ['document', 'source', 'entity', 'section']
    const limit = parseInt(searchParams.get('limit') || '20')
    const offset = parseInt(searchParams.get('offset') || '0')

    if (!query || query.trim().length < 2) {
      return NextResponse.json({ error: 'Query must be at least 2 characters' }, { status: 400 })
    }

    const searchTerm = query.trim().toLowerCase()
    const results: SearchResult[] = []

    // Get user's accessible workspaces
    const { data: memberships } = await supabase
      .from('workspace_members')
      .select('workspace_id, workspace:workspaces(id, name)')
      .eq('user_id', user.id)

    const accessibleWorkspaces = memberships?.map(m => m.workspace_id) || []
    const workspaceNames = new Map<string, string>()
    memberships?.forEach(m => {
      const ws = m.workspace as unknown as { id: string; name: string } | null
      if (ws) workspaceNames.set(ws.id, ws.name)
    })

    if (accessibleWorkspaces.length === 0) {
      return NextResponse.json({ results: [], total: 0 })
    }

    // Filter by specific workspace if provided
    const targetWorkspaces = workspaceId
      ? accessibleWorkspaces.filter(id => id === workspaceId)
      : accessibleWorkspaces

    // Search documents
    if (types.includes('document')) {
      const { data: documents } = await supabase
        .from('documents')
        .select('id, title, created_at, workspace_id')
        .in('workspace_id', targetWorkspaces)
        .ilike('title', `%${searchTerm}%`)
        .order('created_at', { ascending: false })
        .limit(limit)

      documents?.forEach(doc => {
        results.push({
          id: doc.id,
          type: 'document',
          title: doc.title,
          excerpt: '',
          workspace_id: doc.workspace_id,
          workspace_name: workspaceNames.get(doc.workspace_id),
          relevance: doc.title.toLowerCase().includes(searchTerm) ? 1 : 0.5,
          created_at: doc.created_at,
        })
      })
    }

    // Search document sections (full-text)
    if (types.includes('section')) {
      const { data: sections } = await supabase
        .from('doc_sections')
        .select(`
          id,
          title,
          content_text,
          created_at,
          document:documents!inner(id, title, workspace_id)
        `)
        .or(`title.ilike.%${searchTerm}%,content_text.ilike.%${searchTerm}%`)
        .limit(limit)

      sections?.forEach(section => {
        const doc = section.document as unknown as { id: string; title: string; workspace_id: string } | null
        if (!doc || !targetWorkspaces.includes(doc.workspace_id)) return

        const contentText = section.content_text || ''
        const matchIndex = contentText.toLowerCase().indexOf(searchTerm)
        const excerpt = matchIndex >= 0
          ? '...' + contentText.slice(Math.max(0, matchIndex - 50), matchIndex + searchTerm.length + 100) + '...'
          : contentText.slice(0, 150) + '...'

        results.push({
          id: section.id,
          type: 'section',
          title: section.title || 'Untitled section',
          excerpt: excerpt.trim(),
          workspace_id: doc.workspace_id,
          workspace_name: workspaceNames.get(doc.workspace_id),
          document_id: doc.id,
          document_title: doc.title,
          relevance: contentText.toLowerCase().includes(searchTerm) ? 0.9 : 0.5,
          created_at: section.created_at,
        })
      })
    }

    // Search sources
    if (types.includes('source')) {
      const { data: sources } = await supabase
        .from('sources')
        .select('id, title, abstract, authors, created_at, workspace_id')
        .in('workspace_id', targetWorkspaces)
        .or(`title.ilike.%${searchTerm}%,abstract.ilike.%${searchTerm}%,authors.ilike.%${searchTerm}%`)
        .order('created_at', { ascending: false })
        .limit(limit)

      sources?.forEach(source => {
        results.push({
          id: source.id,
          type: 'source',
          title: source.title,
          excerpt: source.abstract?.slice(0, 200) || '',
          workspace_id: source.workspace_id,
          workspace_name: workspaceNames.get(source.workspace_id),
          relevance: source.title.toLowerCase().includes(searchTerm) ? 1 : 0.7,
          created_at: source.created_at,
          metadata: { authors: source.authors },
        })
      })
    }

    // Search knowledge entities
    if (types.includes('entity')) {
      const { data: entities } = await supabase
        .from('knowledge_entities')
        .select('id, name, entity_type, description, created_at, workspace_id')
        .in('workspace_id', targetWorkspaces)
        .or(`name.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`)
        .order('created_at', { ascending: false })
        .limit(limit)

      entities?.forEach(entity => {
        results.push({
          id: entity.id,
          type: 'entity',
          title: entity.name,
          excerpt: entity.description || `${entity.entity_type} entity`,
          workspace_id: entity.workspace_id,
          workspace_name: workspaceNames.get(entity.workspace_id),
          relevance: entity.name.toLowerCase().includes(searchTerm) ? 1 : 0.6,
          created_at: entity.created_at,
          metadata: { entity_type: entity.entity_type },
        })
      })
    }

    // Search claims specifically
    if (types.includes('claim')) {
      const { data: claims } = await supabase
        .from('knowledge_entities')
        .select('id, name, description, created_at, workspace_id')
        .in('workspace_id', targetWorkspaces)
        .eq('entity_type', 'claim')
        .or(`name.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`)
        .order('created_at', { ascending: false })
        .limit(limit)

      claims?.forEach(claim => {
        results.push({
          id: claim.id,
          type: 'claim',
          title: claim.name,
          excerpt: claim.description || '',
          workspace_id: claim.workspace_id,
          workspace_name: workspaceNames.get(claim.workspace_id),
          relevance: claim.name.toLowerCase().includes(searchTerm) ? 1 : 0.7,
          created_at: claim.created_at,
        })
      })
    }

    // Sort by relevance and apply pagination
    results.sort((a, b) => b.relevance - a.relevance)
    const paginatedResults = results.slice(offset, offset + limit)

    return NextResponse.json({
      results: paginatedResults,
      total: results.length,
      query,
      limit,
      offset,
    })

  } catch (error) {
    console.error('Search error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/sources/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const projectId = searchParams.get('projectId')

    // Build query
    let query = supabase
      .from('sources')
      .select('*')
      .order('created_at', { ascending: false })

    if (projectId) {
      query = query.eq('project_id', projectId)
    }

    const { data: sources, error } = await query

    if (error) {
      console.error('Database error:', error)
      return NextResponse.json({ error: 'Failed to fetch sources' }, { status: 500 })
    }

    // Add public URLs
    const sourcesWithUrls = sources?.map(source => {
      const { data: urlData } = supabase.storage
        .from('sources')
        .getPublicUrl(source.storage_path)

      return {
        ...source,
        url: urlData.publicUrl
      }
    }) || []

    return NextResponse.json({ sources: sourcesWithUrls })

  } catch (error) {
    console.error('Sources handler error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/workflows/execute/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

interface ExecuteWorkflowRequest {
  workflowId: string
  documentId?: string
  projectId?: string
  action: 'verify_citations' | 'extract_claims' | 'assess_safety' | 'generate_bibliography'
  parameters?: Record<string, unknown>
}

// POST - Execute a workflow
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body: ExecuteWorkflowRequest = await request.json()
    const { workflowId, documentId, projectId, action, parameters } = body

    if (!workflowId || !action) {
      return NextResponse.json(
        { error: 'Workflow ID and action are required' },
        { status: 400 }
      )
    }

    // Verify user has access to the document/project
    if (documentId) {
      const { data: doc, error: docError } = await supabase
        .from('documents')
        .select('id, user_id')
        .eq('id', documentId)
        .single()

      if (docError || !doc || doc.user_id !== user.id) {
        return NextResponse.json({ error: 'Document not found or access denied' }, { status: 403 })
      }
    }

    // Log workflow execution
    const executionId = crypto.randomUUID()

    await supabase.from('workflow_executions').insert({
      id: executionId,
      workflow_id: workflowId,
      document_id: documentId,
      project_id: projectId,
      action,
      parameters,
      status: 'queued',
      user_id: user.id,
      created_at: new Date().toISOString()
    })

    // Execute workflow based on action (inline execution for now)
    // In production, this would call the Supabase Edge Function
    let result: {
      success: boolean
      action: string
      results?: unknown
      error?: string
    }

    const startTime = Date.now()

    switch (action) {
      case 'verify_citations':
        result = await executeVerifyCitations(supabase, documentId)
        break

      case 'extract_claims':
        result = await executeExtractClaims(supabase, documentId)
        break

      case 'assess_safety':
        result = await executeAssessSafety(supabase, documentId)
        break

      case 'generate_bibliography':
        result = await executeGenerateBibliography(supabase, documentId, projectId, parameters)
        break

      default:
        result = { success: false, action, error: `Unknown action: ${action}` }
    }

    const executionTime = Date.now() - startTime

    // Update execution record
    await supabase.from('workflow_executions').update({
      status: result.success ? 'completed' : 'failed',
      results: result.results,
      error: result.error,
      execution_time_ms: executionTime,
      completed_at: new Date().toISOString()
    }).eq('id', executionId)

    return NextResponse.json({
      executionId,
      ...result,
      executionTime
    })

  } catch (error) {
    console.error('Workflow execution error:', error)
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Internal server error'
    }, { status: 500 })
  }
}

// Inline execution functions (simplified versions)
async function executeVerifyCitations(supabase: any, documentId?: string) {
  if (!documentId) {
    return { success: false, action: 'verify_citations', error: 'Document ID required' }
  }

  const { data: document } = await supabase
    .from('documents')
    .select('content')
    .eq('id', documentId)
    .single()

  if (!document) {
    return { success: false, action: 'verify_citations', error: 'Document not found' }
  }

  // Simple citation pattern matching
  const citationPattern = /\[([A-Za-z]+(?:\s+(?:et\s+al\.|&\s+[A-Za-z]+))?),?\s*(\d{4})\]/g
  const citations: string[] = []
  let match

  while ((match = citationPattern.exec(document.content || '')) !== null) {
    citations.push(`${match[1]}, ${match[2]}`)
  }

  return {
    success: true,
    action: 'verify_citations',
    results: {
      totalCitations: citations.length,
      citations: citations.map(c => ({ citation: c, status: 'pending_verification' }))
    }
  }
}

async function executeExtractClaims(supabase: any, documentId?: string) {
  if (!documentId) {
    return { success: false, action: 'extract_claims', error: 'Document ID required' }
  }

  const { data: document } = await supabase
    .from('documents')
    .select('content')
    .eq('id', documentId)
    .single()

  if (!document) {
    return { success: false, action: 'extract_claims', error: 'Document not found' }
  }

  const content = document.content || ''
  const sentences = content.split(/[.!?]+/).filter((s: string) => s.trim().length > 20)
  const claimMarkers = ['shows that', 'indicates', 'demonstrates', 'suggests', 'proves', 'confirms']

  const claims = sentences.filter((sentence: string) =>
    claimMarkers.some(marker => sentence.toLowerCase().includes(marker))
  ).slice(0, 10)

  return {
    success: true,
    action: 'extract_claims',
    results: {
      totalClaims: claims.length,
      claims: claims.map((claim: string, i: number) => ({
        id: i + 1,
        text: claim.trim(),
        needsCitation: true
      }))
    }
  }
}

async function executeAssessSafety(supabase: any, documentId?: string) {
  if (!documentId) {
    return { success: false, action: 'assess_safety', error: 'Document ID required' }
  }

  const { data: document } = await supabase
    .from('documents')
    .select('content')
    .eq('id', documentId)
    .single()

  if (!document) {
    return { success: false, action: 'assess_safety', error: 'Document not found' }
  }

  const content = document.content || ''

  return {
    success: true,
    action: 'assess_safety',
    results: {
      overallScore: 0.9,
      contentLength: content.length,
      assessment: {
        factualAccuracy: 'pending',
        sourceQuality: 'pending',
        biasIndicators: []
      }
    }
  }
}

async function executeGenerateBibliography(
  supabase: any,
  documentId?: string,
  projectId?: string,
  parameters?: Record<string, unknown>
) {
  const pid = projectId || (documentId ? (await supabase
    .from('documents')
    .select('project_id')
    .eq('id', documentId)
    .single()).data?.project_id : null)

  if (!pid) {
    return { success: false, action: 'generate_bibliography', error: 'Project ID required' }
  }

  const { data: sources } = await supabase
    .from('sources')
    .select('id, title, metadata')
    .eq('project_id', pid)

  const style = (parameters?.style as string) || 'apa'

  return {
    success: true,
    action: 'generate_bibliography',
    results: {
      style,
      totalEntries: (sources || []).length,
      entries: (sources || []).map((s: any, i: number) => ({
        number: i + 1,
        title: s.title,
        formatted: `${s.title}. (n.d.)`
      }))
    }
  }
}
</file>

<file path="app/src/app/api/workflows/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

export interface Workflow {
  id: string
  projectId: string
  workflowType: string
  name: string
  description: string
  schedule: string
  enabled: boolean
  lastRun?: string
  nextRun?: string
}

const AVAILABLE_WORKFLOWS = [
  {
    type: 'daily_index_refresh',
    name: 'Daily Index Refresh',
    description: 'Re-embed updated document sections to keep search fresh',
    schedule: 'daily',
    defaultEnabled: false
  },
  {
    type: 'weekly_exec_summary',
    name: 'Weekly Executive Summary',
    description: 'Generate a summary of project progress and key findings',
    schedule: 'weekly',
    defaultEnabled: false
  },
  {
    type: 'weekly_inconsistency_scan',
    name: 'Weekly Inconsistency Scan',
    description: 'Find contradictions and inconsistencies across documents',
    schedule: 'weekly',
    defaultEnabled: false
  },
  {
    type: 'weekly_citation_check',
    name: 'Weekly Citation Check',
    description: 'Verify all citations are still supported by sources',
    schedule: 'weekly',
    defaultEnabled: false
  },
  {
    type: 'weekly_risk_assessment',
    name: 'Weekly Risk Assessment',
    description: 'Update safety scores for all documents',
    schedule: 'weekly',
    defaultEnabled: false
  }
]

// GET - List workflows for a project
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const projectId = request.nextUrl.searchParams.get('projectId')

    if (!projectId) {
      // Return available workflow types
      return NextResponse.json({ workflows: AVAILABLE_WORKFLOWS })
    }

    // Get project workflows from database
    const { data: workflows, error } = await supabase
      .from('workflows')
      .select('*')
      .eq('project_id', projectId)

    if (error) {
      console.error('Error fetching workflows:', error)
      // Return default workflows if table doesn't exist or error
      return NextResponse.json({
        workflows: AVAILABLE_WORKFLOWS.map(w => ({
          id: `${projectId}-${w.type}`,
          projectId,
          workflowType: w.type,
          name: w.name,
          description: w.description,
          schedule: w.schedule,
          enabled: w.defaultEnabled
        }))
      })
    }

    // Merge with available workflows to show all options
    const mergedWorkflows = AVAILABLE_WORKFLOWS.map(available => {
      const existing = workflows?.find(w => w.workflow_type === available.type)
      return {
        id: existing?.id || `${projectId}-${available.type}`,
        projectId,
        workflowType: available.type,
        name: available.name,
        description: available.description,
        schedule: available.schedule,
        enabled: existing?.enabled || false,
        lastRun: existing?.last_run_at,
        nextRun: existing?.next_run_at
      }
    })

    return NextResponse.json({ workflows: mergedWorkflows })

  } catch (error) {
    console.error('Workflows GET error:', error)
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Internal server error'
    }, { status: 500 })
  }
}

// POST - Create or update a workflow
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { projectId, workflowType, enabled } = body

    if (!projectId || !workflowType) {
      return NextResponse.json({
        error: 'projectId and workflowType are required'
      }, { status: 400 })
    }

    // Validate workflow type
    const workflowDef = AVAILABLE_WORKFLOWS.find(w => w.type === workflowType)
    if (!workflowDef) {
      return NextResponse.json({
        error: 'Invalid workflow type'
      }, { status: 400 })
    }

    // Upsert workflow
    const { data: workflow, error } = await supabase
      .from('workflows')
      .upsert({
        project_id: projectId,
        workflow_type: workflowType,
        enabled: enabled ?? false,
        schedule: workflowDef.schedule,
        config: {}
      }, {
        onConflict: 'project_id,workflow_type'
      })
      .select()
      .single()

    if (error) {
      console.error('Error upserting workflow:', error)
      // Return success anyway for demo purposes
      return NextResponse.json({
        workflow: {
          id: `${projectId}-${workflowType}`,
          projectId,
          workflowType,
          name: workflowDef.name,
          description: workflowDef.description,
          schedule: workflowDef.schedule,
          enabled: enabled ?? false
        }
      })
    }

    return NextResponse.json({
      workflow: {
        id: workflow.id,
        projectId: workflow.project_id,
        workflowType: workflow.workflow_type,
        name: workflowDef.name,
        description: workflowDef.description,
        schedule: workflow.schedule,
        enabled: workflow.enabled,
        lastRun: workflow.last_run_at,
        nextRun: workflow.next_run_at
      }
    })

  } catch (error) {
    console.error('Workflows POST error:', error)
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Internal server error'
    }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/workspaces/[id]/activity/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/workspaces/[id]/activity - Get workspace activity feed
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: workspaceId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', workspaceId)
      .eq('user_id', user.id)
      .single()

    if (!member) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    const { searchParams } = new URL(request.url)
    const limit = parseInt(searchParams.get('limit') || '50')
    const offset = parseInt(searchParams.get('offset') || '0')
    const targetType = searchParams.get('target_type')

    let query = supabase
      .from('activity_feed')
      .select('*', { count: 'exact' })
      .eq('workspace_id', workspaceId)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1)

    if (targetType) {
      query = query.eq('target_type', targetType)
    }

    const { data: activities, error, count } = await query

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({
      activities,
      total: count,
      limit,
      offset,
    })

  } catch (error) {
    console.error('Get activity error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/workspaces/[id]/activity - Record activity
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: workspaceId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', workspaceId)
      .eq('user_id', user.id)
      .single()

    if (!member) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    const body = await request.json()
    const { action, target_type, target_id, target_title, details } = body

    if (!action || !target_type) {
      return NextResponse.json({ error: 'action and target_type required' }, { status: 400 })
    }

    const { data: activity, error } = await supabase
      .from('activity_feed')
      .insert({
        workspace_id: workspaceId,
        user_id: user.id,
        action,
        target_type,
        target_id,
        target_title,
        details: details || {},
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ activity }, { status: 201 })

  } catch (error) {
    console.error('Record activity error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/workspaces/[id]/invitations/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/workspaces/[id]/invitations - List pending invitations
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check admin access
    const { data: membership } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', id)
      .eq('user_id', user.id)
      .single()

    if (!membership || !['owner', 'admin'].includes(membership.role)) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    // Get pending invitations
    const { data: invitations, error } = await supabase
      .from('workspace_invitations')
      .select(`
        id,
        email,
        role,
        invited_by,
        created_at,
        expires_at,
        accepted_at
      `)
      .eq('workspace_id', id)
      .is('accepted_at', null)
      .gt('expires_at', new Date().toISOString())
      .order('created_at', { ascending: false })

    if (error) {
      console.error('Error fetching invitations:', error)
      return NextResponse.json({ error: 'Failed to fetch invitations' }, { status: 500 })
    }

    return NextResponse.json({ invitations })

  } catch (error) {
    console.error('Get invitations error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/workspaces/[id]/invitations - Send invitation
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check admin access
    const { data: membership } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', id)
      .eq('user_id', user.id)
      .single()

    if (!membership || !['owner', 'admin'].includes(membership.role)) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    const body = await request.json()
    const { email, role } = body

    if (!email || !role) {
      return NextResponse.json({ error: 'Email and role are required' }, { status: 400 })
    }

    const validRoles = ['admin', 'editor', 'reviewer', 'viewer']
    if (!validRoles.includes(role)) {
      return NextResponse.json({ error: 'Invalid role' }, { status: 400 })
    }

    // Check if user is already a member
    const { data: existingMember } = await supabase
      .from('workspace_members')
      .select('user_id')
      .eq('workspace_id', id)
      .eq('user_id', (
        await supabase
          .from('user_profiles')
          .select('id')
          .eq('id', user.id) // This won't work - need to check by email
      ))

    // Check if already invited
    const { data: existingInvite } = await supabase
      .from('workspace_invitations')
      .select('id')
      .eq('workspace_id', id)
      .eq('email', email.toLowerCase())
      .is('accepted_at', null)
      .gt('expires_at', new Date().toISOString())
      .single()

    if (existingInvite) {
      return NextResponse.json({ error: 'Invitation already pending' }, { status: 409 })
    }

    // Create invitation
    const { data: invitation, error: inviteError } = await supabase
      .from('workspace_invitations')
      .insert({
        workspace_id: id,
        email: email.toLowerCase(),
        role,
        invited_by: user.id,
      })
      .select()
      .single()

    if (inviteError) {
      console.error('Error creating invitation:', inviteError)
      if (inviteError.code === '23505') {
        return NextResponse.json({ error: 'User already invited' }, { status: 409 })
      }
      return NextResponse.json({ error: 'Failed to create invitation' }, { status: 500 })
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_action: 'workspace.invite_send',
      p_workspace_id: id,
      p_target_type: 'invitation',
      p_target_id: invitation.id,
      p_details: { email: email.toLowerCase(), role },
    })

    // TODO: Send invitation email
    // For now, return the invitation token (in production, this would be sent via email)

    return NextResponse.json({
      invitation: {
        id: invitation.id,
        email: invitation.email,
        role: invitation.role,
        expires_at: invitation.expires_at,
        // Only include token in development/for testing
        invite_url: `${process.env.NEXT_PUBLIC_APP_URL || ''}/invite/${invitation.token}`,
      }
    }, { status: 201 })

  } catch (error) {
    console.error('Create invitation error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/workspaces/[id]/invitations?invitation_id=... - Revoke invitation
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check admin access
    const { data: membership } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', id)
      .eq('user_id', user.id)
      .single()

    if (!membership || !['owner', 'admin'].includes(membership.role)) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    const { searchParams } = new URL(request.url)
    const invitationId = searchParams.get('invitation_id')

    if (!invitationId) {
      return NextResponse.json({ error: 'invitation_id is required' }, { status: 400 })
    }

    const { error: deleteError } = await supabase
      .from('workspace_invitations')
      .delete()
      .eq('id', invitationId)
      .eq('workspace_id', id)

    if (deleteError) {
      console.error('Error revoking invitation:', deleteError)
      return NextResponse.json({ error: 'Failed to revoke invitation' }, { status: 500 })
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_action: 'workspace.invite_revoke',
      p_workspace_id: id,
      p_target_type: 'invitation',
      p_target_id: invitationId,
      p_details: {},
    })

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Revoke invitation error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/workspaces/[id]/members/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/workspaces/[id]/members - List workspace members
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check membership
    const { data: membership } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', id)
      .eq('user_id', user.id)
      .single()

    if (!membership) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    // Get all members with user profiles
    const { data: members, error } = await supabase
      .from('workspace_members')
      .select(`
        user_id,
        role,
        invited_at,
        joined_at,
        user_profiles (
          display_name,
          avatar_url
        )
      `)
      .eq('workspace_id', id)
      .order('joined_at', { ascending: true })

    if (error) {
      console.error('Error fetching members:', error)
      return NextResponse.json({ error: 'Failed to fetch members' }, { status: 500 })
    }

    // Get user emails from auth (only for admins)
    let memberEmails: Record<string, string> = {}
    if (['owner', 'admin'].includes(membership.role)) {
      // Get emails via service role (would need separate endpoint or edge function)
      // For now, we'll just return what we have
    }

    const result = members.map(m => {
      const profile = Array.isArray(m.user_profiles) ? m.user_profiles[0] : m.user_profiles
      return {
        user_id: m.user_id,
        role: m.role,
        invited_at: m.invited_at,
        joined_at: m.joined_at,
        display_name: profile?.display_name,
        avatar_url: profile?.avatar_url,
        email: memberEmails[m.user_id],
      }
    })

    return NextResponse.json({ members: result })

  } catch (error) {
    console.error('Get members error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/workspaces/[id]/members - Update member role
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check admin access
    const { data: membership } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', id)
      .eq('user_id', user.id)
      .single()

    if (!membership || !['owner', 'admin'].includes(membership.role)) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    const body = await request.json()
    const { user_id, role } = body

    if (!user_id || !role) {
      return NextResponse.json({ error: 'user_id and role are required' }, { status: 400 })
    }

    const validRoles = ['admin', 'editor', 'reviewer', 'viewer']
    if (!validRoles.includes(role)) {
      return NextResponse.json({ error: 'Invalid role' }, { status: 400 })
    }

    // Can't change owner's role
    const { data: workspace } = await supabase
      .from('workspaces')
      .select('owner_id')
      .eq('id', id)
      .single()

    if (workspace?.owner_id === user_id) {
      return NextResponse.json({ error: "Cannot change owner's role" }, { status: 400 })
    }

    // Admins can't promote to owner
    if (membership.role === 'admin' && role === 'owner') {
      return NextResponse.json({ error: 'Only owner can transfer ownership' }, { status: 403 })
    }

    const { error: updateError } = await supabase
      .from('workspace_members')
      .update({ role })
      .eq('workspace_id', id)
      .eq('user_id', user_id)

    if (updateError) {
      console.error('Update member error:', updateError)
      return NextResponse.json({ error: 'Failed to update member' }, { status: 500 })
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_action: 'workspace.member_role_change',
      p_workspace_id: id,
      p_target_type: 'member',
      p_target_id: user_id,
      p_details: { new_role: role },
    })

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Update member error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/workspaces/[id]/members - Remove member
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const targetUserId = searchParams.get('user_id')

    if (!targetUserId) {
      return NextResponse.json({ error: 'user_id is required' }, { status: 400 })
    }

    // Users can remove themselves, admins can remove others
    const { data: membership } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', id)
      .eq('user_id', user.id)
      .single()

    if (!membership) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    const isSelf = targetUserId === user.id
    const isAdmin = ['owner', 'admin'].includes(membership.role)

    if (!isSelf && !isAdmin) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    // Can't remove the owner
    const { data: workspace } = await supabase
      .from('workspaces')
      .select('owner_id')
      .eq('id', id)
      .single()

    if (workspace?.owner_id === targetUserId) {
      return NextResponse.json({ error: 'Cannot remove workspace owner' }, { status: 400 })
    }

    const { error: deleteError } = await supabase
      .from('workspace_members')
      .delete()
      .eq('workspace_id', id)
      .eq('user_id', targetUserId)

    if (deleteError) {
      console.error('Remove member error:', deleteError)
      return NextResponse.json({ error: 'Failed to remove member' }, { status: 500 })
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_action: 'workspace.member_remove',
      p_workspace_id: id,
      p_target_type: 'member',
      p_target_id: targetUserId,
      p_details: { removed_by: user.id, self_removal: isSelf },
    })

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Remove member error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/workspaces/[id]/summary/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

/**
 * GET /api/workspaces/[id]/summary - Get workspace summary (latest or by period)
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: workspaceId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Verify workspace access
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', workspaceId)
      .eq('user_id', user.id)
      .single()

    if (!member) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    const { searchParams } = new URL(request.url)
    const summaryType = searchParams.get('type') || 'weekly'

    // Get latest summary of this type
    const { data: summary } = await supabase
      .from('workspace_summaries')
      .select('*')
      .eq('workspace_id', workspaceId)
      .eq('summary_type', summaryType)
      .order('period_end', { ascending: false })
      .limit(1)
      .single()

    if (summary) {
      return NextResponse.json({ summary })
    }

    return NextResponse.json({ summary: null, message: 'No summary available yet' })

  } catch (error) {
    console.error('Get summary error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/workspaces/[id]/summary - Generate workspace summary
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: workspaceId } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Verify workspace access (admin/owner only)
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', workspaceId)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin'].includes(member.role)) {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    const body = await request.json()
    const { summary_type = 'weekly', days = 7 } = body

    const periodEnd = new Date()
    const periodStart = new Date()
    periodStart.setDate(periodStart.getDate() - days)

    // Gather workspace data for the period
    const { data: workspace } = await supabase
      .from('workspaces')
      .select('name')
      .eq('id', workspaceId)
      .single()

    // New documents
    const { data: newDocs, count: docCount } = await supabase
      .from('documents')
      .select('id, title', { count: 'exact' })
      .eq('workspace_id', workspaceId)
      .gte('created_at', periodStart.toISOString())
      .limit(20)

    // New sources
    const { data: newSources, count: sourceCount } = await supabase
      .from('sources')
      .select('id, title', { count: 'exact' })
      .eq('workspace_id', workspaceId)
      .gte('created_at', periodStart.toISOString())
      .limit(20)

    // New entities
    const { data: newEntities, count: entityCount } = await supabase
      .from('knowledge_entities')
      .select('id, name, entity_type', { count: 'exact' })
      .eq('workspace_id', workspaceId)
      .gte('created_at', periodStart.toISOString())
      .limit(30)

    // Contradictions
    const { data: contradictions, count: contradictionCount } = await supabase
      .from('contradictions')
      .select('id, description, severity', { count: 'exact' })
      .eq('workspace_id', workspaceId)
      .gte('created_at', periodStart.toISOString())

    // Active users
    const { data: activeMembers } = await supabase
      .from('workspace_members')
      .select('user_id')
      .eq('workspace_id', workspaceId)

    // Recent claims/findings
    const { data: recentClaims } = await supabase
      .from('knowledge_entities')
      .select('name, description')
      .eq('workspace_id', workspaceId)
      .in('entity_type', ['claim', 'finding'])
      .gte('created_at', periodStart.toISOString())
      .limit(10)

    // Build context for AI summary
    const documentsContext = newDocs?.map(d => `- ${d.title}`).join('\n') || 'None'
    const sourcesContext = newSources?.map(s => `- ${s.title}`).join('\n') || 'None'
    const entitiesContext = newEntities?.map(e => `- ${e.name} (${e.entity_type})`).join('\n') || 'None'
    const claimsContext = recentClaims?.map(c => `- ${c.name}: ${c.description || 'No description'}`).join('\n') || 'None'
    const contradictionsContext = contradictions?.map(c => `- [${c.severity}] ${c.description}`).join('\n') || 'None'

    // Generate AI summary
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      messages: [
        {
          role: 'user',
          content: `Generate a research workspace summary for the past ${days} days.

Workspace: ${workspace?.name || 'Research Workspace'}

NEW DOCUMENTS (${docCount || 0}):
${documentsContext}

NEW SOURCES (${sourceCount || 0}):
${sourcesContext}

NEW KNOWLEDGE ENTITIES (${entityCount || 0}):
${entitiesContext}

RECENT CLAIMS & FINDINGS:
${claimsContext}

NEW CONTRADICTIONS (${contradictionCount || 0}):
${contradictionsContext}

Provide a JSON response:
{
  "summary_text": "Executive summary paragraph (2-4 sentences)",
  "key_findings": ["List of key findings/progress points"],
  "trends": ["Notable trends or patterns observed"],
  "recommendations": ["Suggested next steps or areas to focus on"],
  "highlights": {
    "most_significant_document": "Title if any",
    "emerging_themes": ["Themes appearing across documents"],
    "attention_needed": ["Areas that may need attention"]
  }
}

Only return valid JSON.`,
        },
      ],
    })

    const aiContent = response.content[0]
    if (aiContent.type !== 'text') {
      throw new Error('Unexpected response format')
    }

    let aiSummary
    try {
      let jsonStr = aiContent.text.trim()
      if (jsonStr.startsWith('```')) jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '')
      aiSummary = JSON.parse(jsonStr)
    } catch {
      aiSummary = {
        summary_text: `This week saw ${docCount || 0} new documents, ${sourceCount || 0} sources, and ${entityCount || 0} knowledge entities added to the workspace.`,
        key_findings: [],
        trends: [],
        recommendations: [],
      }
    }

    // Store summary
    const { data: summary, error } = await supabase
      .from('workspace_summaries')
      .insert({
        workspace_id: workspaceId,
        summary_type,
        period_start: periodStart.toISOString(),
        period_end: periodEnd.toISOString(),
        summary_text: aiSummary.summary_text,
        key_findings: aiSummary.key_findings || [],
        new_documents: docCount || 0,
        new_sources: sourceCount || 0,
        new_entities: entityCount || 0,
        new_contradictions: contradictionCount || 0,
        active_users: activeMembers?.map(m => m.user_id) || [],
        trends: aiSummary.trends || [],
        recommendations: aiSummary.recommendations || [],
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ summary, ai_analysis: aiSummary }, { status: 201 })

  } catch (error) {
    console.error('Generate summary error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="app/src/components/arguments/ArgumentPanel.tsx">
'use client'

import { useState } from 'react'

interface Claim {
  id: string
  type: 'claim' | 'assumption' | 'definition' | 'evidence'
  text: string
  confidence: number
}

interface ClaimLink {
  sourceId: string
  targetId: string
  relationship: 'supports' | 'contradicts' | 'depends_on' | 'refines' | 'exemplifies'
  strength: number
}

interface ClaimGraph {
  claims: Claim[]
  links: ClaimLink[]
  summary: string
}

interface ArgumentPanelProps {
  documentContent: string
  documentId?: string
  isOpen: boolean
  onClose: () => void
}

export function ArgumentPanel({ documentContent, documentId, isOpen, onClose }: ArgumentPanelProps) {
  const [graph, setGraph] = useState<ClaimGraph | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [selectedClaim, setSelectedClaim] = useState<string | null>(null)

  const extractClaims = async () => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/claims/extract', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: documentContent,
          documentId
        })
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to extract claims')
      }

      setGraph(data.graph)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to analyze document')
    } finally {
      setLoading(false)
    }
  }

  const getTypeIcon = (type: string) => {
    switch (type) {
      case 'claim': return 'üí°'
      case 'assumption': return 'ü§î'
      case 'definition': return 'üìñ'
      case 'evidence': return 'üìä'
      default: return '‚Ä¢'
    }
  }

  const getTypeColor = (type: string) => {
    switch (type) {
      case 'claim': return 'border-blue-500 bg-blue-50 dark:bg-blue-900/20'
      case 'assumption': return 'border-yellow-500 bg-yellow-50 dark:bg-yellow-900/20'
      case 'definition': return 'border-purple-500 bg-purple-50 dark:bg-purple-900/20'
      case 'evidence': return 'border-green-500 bg-green-50 dark:bg-green-900/20'
      default: return 'border-gray-300 bg-gray-50 dark:bg-gray-800'
    }
  }

  const getRelationshipColor = (rel: string) => {
    switch (rel) {
      case 'supports': return 'text-green-600 dark:text-green-400'
      case 'contradicts': return 'text-red-600 dark:text-red-400'
      case 'depends_on': return 'text-blue-600 dark:text-blue-400'
      case 'refines': return 'text-purple-600 dark:text-purple-400'
      case 'exemplifies': return 'text-orange-600 dark:text-orange-400'
      default: return 'text-gray-600 dark:text-gray-400'
    }
  }

  const getRelationshipArrow = (rel: string) => {
    switch (rel) {
      case 'supports': return '‚Üí'
      case 'contradicts': return '‚äó'
      case 'depends_on': return '‚ü∂'
      case 'refines': return '‚Üù'
      case 'exemplifies': return '‚âà'
      default: return '‚Üí'
    }
  }

  // Get links for selected claim
  const selectedLinks = graph?.links.filter(
    link => link.sourceId === selectedClaim || link.targetId === selectedClaim
  ) || []

  if (!isOpen) return null

  return (
    <div className="fixed inset-y-0 right-0 w-[480px] bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-gray-700 shadow-xl z-50 flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-2">
          <svg className="w-5 h-5 text-orange-600 dark:text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
          </svg>
          <h2 className="font-semibold text-gray-900 dark:text-white">Argument Structure</h2>
        </div>
        <button
          onClick={onClose}
          className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {/* Action Bar */}
      <div className="px-4 py-3 bg-gray-50 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <button
          onClick={extractClaims}
          disabled={loading}
          className="w-full px-4 py-2 text-sm font-medium text-white bg-orange-600 hover:bg-orange-700 rounded-lg disabled:opacity-50 flex items-center justify-center gap-2"
        >
          {loading ? (
            <>
              <svg className="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
              </svg>
              Analyzing...
            </>
          ) : (
            <>
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
              </svg>
              Extract Claims & Arguments
            </>
          )}
        </button>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto p-4">
        {error && (
          <div className="p-3 mb-4 text-sm text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900/20 rounded-lg">
            {error}
          </div>
        )}

        {!graph && !loading && !error && (
          <div className="text-center py-8">
            <svg className="w-12 h-12 mx-auto text-gray-300 dark:text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
            </svg>
            <p className="mt-3 text-sm text-gray-500 dark:text-gray-400">
              Analyze your document to extract claims and arguments
            </p>
            <p className="mt-1 text-xs text-gray-400 dark:text-gray-500">
              AI will identify claims, assumptions, evidence, and their relationships
            </p>
          </div>
        )}

        {graph && (
          <div className="space-y-4">
            {/* Summary */}
            <div className="p-3 bg-orange-50 dark:bg-orange-900/20 rounded-lg">
              <p className="text-sm text-gray-700 dark:text-gray-300">
                {graph.summary}
              </p>
            </div>

            {/* Stats */}
            <div className="flex gap-2 text-xs">
              <span className="px-2 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded">
                {graph.claims.filter(c => c.type === 'claim').length} claims
              </span>
              <span className="px-2 py-1 bg-yellow-100 dark:bg-yellow-900/30 text-yellow-700 dark:text-yellow-300 rounded">
                {graph.claims.filter(c => c.type === 'assumption').length} assumptions
              </span>
              <span className="px-2 py-1 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300 rounded">
                {graph.claims.filter(c => c.type === 'evidence').length} evidence
              </span>
              <span className="px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded">
                {graph.links.length} links
              </span>
            </div>

            {/* Claims List */}
            <div className="space-y-2">
              <h3 className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                Extracted Elements
              </h3>
              {graph.claims.map((claim) => (
                <div
                  key={claim.id}
                  onClick={() => setSelectedClaim(selectedClaim === claim.id ? null : claim.id)}
                  className={`p-3 border-l-4 rounded-r-lg cursor-pointer transition-all ${getTypeColor(claim.type)} ${
                    selectedClaim === claim.id ? 'ring-2 ring-orange-500' : ''
                  }`}
                >
                  <div className="flex items-start gap-2">
                    <span className="text-lg">{getTypeIcon(claim.type)}</span>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2 mb-1">
                        <span className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">
                          {claim.type}
                        </span>
                        <span className="text-xs text-gray-400">
                          {Math.round(claim.confidence * 100)}% confidence
                        </span>
                      </div>
                      <p className="text-sm text-gray-700 dark:text-gray-300">
                        {claim.text}
                      </p>
                    </div>
                  </div>

                  {/* Show relationships when selected */}
                  {selectedClaim === claim.id && selectedLinks.length > 0 && (
                    <div className="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700 space-y-2">
                      <div className="text-xs font-medium text-gray-500 dark:text-gray-400">
                        Relationships:
                      </div>
                      {selectedLinks.map((link, i) => {
                        const isSource = link.sourceId === claim.id
                        const otherId = isSource ? link.targetId : link.sourceId
                        const otherClaim = graph.claims.find(c => c.id === otherId)

                        return (
                          <div key={i} className={`text-xs ${getRelationshipColor(link.relationship)}`}>
                            {isSource ? (
                              <>
                                {getRelationshipArrow(link.relationship)} {link.relationship} &ldquo;{otherClaim?.text.substring(0, 50)}...&rdquo;
                              </>
                            ) : (
                              <>
                                ‚Üê {link.relationship} by &ldquo;{otherClaim?.text.substring(0, 50)}...&rdquo;
                              </>
                            )}
                          </div>
                        )
                      })}
                    </div>
                  )}
                </div>
              ))}
            </div>

            {/* Legend */}
            <div className="pt-4 border-t border-gray-200 dark:border-gray-700">
              <h3 className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-2">
                Legend
              </h3>
              <div className="grid grid-cols-2 gap-2 text-xs">
                <div className="flex items-center gap-1">
                  <span className="text-green-600">‚Üí</span> supports
                </div>
                <div className="flex items-center gap-1">
                  <span className="text-red-600">‚äó</span> contradicts
                </div>
                <div className="flex items-center gap-1">
                  <span className="text-blue-600">‚ü∂</span> depends on
                </div>
                <div className="flex items-center gap-1">
                  <span className="text-purple-600">‚Üù</span> refines
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/ask/AskProject.tsx">
'use client'

import { useState, useRef, useEffect } from 'react'

interface RelevantChunk {
  id: string
  content: string
  source_id: string
  source_title: string
  similarity: number
}

interface AskResponse {
  query: string
  chunks: RelevantChunk[]
  answer: string
  sources_count: number
  message?: string
}

interface AskProjectProps {
  projectId?: string
  isOpen: boolean
  onClose: () => void
}

export function AskProject({ projectId, isOpen, onClose }: AskProjectProps) {
  const [query, setQuery] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [response, setResponse] = useState<AskResponse | null>(null)
  const [error, setError] = useState<string | null>(null)
  const [history, setHistory] = useState<AskResponse[]>([])
  const inputRef = useRef<HTMLInputElement>(null)
  const resultsRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    if (isOpen && inputRef.current) {
      inputRef.current.focus()
    }
  }, [isOpen])

  useEffect(() => {
    if (response && resultsRef.current) {
      resultsRef.current.scrollTop = 0
    }
  }, [response])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!query.trim() || isLoading) return

    setIsLoading(true)
    setError(null)

    try {
      const res = await fetch('/api/ask', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: query.trim(),
          projectId,
          topK: 5
        })
      })

      if (!res.ok) {
        const data = await res.json()
        throw new Error(data.error || 'Failed to search')
      }

      const data: AskResponse = await res.json()
      setResponse(data)
      setHistory(prev => [data, ...prev.slice(0, 9)]) // Keep last 10
      setQuery('')
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Something went wrong')
    } finally {
      setIsLoading(false)
    }
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-y-0 right-0 w-96 bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-gray-700 shadow-xl z-50 flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-2">
          <svg className="w-5 h-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <h2 className="font-semibold text-gray-900 dark:text-white">Ask Project</h2>
        </div>
        <button
          onClick={onClose}
          className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {/* Search Form */}
      <form onSubmit={handleSubmit} className="p-4 border-b border-gray-200 dark:border-gray-700">
        <div className="relative">
          <input
            ref={inputRef}
            type="text"
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            placeholder="Ask a question about your sources..."
            className="w-full px-4 py-2 pr-10 text-sm border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            disabled={isLoading}
          />
          <button
            type="submit"
            disabled={isLoading || !query.trim()}
            className="absolute right-2 top-1/2 -translate-y-1/2 p-1 text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isLoading ? (
              <svg className="w-5 h-5 animate-spin" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
              </svg>
            ) : (
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
            )}
          </button>
        </div>
      </form>

      {/* Results */}
      <div ref={resultsRef} className="flex-1 overflow-y-auto p-4">
        {error && (
          <div className="p-3 mb-4 text-sm text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900/20 rounded-lg">
            {error}
          </div>
        )}

        {response?.message && (
          <div className="p-3 mb-4 text-sm text-amber-600 dark:text-amber-400 bg-amber-50 dark:bg-amber-900/20 rounded-lg">
            {response.message}
          </div>
        )}

        {response && !response.message && (
          <div className="space-y-4">
            {/* Answer Summary */}
            <div className="p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <svg className="w-4 h-4 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span className="text-sm font-medium text-blue-700 dark:text-blue-300">
                  Found {response.sources_count} relevant source{response.sources_count !== 1 ? 's' : ''}
                </span>
              </div>
              <p className="text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap">
                {response.answer}
              </p>
            </div>

            {/* Source Chunks */}
            {response.chunks.length > 0 && (
              <div className="space-y-3">
                <h3 className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Relevant Passages
                </h3>
                {response.chunks.map((chunk, index) => (
                  <div
                    key={chunk.id}
                    className="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700"
                  >
                    <div className="flex items-center justify-between mb-2">
                      <span className="text-xs font-medium text-blue-600 dark:text-blue-400">
                        [{index + 1}] {chunk.source_title}
                      </span>
                      <span className="text-xs text-gray-400">
                        {Math.round(chunk.similarity * 100)}% match
                      </span>
                    </div>
                    <p className="text-sm text-gray-600 dark:text-gray-300 line-clamp-4">
                      {chunk.content}
                    </p>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        {/* Empty State */}
        {!response && !error && (
          <div className="text-center py-8">
            <svg className="w-12 h-12 mx-auto text-gray-300 dark:text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <p className="mt-3 text-sm text-gray-500 dark:text-gray-400">
              Ask questions about your uploaded sources
            </p>
            <p className="mt-1 text-xs text-gray-400 dark:text-gray-500">
              Semantic search powered by Voyage AI
            </p>
          </div>
        )}

        {/* Query History */}
        {history.length > 1 && (
          <div className="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700">
            <h3 className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-2">
              Recent Queries
            </h3>
            <div className="space-y-1">
              {history.slice(1).map((item, index) => (
                <button
                  key={index}
                  onClick={() => {
                    setQuery(item.query)
                    setResponse(item)
                  }}
                  className="w-full text-left px-2 py-1.5 text-sm text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800 rounded truncate"
                >
                  {item.query}
                </button>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/citations/CitationExportPanel.tsx">
'use client'

import { useState } from 'react'
import {
  Citation,
  CitationStyle,
  CITATION_STYLES,
  formatCitation,
  exportCitations,
  exportBibTeX
} from '@/lib/citations'

interface CitationExportPanelProps {
  citations: Citation[]
  isOpen: boolean
  onClose: () => void
}

export function CitationExportPanel({ citations, isOpen, onClose }: CitationExportPanelProps) {
  const [selectedStyle, setSelectedStyle] = useState<CitationStyle>('apa')
  const [exportFormat, setExportFormat] = useState<'text' | 'bibtex'>('text')
  const [copied, setCopied] = useState(false)

  if (!isOpen) return null

  const formattedCitations = citations.map(c => ({
    ...c,
    formatted: formatCitation(c, selectedStyle)
  }))

  const exportText = exportFormat === 'bibtex'
    ? exportBibTeX(citations)
    : exportCitations(citations, selectedStyle)

  const handleCopy = async () => {
    await navigator.clipboard.writeText(exportText)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  const handleDownload = () => {
    const blob = new Blob([exportText], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = exportFormat === 'bibtex' ? 'citations.bib' : 'citations.txt'
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Backdrop */}
      <div
        className="absolute inset-0 bg-black/50 backdrop-blur-sm"
        onClick={onClose}
      />

      {/* Modal */}
      <div className="relative bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-2xl w-full mx-4 overflow-hidden max-h-[80vh] flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200 dark:border-gray-700">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
            Export Citations
          </h2>
          <button
            onClick={onClose}
            className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Style Selection */}
        <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700 space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Citation Style
            </label>
            <div className="flex flex-wrap gap-2">
              {(Object.keys(CITATION_STYLES) as CitationStyle[]).map(style => (
                <button
                  key={style}
                  onClick={() => setSelectedStyle(style)}
                  className={`px-3 py-1.5 text-sm rounded-lg transition-colors ${
                    selectedStyle === style
                      ? 'bg-indigo-600 text-white'
                      : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                  }`}
                >
                  {style.toUpperCase()}
                </button>
              ))}
            </div>
            <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
              {CITATION_STYLES[selectedStyle]}
            </p>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Export Format
            </label>
            <div className="flex gap-2">
              <button
                onClick={() => setExportFormat('text')}
                className={`px-3 py-1.5 text-sm rounded-lg transition-colors ${
                  exportFormat === 'text'
                    ? 'bg-indigo-600 text-white'
                    : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                }`}
              >
                Plain Text
              </button>
              <button
                onClick={() => setExportFormat('bibtex')}
                className={`px-3 py-1.5 text-sm rounded-lg transition-colors ${
                  exportFormat === 'bibtex'
                    ? 'bg-indigo-600 text-white'
                    : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                }`}
              >
                BibTeX
              </button>
            </div>
          </div>
        </div>

        {/* Preview */}
        <div className="flex-1 overflow-y-auto p-6">
          <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
            Preview ({citations.length} citation{citations.length !== 1 ? 's' : ''})
          </h3>

          {citations.length === 0 ? (
            <div className="text-center py-8 text-gray-500 dark:text-gray-400">
              <svg className="w-12 h-12 mx-auto mb-3 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
              </svg>
              <p>No citations to export</p>
              <p className="text-sm mt-1">Add citations from your sources first</p>
            </div>
          ) : (
            <div className="bg-gray-50 dark:bg-gray-900 rounded-lg p-4">
              <pre className="text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap font-mono">
                {exportText}
              </pre>
            </div>
          )}
        </div>

        {/* Actions */}
        <div className="px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex justify-between">
          <button
            onClick={handleCopy}
            disabled={citations.length === 0}
            className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-colors"
          >
            {copied ? (
              <>
                <svg className="w-4 h-4 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                </svg>
                Copied!
              </>
            ) : (
              <>
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
                Copy to Clipboard
              </>
            )}
          </button>

          <button
            onClick={handleDownload}
            disabled={citations.length === 0}
            className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 disabled:opacity-50 transition-colors"
          >
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
            </svg>
            Download
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/citations/CitationPanel.tsx">
'use client'

import { useState, useEffect } from 'react'
import { createClient } from '@/lib/supabase/client'

interface Citation {
  id: string
  text: string
  sourceId: string
  sourceTitle: string
  pageNumber?: number
  verification?: {
    status: 'pending' | 'supported' | 'contradicted' | 'partial' | 'unverifiable'
    confidence: number
    explanation: string
  }
}

interface CitationPanelProps {
  citations: Citation[]
  documentId?: string
  isOpen: boolean
  onClose: () => void
  onVerify: (citation: Citation) => void
  onJumpTo: (citation: Citation) => void
}

export function CitationPanel({
  citations,
  documentId,
  isOpen,
  onClose,
  onVerify,
  onJumpTo
}: CitationPanelProps) {
  const [verifying, setVerifying] = useState<string | null>(null)
  const [localCitations, setLocalCitations] = useState<Citation[]>(citations)

  useEffect(() => {
    setLocalCitations(citations)
  }, [citations])

  const handleVerify = async (citation: Citation) => {
    setVerifying(citation.id)

    try {
      const response = await fetch('/api/citations/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          citedText: citation.text,
          sourceId: citation.sourceId,
          documentId
        })
      })

      const data = await response.json()

      if (response.ok && data.verification) {
        // Update local state
        setLocalCitations(prev =>
          prev.map(c =>
            c.id === citation.id
              ? { ...c, verification: data.verification }
              : c
          )
        )
        onVerify({ ...citation, verification: data.verification })
      }
    } catch (error) {
      console.error('Verification error:', error)
    } finally {
      setVerifying(null)
    }
  }

  const handleVerifyAll = async () => {
    for (const citation of localCitations) {
      if (!citation.verification || citation.verification.status === 'pending') {
        await handleVerify(citation)
      }
    }
  }

  const getStatusIcon = (status?: string) => {
    switch (status) {
      case 'supported':
        return <span className="text-green-500">‚úì</span>
      case 'contradicted':
        return <span className="text-red-500">‚úó</span>
      case 'partial':
        return <span className="text-yellow-500">‚óê</span>
      case 'unverifiable':
        return <span className="text-gray-400">?</span>
      default:
        return <span className="text-gray-300">‚óã</span>
    }
  }

  const getStatusBadge = (status?: string) => {
    switch (status) {
      case 'supported':
        return 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-400'
      case 'contradicted':
        return 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-400'
      case 'partial':
        return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-400'
      case 'unverifiable':
        return 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
      default:
        return 'bg-gray-100 text-gray-500 dark:bg-gray-700 dark:text-gray-400'
    }
  }

  // Stats
  const stats = {
    total: localCitations.length,
    verified: localCitations.filter(c => c.verification && c.verification.status !== 'pending').length,
    supported: localCitations.filter(c => c.verification?.status === 'supported').length,
    contradicted: localCitations.filter(c => c.verification?.status === 'contradicted').length
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-y-0 right-0 w-96 bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-gray-700 shadow-xl z-50 flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-2">
          <svg className="w-5 h-5 text-purple-600 dark:text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
          <h2 className="font-semibold text-gray-900 dark:text-white">Citations</h2>
          <span className="text-sm text-gray-500 dark:text-gray-400">
            ({stats.total})
          </span>
        </div>
        <button
          onClick={onClose}
          className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {/* Stats Bar */}
      {localCitations.length > 0 && (
        <div className="px-4 py-2 bg-gray-50 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center justify-between text-sm">
            <div className="flex items-center gap-3">
              <span className="text-gray-500 dark:text-gray-400">
                {stats.verified}/{stats.total} verified
              </span>
              {stats.supported > 0 && (
                <span className="text-green-600 dark:text-green-400">
                  {stats.supported} ‚úì
                </span>
              )}
              {stats.contradicted > 0 && (
                <span className="text-red-600 dark:text-red-400">
                  {stats.contradicted} ‚úó
                </span>
              )}
            </div>
            <button
              onClick={handleVerifyAll}
              disabled={verifying !== null}
              className="text-blue-600 dark:text-blue-400 hover:underline disabled:opacity-50"
            >
              Verify All
            </button>
          </div>
        </div>
      )}

      {/* Citation List */}
      <div className="flex-1 overflow-y-auto p-4">
        {localCitations.length === 0 ? (
          <div className="text-center py-8">
            <svg className="w-12 h-12 mx-auto text-gray-300 dark:text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
            <p className="mt-3 text-sm text-gray-500 dark:text-gray-400">
              No citations in this document
            </p>
            <p className="mt-1 text-xs text-gray-400 dark:text-gray-500">
              Select text and click the citation button to add citations
            </p>
          </div>
        ) : (
          <div className="space-y-3">
            {localCitations.map((citation) => (
              <div
                key={citation.id}
                className="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700"
              >
                <div className="flex items-start gap-2 mb-2">
                  <span className="text-lg">{getStatusIcon(citation.verification?.status)}</span>
                  <div className="flex-1 min-w-0">
                    <p className="text-sm text-gray-700 dark:text-gray-300 line-clamp-2">
                      &ldquo;{citation.text}&rdquo;
                    </p>
                  </div>
                </div>

                <div className="flex items-center gap-2 text-xs text-gray-500 dark:text-gray-400 mb-2">
                  <span className="truncate">{citation.sourceTitle}</span>
                  {citation.pageNumber && (
                    <span>p. {citation.pageNumber}</span>
                  )}
                </div>

                {citation.verification && citation.verification.status !== 'pending' && (
                  <div className="mb-2">
                    <span className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${getStatusBadge(citation.verification.status)}`}>
                      {citation.verification.status}
                      {citation.verification.confidence > 0 && (
                        <span className="ml-1 opacity-75">
                          ({Math.round(citation.verification.confidence * 100)}%)
                        </span>
                      )}
                    </span>
                    {citation.verification.explanation && (
                      <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
                        {citation.verification.explanation}
                      </p>
                    )}
                  </div>
                )}

                <div className="flex items-center gap-2">
                  <button
                    onClick={() => onJumpTo(citation)}
                    className="text-xs text-blue-600 dark:text-blue-400 hover:underline"
                  >
                    Jump to
                  </button>
                  <button
                    onClick={() => handleVerify(citation)}
                    disabled={verifying === citation.id}
                    className="text-xs text-purple-600 dark:text-purple-400 hover:underline disabled:opacity-50"
                  >
                    {verifying === citation.id ? 'Verifying...' : 'Verify'}
                  </button>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/collaboration/CollaborativeEditor.tsx">
'use client'

import { useEffect, useMemo } from 'react'
import { useEditor, EditorContent, Editor } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import Placeholder from '@tiptap/extension-placeholder'
import Collaboration from '@tiptap/extension-collaboration'
import CollaborationCursor from '@tiptap/extension-collaboration-cursor'
import * as Y from 'yjs'
import { WebsocketProvider } from 'y-websocket'

interface User {
  id: string
  name: string
  color: string
}

interface CollaborativeEditorProps {
  ydoc: Y.Doc
  provider: WebsocketProvider
  user: User
  placeholder?: string
  className?: string
  onUpdate?: (editor: Editor) => void
  editable?: boolean
}

export function CollaborativeEditor({
  ydoc,
  provider,
  user,
  placeholder = 'Start writing...',
  className = '',
  onUpdate,
  editable = true
}: CollaborativeEditorProps) {
  const editor = useEditor({
    extensions: [
      StarterKit,
      Placeholder.configure({
        placeholder,
        showOnlyWhenEditable: true,
      }),
      Collaboration.configure({
        document: ydoc,
      }),
      CollaborationCursor.configure({
        provider,
        user: {
          name: user.name,
          color: user.color,
        },
      }),
    ],
    editable,
    editorProps: {
      attributes: {
        class: 'prose prose-sm sm:prose lg:prose-lg dark:prose-invert max-w-none focus:outline-none min-h-[300px] px-4 py-3',
      },
    },
    onUpdate: ({ editor }) => {
      onUpdate?.(editor as Editor)
    },
  }, [ydoc, provider])

  // Update user in cursor extension when it changes
  useEffect(() => {
    if (editor) {
      editor.chain().focus().updateUser({
        name: user.name,
        color: user.color,
      }).run()
    }
  }, [editor, user.name, user.color])

  // Cleanup
  useEffect(() => {
    return () => {
      editor?.destroy()
    }
  }, [editor])

  return (
    <div className={`collaborative-editor ${className}`}>
      <EditorContent editor={editor} />

      {/* Collaboration cursor styles */}
      <style jsx global>{`
        .collaboration-cursor__caret {
          border-left: 1px solid currentColor;
          border-right: 1px solid currentColor;
          margin-left: -1px;
          margin-right: -1px;
          pointer-events: none;
          position: relative;
          word-break: normal;
        }

        .collaboration-cursor__label {
          border-radius: 3px 3px 3px 0;
          color: white;
          font-size: 12px;
          font-weight: 600;
          left: -1px;
          line-height: normal;
          padding: 0.1rem 0.3rem;
          position: absolute;
          top: -1.4em;
          user-select: none;
          white-space: nowrap;
        }

        .ProseMirror p.is-editor-empty:first-child::before {
          color: #adb5bd;
          content: attr(data-placeholder);
          float: left;
          height: 0;
          pointer-events: none;
        }
      `}</style>
    </div>
  )
}
</file>

<file path="app/src/components/collaboration/CollaboratorPresence.tsx">
'use client'

interface Collaborator {
  user: {
    id: string
    name: string
    color: string
    email?: string
  }
  lastActive: number
}

interface CollaboratorPresenceProps {
  collaborators: Collaborator[]
  connectionStatus: 'connecting' | 'connected' | 'disconnected'
  maxVisible?: number
}

export function CollaboratorPresence({
  collaborators,
  connectionStatus,
  maxVisible = 5
}: CollaboratorPresenceProps) {
  const visibleCollaborators = collaborators.slice(0, maxVisible)
  const hiddenCount = Math.max(0, collaborators.length - maxVisible)

  return (
    <div className="flex items-center gap-2">
      {/* Connection Status */}
      <div className="flex items-center gap-1.5">
        <div
          className={`w-2 h-2 rounded-full ${
            connectionStatus === 'connected'
              ? 'bg-green-500'
              : connectionStatus === 'connecting'
              ? 'bg-yellow-500 animate-pulse'
              : 'bg-red-500'
          }`}
        />
        <span className="text-xs text-gray-500 dark:text-gray-400 hidden sm:inline">
          {connectionStatus === 'connected'
            ? 'Live'
            : connectionStatus === 'connecting'
            ? 'Connecting...'
            : 'Offline'}
        </span>
      </div>

      {/* Collaborator Avatars */}
      {collaborators.length > 0 && (
        <>
          <div className="w-px h-5 bg-gray-200 dark:bg-gray-700 mx-1" />

          <div className="flex items-center -space-x-2">
            {visibleCollaborators.map((collab) => (
              <div
                key={collab.user.id}
                className="relative group"
                title={collab.user.name}
              >
                {/* Avatar */}
                <div
                  className="w-7 h-7 rounded-full flex items-center justify-center text-white text-xs font-medium ring-2 ring-white dark:ring-gray-800"
                  style={{ backgroundColor: collab.user.color }}
                >
                  {collab.user.name.charAt(0).toUpperCase()}
                </div>

                {/* Tooltip */}
                <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-gray-900 text-white text-xs rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">
                  {collab.user.name}
                  {collab.user.email && (
                    <span className="text-gray-400 ml-1">({collab.user.email})</span>
                  )}
                </div>
              </div>
            ))}

            {/* Hidden count */}
            {hiddenCount > 0 && (
              <div className="w-7 h-7 rounded-full bg-gray-200 dark:bg-gray-700 flex items-center justify-center text-xs font-medium text-gray-600 dark:text-gray-300 ring-2 ring-white dark:ring-gray-800">
                +{hiddenCount}
              </div>
            )}
          </div>
        </>
      )}
    </div>
  )
}
</file>

<file path="app/src/components/diff/SemanticDiffPanel.tsx">
'use client'

import { useState } from 'react'

interface SemanticChange {
  type: 'added' | 'removed' | 'modified' | 'strengthened' | 'weakened'
  category: 'claim' | 'argument' | 'evidence' | 'structure' | 'tone'
  description: string
  importance: 'high' | 'medium' | 'low'
  beforeText?: string
  afterText?: string
}

interface SemanticDiff {
  changes: SemanticChange[]
  summary: string
  overallAssessment: string
  claimsAdded: number
  claimsRemoved: number
  claimsModified: number
}

interface SemanticDiffPanelProps {
  beforeContent: string
  afterContent: string
  documentId?: string
  branchA?: string
  branchB?: string
  isOpen: boolean
  onClose: () => void
}

export function SemanticDiffPanel({
  beforeContent,
  afterContent,
  documentId,
  branchA = 'Previous',
  branchB = 'Current',
  isOpen,
  onClose
}: SemanticDiffPanelProps) {
  const [diff, setDiff] = useState<SemanticDiff | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [expandedChange, setExpandedChange] = useState<number | null>(null)

  const computeDiff = async () => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/diff/semantic', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          beforeContent,
          afterContent,
          documentId,
          branchA,
          branchB
        })
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to compute diff')
      }

      setDiff(data.diff)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to analyze changes')
    } finally {
      setLoading(false)
    }
  }

  const getTypeIcon = (type: string) => {
    switch (type) {
      case 'added': return '‚ûï'
      case 'removed': return '‚ûñ'
      case 'modified': return '‚úèÔ∏è'
      case 'strengthened': return 'üí™'
      case 'weakened': return 'üìâ'
      default: return '‚Ä¢'
    }
  }

  const getTypeColor = (type: string) => {
    switch (type) {
      case 'added': return 'border-green-500 bg-green-50 dark:bg-green-900/20'
      case 'removed': return 'border-red-500 bg-red-50 dark:bg-red-900/20'
      case 'modified': return 'border-blue-500 bg-blue-50 dark:bg-blue-900/20'
      case 'strengthened': return 'border-purple-500 bg-purple-50 dark:bg-purple-900/20'
      case 'weakened': return 'border-yellow-500 bg-yellow-50 dark:bg-yellow-900/20'
      default: return 'border-gray-300 bg-gray-50 dark:bg-gray-800'
    }
  }

  const getImportanceBadge = (importance: string) => {
    switch (importance) {
      case 'high': return 'bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400'
      case 'medium': return 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-400'
      case 'low': return 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
      default: return 'bg-gray-100 text-gray-600'
    }
  }

  const getCategoryIcon = (category: string) => {
    switch (category) {
      case 'claim': return 'üí°'
      case 'argument': return 'üîó'
      case 'evidence': return 'üìä'
      case 'structure': return 'üìã'
      case 'tone': return 'üé≠'
      default: return '‚Ä¢'
    }
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-y-0 right-0 w-[480px] bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-gray-700 shadow-xl z-50 flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-2">
          <svg className="w-5 h-5 text-indigo-600 dark:text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
          </svg>
          <h2 className="font-semibold text-gray-900 dark:text-white">Semantic Diff</h2>
        </div>
        <button
          onClick={onClose}
          className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {/* Branch Info */}
      <div className="px-4 py-2 bg-gray-50 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between text-sm">
        <div className="flex items-center gap-2">
          <span className="text-red-600 dark:text-red-400">‚óè {branchA}</span>
          <span className="text-gray-400">‚Üí</span>
          <span className="text-green-600 dark:text-green-400">‚óè {branchB}</span>
        </div>
        <button
          onClick={computeDiff}
          disabled={loading}
          className="px-3 py-1 text-xs font-medium text-white bg-indigo-600 hover:bg-indigo-700 rounded disabled:opacity-50"
        >
          {loading ? 'Analyzing...' : 'Compare'}
        </button>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto p-4">
        {error && (
          <div className="p-3 mb-4 text-sm text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900/20 rounded-lg">
            {error}
          </div>
        )}

        {!diff && !loading && !error && (
          <div className="text-center py-8">
            <svg className="w-12 h-12 mx-auto text-gray-300 dark:text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
            </svg>
            <p className="mt-3 text-sm text-gray-500 dark:text-gray-400">
              Compare versions to see semantic changes
            </p>
            <p className="mt-1 text-xs text-gray-400 dark:text-gray-500">
              AI analyzes changes in claims, arguments, and meaning
            </p>
          </div>
        )}

        {loading && (
          <div className="flex items-center justify-center py-12">
            <svg className="w-8 h-8 animate-spin text-indigo-600" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
            </svg>
          </div>
        )}

        {diff && (
          <div className="space-y-4">
            {/* Summary */}
            <div className="p-3 bg-indigo-50 dark:bg-indigo-900/20 rounded-lg">
              <p className="text-sm text-gray-700 dark:text-gray-300 mb-2">
                {diff.summary}
              </p>
              <p className="text-xs text-gray-500 dark:text-gray-400 italic">
                {diff.overallAssessment}
              </p>
            </div>

            {/* Stats */}
            <div className="flex gap-2 text-xs">
              <span className="px-2 py-1 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300 rounded">
                +{diff.claimsAdded} added
              </span>
              <span className="px-2 py-1 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300 rounded">
                -{diff.claimsRemoved} removed
              </span>
              <span className="px-2 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded">
                ~{diff.claimsModified} modified
              </span>
            </div>

            {/* Changes List */}
            {diff.changes.length > 0 ? (
              <div className="space-y-2">
                <h3 className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Changes ({diff.changes.length})
                </h3>
                {diff.changes.map((change, index) => (
                  <div
                    key={index}
                    className={`p-3 border-l-4 rounded-r-lg cursor-pointer transition-all ${getTypeColor(change.type)}`}
                    onClick={() => setExpandedChange(expandedChange === index ? null : index)}
                  >
                    <div className="flex items-start gap-2">
                      <span className="text-lg">{getTypeIcon(change.type)}</span>
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1">
                          <span className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">
                            {change.type}
                          </span>
                          <span className="text-xs">{getCategoryIcon(change.category)} {change.category}</span>
                          <span className={`text-xs px-1.5 py-0.5 rounded ${getImportanceBadge(change.importance)}`}>
                            {change.importance}
                          </span>
                        </div>
                        <p className="text-sm text-gray-700 dark:text-gray-300">
                          {change.description}
                        </p>

                        {/* Expanded details */}
                        {expandedChange === index && (change.beforeText || change.afterText) && (
                          <div className="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700 space-y-2 text-xs">
                            {change.beforeText && (
                              <div>
                                <span className="font-medium text-red-600 dark:text-red-400">Before:</span>
                                <p className="mt-1 text-gray-600 dark:text-gray-400 italic">
                                  &ldquo;{change.beforeText}&rdquo;
                                </p>
                              </div>
                            )}
                            {change.afterText && (
                              <div>
                                <span className="font-medium text-green-600 dark:text-green-400">After:</span>
                                <p className="mt-1 text-gray-600 dark:text-gray-400 italic">
                                  &ldquo;{change.afterText}&rdquo;
                                </p>
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center py-4 text-sm text-gray-500">
                No significant semantic changes detected.
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/editor/extensions/SlashCommand.tsx">
'use client'

import { Extension } from '@tiptap/core'
import { ReactRenderer } from '@tiptap/react'
import Suggestion, { SuggestionProps, SuggestionKeyDownProps } from '@tiptap/suggestion'
import tippy, { Instance as TippyInstance } from 'tippy.js'
import { forwardRef, useEffect, useImperativeHandle, useState, useCallback } from 'react'

export interface CommandItem {
  title: string
  description: string
  icon: string
  action: string
}

const SLASH_COMMANDS: CommandItem[] = [
  {
    title: 'Summarize',
    description: 'Condense the selected text',
    icon: 'üìù',
    action: 'summarize'
  },
  {
    title: 'Rewrite',
    description: 'Improve clarity and flow',
    icon: '‚úèÔ∏è',
    action: 'rewrite'
  },
  {
    title: 'Expand',
    description: 'Add more detail and depth',
    icon: 'üìñ',
    action: 'expand'
  },
  {
    title: 'Shorten',
    description: 'Make it more concise',
    icon: '‚úÇÔ∏è',
    action: 'shorten'
  },
  {
    title: 'Define',
    description: 'Explain key terms',
    icon: 'üìö',
    action: 'define'
  },
  {
    title: 'Humanize',
    description: 'Make it sound natural',
    icon: 'üë§',
    action: 'humanize'
  },
  {
    title: 'Continue',
    description: 'Continue writing from here',
    icon: '‚û°Ô∏è',
    action: 'continue'
  }
]

interface CommandListRef {
  onKeyDown: (props: SuggestionKeyDownProps) => boolean
}

interface CommandListProps {
  items: CommandItem[]
  command: (item: CommandItem) => void
}

const CommandList = forwardRef<CommandListRef, CommandListProps>(
  ({ items, command }, ref) => {
    const [selectedIndex, setSelectedIndex] = useState(0)

    const selectItem = useCallback((index: number) => {
      const item = items[index]
      if (item) {
        command(item)
      }
    }, [items, command])

    useImperativeHandle(ref, () => ({
      onKeyDown: ({ event }: SuggestionKeyDownProps) => {
        if (event.key === 'ArrowUp') {
          setSelectedIndex((selectedIndex + items.length - 1) % items.length)
          return true
        }

        if (event.key === 'ArrowDown') {
          setSelectedIndex((selectedIndex + 1) % items.length)
          return true
        }

        if (event.key === 'Enter') {
          selectItem(selectedIndex)
          return true
        }

        return false
      }
    }), [selectedIndex, items.length, selectItem])

    useEffect(() => {
      setSelectedIndex(0)
    }, [items])

    if (items.length === 0) {
      return null
    }

    return (
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 overflow-hidden min-w-[200px]">
        <div className="px-2 py-1.5 text-xs font-medium text-gray-500 dark:text-gray-400 border-b border-gray-200 dark:border-gray-700">
          AI Commands
        </div>
        {items.map((item, index) => (
          <button
            key={item.action}
            onClick={() => selectItem(index)}
            className={`w-full flex items-center gap-3 px-3 py-2 text-left transition-colors ${
              index === selectedIndex
                ? 'bg-blue-50 dark:bg-blue-900/30'
                : 'hover:bg-gray-50 dark:hover:bg-gray-700'
            }`}
          >
            <span className="text-lg">{item.icon}</span>
            <div className="flex-1 min-w-0">
              <div className="text-sm font-medium text-gray-900 dark:text-white">
                {item.title}
              </div>
              <div className="text-xs text-gray-500 dark:text-gray-400 truncate">
                {item.description}
              </div>
            </div>
          </button>
        ))}
      </div>
    )
  }
)

CommandList.displayName = 'CommandList'

export interface SlashCommandOptions {
  onCommand: (action: string, text: string) => void
}

export const SlashCommand = Extension.create<SlashCommandOptions>({
  name: 'slashCommand',

  addOptions() {
    return {
      onCommand: () => {}
    }
  },

  addProseMirrorPlugins() {
    return [
      Suggestion({
        editor: this.editor,
        char: '/',
        command: ({ editor, range, props }) => {
          // Delete the slash command
          editor.chain().focus().deleteRange(range).run()

          // Get selected text or current paragraph
          const { from, to } = editor.state.selection
          let text = ''

          if (from !== to) {
            // There's a selection
            text = editor.state.doc.textBetween(from, to, ' ')
          } else {
            // Get current paragraph/block content
            const $pos = editor.state.doc.resolve(from)
            const start = $pos.start()
            const end = $pos.end()
            text = editor.state.doc.textBetween(start, end, ' ')
          }

          // Call the onCommand handler with the action and text
          this.options.onCommand((props as CommandItem).action, text)
        },
        items: ({ query }) => {
          return SLASH_COMMANDS.filter(item =>
            item.title.toLowerCase().includes(query.toLowerCase()) ||
            item.action.toLowerCase().includes(query.toLowerCase())
          )
        },
        render: () => {
          let component: ReactRenderer<CommandListRef> | null = null
          let popup: TippyInstance[] | null = null

          return {
            onStart: (props: SuggestionProps) => {
              component = new ReactRenderer(CommandList, {
                props,
                editor: props.editor
              })

              if (!props.clientRect) {
                return
              }

              popup = tippy('body', {
                getReferenceClientRect: props.clientRect as () => DOMRect,
                appendTo: () => document.body,
                content: component.element,
                showOnCreate: true,
                interactive: true,
                trigger: 'manual',
                placement: 'bottom-start'
              })
            },

            onUpdate: (props: SuggestionProps) => {
              component?.updateProps(props)

              if (!props.clientRect) {
                return
              }

              popup?.[0]?.setProps({
                getReferenceClientRect: props.clientRect as () => DOMRect
              })
            },

            onKeyDown: (props: SuggestionKeyDownProps) => {
              if (props.event.key === 'Escape') {
                popup?.[0]?.hide()
                return true
              }

              return component?.ref?.onKeyDown(props) || false
            },

            onExit: () => {
              popup?.[0]?.destroy()
              component?.destroy()
            }
          }
        }
      })
    ]
  }
})
</file>

<file path="app/src/components/editor/CitationDialog.tsx">
'use client'

import { useState, useEffect } from 'react'
import { createClient } from '@/lib/supabase/client'

interface Source {
  id: string
  title: string
  source_type: string
  page_count: number | null
}

interface CitationDialogProps {
  isOpen: boolean
  onClose: () => void
  onInsert: (sourceId: string, pageNumber?: number) => void
  projectId?: string
}

export function CitationDialog({ isOpen, onClose, onInsert, projectId }: CitationDialogProps) {
  const [sources, setSources] = useState<Source[]>([])
  const [loading, setLoading] = useState(true)
  const [selectedSource, setSelectedSource] = useState<string | null>(null)
  const [pageNumber, setPageNumber] = useState<string>('')
  const [search, setSearch] = useState('')

  useEffect(() => {
    if (isOpen) {
      loadSources()
    }
  }, [isOpen, projectId])

  const loadSources = async () => {
    setLoading(true)
    const supabase = createClient()

    let query = supabase
      .from('sources')
      .select('id, title, source_type, page_count')
      .order('created_at', { ascending: false })

    if (projectId) {
      query = query.eq('project_id', projectId)
    }

    const { data, error } = await query

    if (error) {
      console.error('Error loading sources:', error)
    } else {
      setSources(data || [])
    }
    setLoading(false)
  }

  const handleInsert = () => {
    if (!selectedSource) return

    const page = pageNumber ? parseInt(pageNumber, 10) : undefined
    onInsert(selectedSource, page)
    handleClose()
  }

  const handleClose = () => {
    setSelectedSource(null)
    setPageNumber('')
    setSearch('')
    onClose()
  }

  const filteredSources = sources.filter(source =>
    source.title.toLowerCase().includes(search.toLowerCase())
  )

  const selectedSourceData = sources.find(s => s.id === selectedSource)

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Backdrop */}
      <div
        className="absolute inset-0 bg-black/50"
        onClick={handleClose}
      />

      {/* Dialog */}
      <div className="relative bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md mx-4 overflow-hidden">
        {/* Header */}
        <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
              Insert Citation
            </h2>
            <button
              onClick={handleClose}
              className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>

        {/* Content */}
        <div className="p-4">
          {/* Search */}
          <div className="mb-4">
            <input
              type="text"
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              placeholder="Search sources..."
              className="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          {/* Source List */}
          <div className="max-h-60 overflow-y-auto mb-4">
            {loading ? (
              <div className="text-center py-4 text-gray-500">Loading sources...</div>
            ) : filteredSources.length === 0 ? (
              <div className="text-center py-4 text-gray-500">
                {search ? 'No matching sources' : 'No sources available. Upload a PDF first.'}
              </div>
            ) : (
              <div className="space-y-1">
                {filteredSources.map((source) => (
                  <button
                    key={source.id}
                    onClick={() => setSelectedSource(source.id)}
                    className={`w-full text-left px-3 py-2 rounded-lg transition-colors ${
                      selectedSource === source.id
                        ? 'bg-blue-50 dark:bg-blue-900/30 border border-blue-500'
                        : 'hover:bg-gray-50 dark:hover:bg-gray-700 border border-transparent'
                    }`}
                  >
                    <div className="flex items-center gap-2">
                      <span className="text-sm">
                        {source.source_type === 'pdf' ? 'üìÑ' : 'üìù'}
                      </span>
                      <div className="flex-1 min-w-0">
                        <div className="text-sm font-medium text-gray-900 dark:text-white truncate">
                          {source.title}
                        </div>
                        {source.page_count && (
                          <div className="text-xs text-gray-500 dark:text-gray-400">
                            {source.page_count} pages
                          </div>
                        )}
                      </div>
                    </div>
                  </button>
                ))}
              </div>
            )}
          </div>

          {/* Page Number */}
          {selectedSource && (
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Page Number (optional)
              </label>
              <input
                type="number"
                value={pageNumber}
                onChange={(e) => setPageNumber(e.target.value)}
                placeholder={selectedSourceData?.page_count ? `1-${selectedSourceData.page_count}` : 'Page number'}
                min="1"
                max={selectedSourceData?.page_count || undefined}
                className="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="px-4 py-3 border-t border-gray-200 dark:border-gray-700 flex justify-end gap-2">
          <button
            onClick={handleClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg"
          >
            Cancel
          </button>
          <button
            onClick={handleInsert}
            disabled={!selectedSource}
            className="px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Insert Citation
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/evidence/EvidencePanel.tsx">
'use client'

import { useState } from 'react'

interface Evidence {
  id: string
  content: string
  sourceId: string
  sourceTitle: string
  chunkIndex: number
  similarity: number
  pageNumber?: number
}

interface EvidencePanelProps {
  projectId?: string
  selectedText?: string
  isOpen: boolean
  onClose: () => void
  onInsertCitation?: (evidence: Evidence) => void
}

export function EvidencePanel({ projectId, selectedText, isOpen, onClose, onInsertCitation }: EvidencePanelProps) {
  const [query, setQuery] = useState(selectedText || '')
  const [evidence, setEvidence] = useState<Evidence[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [expandedId, setExpandedId] = useState<string | null>(null)

  const searchEvidence = async () => {
    if (!query.trim()) return

    setLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/evidence/find', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: query.trim(),
          projectId,
          limit: 8,
          threshold: 0.3
        })
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Search failed')
      }

      setEvidence(data.evidence || [])
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Search failed')
    } finally {
      setLoading(false)
    }
  }

  const getSimilarityColor = (similarity: number) => {
    if (similarity >= 0.8) return 'text-green-600 dark:text-green-400 bg-green-50 dark:bg-green-900/20'
    if (similarity >= 0.6) return 'text-blue-600 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/20'
    if (similarity >= 0.4) return 'text-yellow-600 dark:text-yellow-400 bg-yellow-50 dark:bg-yellow-900/20'
    return 'text-gray-600 dark:text-gray-400 bg-gray-50 dark:bg-gray-800'
  }

  const getSimilarityLabel = (similarity: number) => {
    if (similarity >= 0.8) return 'Strong match'
    if (similarity >= 0.6) return 'Good match'
    if (similarity >= 0.4) return 'Partial match'
    return 'Weak match'
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-y-0 right-0 w-[520px] bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-gray-700 shadow-xl z-50 flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-2">
          <svg className="w-5 h-5 text-indigo-600 dark:text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
          <h2 className="font-semibold text-gray-900 dark:text-white">Find Evidence</h2>
        </div>
        <button
          onClick={onClose}
          className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {/* Search Box */}
      <div className="p-4 border-b border-gray-200 dark:border-gray-700">
        <div className="flex gap-2">
          <input
            type="text"
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            onKeyDown={(e) => e.key === 'Enter' && searchEvidence()}
            placeholder="Enter a claim or query to find supporting evidence..."
            className="flex-1 px-3 py-2 bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg text-gray-900 dark:text-white placeholder-gray-400 focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
          />
          <button
            onClick={searchEvidence}
            disabled={loading || !query.trim()}
            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg disabled:opacity-50 flex items-center gap-2"
          >
            {loading ? (
              <svg className="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
              </svg>
            ) : (
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
            )}
            Search
          </button>
        </div>
        <p className="mt-2 text-xs text-gray-500 dark:text-gray-400">
          Search your uploaded sources for evidence that supports or relates to your claim
        </p>
      </div>

      {/* Results */}
      <div className="flex-1 overflow-y-auto p-4">
        {error && (
          <div className="p-3 mb-4 text-sm text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900/20 rounded-lg">
            {error}
          </div>
        )}

        {!loading && evidence.length === 0 && !error && (
          <div className="text-center py-12">
            <svg className="w-12 h-12 mx-auto text-gray-300 dark:text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
            <p className="mt-3 text-sm text-gray-500 dark:text-gray-400">
              Enter a claim or query to find supporting evidence from your sources
            </p>
          </div>
        )}

        {evidence.length > 0 && (
          <div className="space-y-3">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
                {evidence.length} result{evidence.length !== 1 ? 's' : ''} found
              </span>
            </div>

            {evidence.map((item) => (
              <div
                key={item.id}
                className="p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 hover:border-indigo-300 dark:hover:border-indigo-600 transition-colors"
              >
                {/* Header */}
                <div className="flex items-start justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <svg className="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    <span className="text-sm font-medium text-gray-700 dark:text-gray-300 truncate max-w-[200px]">
                      {item.sourceTitle}
                    </span>
                    {item.pageNumber && (
                      <span className="text-xs text-gray-500 dark:text-gray-400">
                        p. {item.pageNumber}
                      </span>
                    )}
                  </div>
                  <span className={`text-xs px-2 py-0.5 rounded ${getSimilarityColor(item.similarity)}`}>
                    {Math.round(item.similarity * 100)}% - {getSimilarityLabel(item.similarity)}
                  </span>
                </div>

                {/* Content */}
                <p
                  className={`text-sm text-gray-600 dark:text-gray-400 ${
                    expandedId === item.id ? '' : 'line-clamp-3'
                  }`}
                >
                  {item.content}
                </p>

                {/* Actions */}
                <div className="flex items-center gap-2 mt-3">
                  <button
                    onClick={() => setExpandedId(expandedId === item.id ? null : item.id)}
                    className="text-xs text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                  >
                    {expandedId === item.id ? 'Show less' : 'Show more'}
                  </button>
                  {onInsertCitation && (
                    <button
                      onClick={() => onInsertCitation(item)}
                      className="ml-auto px-3 py-1 text-xs font-medium text-indigo-600 dark:text-indigo-400 bg-indigo-50 dark:bg-indigo-900/20 rounded hover:bg-indigo-100 dark:hover:bg-indigo-900/30 transition-colors"
                    >
                      Cite this
                    </button>
                  )}
                  <button
                    onClick={() => navigator.clipboard.writeText(item.content)}
                    className="px-3 py-1 text-xs font-medium text-gray-600 dark:text-gray-400 bg-gray-100 dark:bg-gray-700 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                  >
                    Copy
                  </button>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Tips */}
      <div className="p-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800">
        <h4 className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-2">
          Tips
        </h4>
        <ul className="space-y-1 text-xs text-gray-500 dark:text-gray-400">
          <li>‚Ä¢ Use specific claims for better results</li>
          <li>‚Ä¢ Higher match percentages indicate stronger relevance</li>
          <li>‚Ä¢ Click "Cite this" to add as a citation in your document</li>
        </ul>
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/guardrails/GuardrailsPanel.tsx">
'use client'

import { useState } from 'react'
import {
  useGuardrails,
  GuardrailWarning,
  GuardrailSuggestion,
  GuardrailSettings,
} from '@/hooks/useGuardrails'

interface GuardrailsPanelProps {
  text: string
  documentId?: string
  projectId?: string
  onSelectRange?: (start: number, end: number) => void
}

export function GuardrailsPanel({
  text,
  documentId,
  projectId,
  onSelectRange,
}: GuardrailsPanelProps) {
  const {
    settings,
    warnings,
    suggestions,
    metrics,
    loading,
    error,
    analyze,
    suggestCitations,
    factCheck,
    dismissWarning,
    dismissSuggestion,
    updateSettings,
    warningCount,
    suggestionCount,
  } = useGuardrails(documentId, projectId)

  const [activeTab, setActiveTab] = useState<'warnings' | 'suggestions' | 'metrics' | 'settings'>('warnings')
  const [factCheckResults, setFactCheckResults] = useState<{
    results: Array<{
      claim: string
      verdict: string
      confidence: number
      explanation: string
    }>
    summary: {
      total: number
      supported: number
      unsupported: number
    }
  } | null>(null)

  const handleAnalyze = () => {
    analyze(text)
  }

  const handleFactCheck = async () => {
    const results = await factCheck(text)
    if (results) {
      setFactCheckResults(results)
    }
  }

  const handleWarningClick = (warning: GuardrailWarning) => {
    if (onSelectRange && warning.start_offset > 0) {
      onSelectRange(warning.start_offset, warning.end_offset)
    }
  }

  const handleSuggestionClick = (suggestion: GuardrailSuggestion) => {
    if (onSelectRange && suggestion.start_offset > 0) {
      onSelectRange(suggestion.start_offset, suggestion.end_offset)
    }
  }

  const getSeverityColor = (severity: string) => {
    switch (severity) {
      case 'high': return 'text-red-600 bg-red-50 dark:text-red-400 dark:bg-red-900/20'
      case 'medium': return 'text-yellow-600 bg-yellow-50 dark:text-yellow-400 dark:bg-yellow-900/20'
      case 'low': return 'text-blue-600 bg-blue-50 dark:text-blue-400 dark:bg-blue-900/20'
      default: return 'text-gray-600 bg-gray-50 dark:text-gray-400 dark:bg-gray-900/20'
    }
  }

  const getVerdictColor = (verdict: string) => {
    switch (verdict) {
      case 'supported': return 'text-green-600'
      case 'unsupported': return 'text-red-600'
      case 'partially_supported': return 'text-yellow-600'
      case 'needs_verification': return 'text-orange-600'
      default: return 'text-gray-600'
    }
  }

  return (
    <div className="h-full flex flex-col bg-white dark:bg-gray-800 border-l border-gray-200 dark:border-gray-700">
      {/* Header */}
      <div className="p-4 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center justify-between mb-3">
          <h3 className="font-semibold text-gray-900 dark:text-white">AI Guardrails</h3>
          <button
            onClick={handleAnalyze}
            disabled={loading || !text.trim()}
            className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
          >
            {loading ? 'Analyzing...' : 'Analyze'}
          </button>
        </div>

        {/* Quick stats */}
        <div className="flex gap-4 text-sm">
          <span className={warningCount > 0 ? 'text-red-600 dark:text-red-400' : 'text-gray-500'}>
            {warningCount} warnings
          </span>
          <span className={suggestionCount > 0 ? 'text-blue-600 dark:text-blue-400' : 'text-gray-500'}>
            {suggestionCount} suggestions
          </span>
        </div>
      </div>

      {/* Tabs */}
      <div className="flex border-b border-gray-200 dark:border-gray-700">
        {(['warnings', 'suggestions', 'metrics', 'settings'] as const).map((tab) => (
          <button
            key={tab}
            onClick={() => setActiveTab(tab)}
            className={`flex-1 px-3 py-2 text-sm font-medium capitalize ${
              activeTab === tab
                ? 'text-blue-600 border-b-2 border-blue-600'
                : 'text-gray-500 hover:text-gray-700 dark:text-gray-400'
            }`}
          >
            {tab}
          </button>
        ))}
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto p-4">
        {error && (
          <div className="p-3 mb-4 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 rounded text-sm">
            {error}
          </div>
        )}

        {/* Warnings Tab */}
        {activeTab === 'warnings' && (
          <div className="space-y-3">
            {warnings.length === 0 ? (
              <p className="text-gray-500 dark:text-gray-400 text-sm text-center py-8">
                No warnings found. Click Analyze to check your text.
              </p>
            ) : (
              warnings.map((warning, index) => (
                <div
                  key={index}
                  className={`p-3 rounded-lg cursor-pointer ${getSeverityColor(warning.severity)}`}
                  onClick={() => handleWarningClick(warning)}
                >
                  <div className="flex justify-between items-start mb-1">
                    <span className="text-xs font-medium uppercase">{warning.type.replace(/_/g, ' ')}</span>
                    <button
                      onClick={(e) => {
                        e.stopPropagation()
                        dismissWarning(index)
                      }}
                      className="text-gray-400 hover:text-gray-600"
                    >
                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                  <p className="text-sm font-medium mb-1">&ldquo;{warning.text.slice(0, 100)}{warning.text.length > 100 ? '...' : ''}&rdquo;</p>
                  <p className="text-sm opacity-80">{warning.message}</p>
                  {warning.suggestion && (
                    <p className="text-xs mt-2 opacity-70">Suggestion: {warning.suggestion}</p>
                  )}
                </div>
              ))
            )}
          </div>
        )}

        {/* Suggestions Tab */}
        {activeTab === 'suggestions' && (
          <div className="space-y-3">
            <button
              onClick={() => suggestCitations(text)}
              className="w-full px-3 py-2 text-sm bg-gray-100 dark:bg-gray-700 rounded hover:bg-gray-200 dark:hover:bg-gray-600 mb-4"
            >
              Find Citation Opportunities
            </button>

            {suggestions.length === 0 ? (
              <p className="text-gray-500 dark:text-gray-400 text-sm text-center py-8">
                No suggestions yet.
              </p>
            ) : (
              suggestions.map((suggestion, index) => (
                <div
                  key={index}
                  className="p-3 rounded-lg bg-blue-50 dark:bg-blue-900/20 cursor-pointer"
                  onClick={() => handleSuggestionClick(suggestion)}
                >
                  <div className="flex justify-between items-start mb-1">
                    <span className="text-xs font-medium text-blue-600 dark:text-blue-400 uppercase">
                      {suggestion.type.replace(/_/g, ' ')}
                    </span>
                    <button
                      onClick={(e) => {
                        e.stopPropagation()
                        dismissSuggestion(index)
                      }}
                      className="text-gray-400 hover:text-gray-600"
                    >
                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                  <p className="text-sm text-gray-700 dark:text-gray-300">{suggestion.message}</p>
                </div>
              ))
            )}
          </div>
        )}

        {/* Metrics Tab */}
        {activeTab === 'metrics' && (
          <div className="space-y-4">
            <button
              onClick={handleFactCheck}
              className="w-full px-3 py-2 text-sm bg-gray-100 dark:bg-gray-700 rounded hover:bg-gray-200 dark:hover:bg-gray-600"
            >
              Run Fact Check
            </button>

            {metrics && (
              <div className="space-y-3">
                <div className="p-3 bg-gray-50 dark:bg-gray-900 rounded">
                  <div className="flex justify-between mb-1">
                    <span className="text-sm text-gray-600 dark:text-gray-400">Readability</span>
                    <span className="text-sm font-medium">{metrics.readability_score}/100</span>
                  </div>
                  <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                    <div
                      className="bg-blue-600 h-2 rounded-full"
                      style={{ width: `${metrics.readability_score}%` }}
                    />
                  </div>
                </div>

                <div className="p-3 bg-gray-50 dark:bg-gray-900 rounded">
                  <div className="flex justify-between mb-1">
                    <span className="text-sm text-gray-600 dark:text-gray-400">Confidence</span>
                    <span className="text-sm font-medium">{metrics.confidence_score}/100</span>
                  </div>
                  <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                    <div
                      className="bg-green-600 h-2 rounded-full"
                      style={{ width: `${metrics.confidence_score}%` }}
                    />
                  </div>
                </div>

                <div className="p-3 bg-gray-50 dark:bg-gray-900 rounded">
                  <div className="flex justify-between mb-1">
                    <span className="text-sm text-gray-600 dark:text-gray-400">Citation Coverage</span>
                    <span className="text-sm font-medium">{metrics.citation_coverage}%</span>
                  </div>
                  <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                    <div
                      className="bg-purple-600 h-2 rounded-full"
                      style={{ width: `${metrics.citation_coverage}%` }}
                    />
                  </div>
                </div>
              </div>
            )}

            {factCheckResults && (
              <div className="mt-4">
                <h4 className="font-medium text-gray-900 dark:text-white mb-2">Fact Check Results</h4>
                <div className="p-3 bg-gray-50 dark:bg-gray-900 rounded mb-3">
                  <div className="grid grid-cols-3 gap-2 text-center text-sm">
                    <div>
                      <div className="font-bold text-green-600">{factCheckResults.summary.supported}</div>
                      <div className="text-gray-500 text-xs">Supported</div>
                    </div>
                    <div>
                      <div className="font-bold text-red-600">{factCheckResults.summary.unsupported}</div>
                      <div className="text-gray-500 text-xs">Unsupported</div>
                    </div>
                    <div>
                      <div className="font-bold text-gray-600">{factCheckResults.summary.total}</div>
                      <div className="text-gray-500 text-xs">Total</div>
                    </div>
                  </div>
                </div>
                <div className="space-y-2 max-h-64 overflow-y-auto">
                  {factCheckResults.results.map((result, i) => (
                    <div key={i} className="p-2 bg-gray-50 dark:bg-gray-900 rounded text-sm">
                      <p className="font-medium">&ldquo;{result.claim.slice(0, 80)}...&rdquo;</p>
                      <p className={`text-xs ${getVerdictColor(result.verdict)}`}>
                        {result.verdict} ({Math.round(result.confidence * 100)}% confidence)
                      </p>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}

        {/* Settings Tab */}
        {activeTab === 'settings' && (
          <div className="space-y-4">
            <div>
              <label className="flex items-center gap-2">
                <input
                  type="checkbox"
                  checked={settings.enabled}
                  onChange={(e) => updateSettings({ enabled: e.target.checked })}
                  className="rounded"
                />
                <span className="text-sm text-gray-700 dark:text-gray-300">Enable Guardrails</span>
              </label>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Sensitivity
              </label>
              <select
                value={settings.sensitivity}
                onChange={(e) => updateSettings({ sensitivity: e.target.value as GuardrailSettings['sensitivity'] })}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-900 text-sm"
              >
                <option value="strict">Strict - Flag everything</option>
                <option value="medium">Medium - Balanced</option>
                <option value="relaxed">Relaxed - Major issues only</option>
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Active Checks
              </label>
              <div className="space-y-2">
                {['claims', 'speculation', 'citations', 'readability', 'bias'].map((check) => (
                  <label key={check} className="flex items-center gap-2">
                    <input
                      type="checkbox"
                      checked={settings.checks.includes(check)}
                      onChange={(e) => {
                        const newChecks = e.target.checked
                          ? [...settings.checks, check]
                          : settings.checks.filter(c => c !== check)
                        updateSettings({ checks: newChecks })
                      }}
                      className="rounded"
                    />
                    <span className="text-sm text-gray-600 dark:text-gray-400 capitalize">{check}</span>
                  </label>
                ))}
              </div>
            </div>

            <div>
              <label className="flex items-center gap-2">
                <input
                  type="checkbox"
                  checked={settings.showInlineWarnings}
                  onChange={(e) => updateSettings({ showInlineWarnings: e.target.checked })}
                  className="rounded"
                />
                <span className="text-sm text-gray-700 dark:text-gray-300">Show inline warnings</span>
              </label>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/knowledge/EntityPanel.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useKnowledgeGraph, KnowledgeEntity } from '@/hooks/useKnowledgeGraph'

interface EntityPanelProps {
  workspaceId: string
  entityId: string
  onClose: () => void
  onNavigate?: (entityId: string) => void
}

interface EntityDetails extends KnowledgeEntity {
  mentions: Array<{
    id: string
    document_id: string
    mention_text: string
    context_text?: string
    document?: { id: string; title: string }
  }>
  outgoing_relationships: Array<{
    id: string
    target_entity_id: string
    relationship_type: string
    description?: string
    target?: { id: string; name: string; entity_type: string }
  }>
  incoming_relationships: Array<{
    id: string
    source_entity_id: string
    relationship_type: string
    description?: string
    source?: { id: string; name: string; entity_type: string }
  }>
}

export function EntityPanel({ workspaceId, entityId, onClose, onNavigate }: EntityPanelProps) {
  const { getEntity, updateEntity, deleteEntity } = useKnowledgeGraph(workspaceId)
  const [entity, setEntity] = useState<EntityDetails | null>(null)
  const [loading, setLoading] = useState(true)
  const [editing, setEditing] = useState(false)
  const [editName, setEditName] = useState('')
  const [editDescription, setEditDescription] = useState('')

  useEffect(() => {
    async function load() {
      setLoading(true)
      try {
        const data = await getEntity(entityId)
        setEntity(data as EntityDetails)
        setEditName(data.name)
        setEditDescription(data.description || '')
      } catch (err) {
        console.error('Failed to load entity:', err)
      } finally {
        setLoading(false)
      }
    }
    load()
  }, [entityId, getEntity])

  const handleSave = async () => {
    if (!entity) return
    try {
      await updateEntity(entityId, {
        name: editName,
        description: editDescription,
      })
      setEntity({ ...entity, name: editName, description: editDescription })
      setEditing(false)
    } catch (err) {
      console.error('Failed to update entity:', err)
    }
  }

  const handleDelete = async () => {
    if (!confirm('Delete this entity? This cannot be undone.')) return
    try {
      await deleteEntity(entityId)
      onClose()
    } catch (err) {
      console.error('Failed to delete entity:', err)
    }
  }

  if (loading) {
    return (
      <div className="p-4 bg-white dark:bg-gray-900 border rounded-lg">
        <div className="animate-pulse">
          <div className="h-6 bg-gray-200 rounded w-1/2 mb-4"></div>
          <div className="h-4 bg-gray-200 rounded w-full mb-2"></div>
          <div className="h-4 bg-gray-200 rounded w-3/4"></div>
        </div>
      </div>
    )
  }

  if (!entity) {
    return (
      <div className="p-4 bg-white dark:bg-gray-900 border rounded-lg">
        <p className="text-gray-500">Entity not found</p>
      </div>
    )
  }

  return (
    <div className="bg-white dark:bg-gray-900 border rounded-lg overflow-hidden">
      {/* Header */}
      <div className="p-4 border-b flex items-start justify-between">
        <div className="flex-1">
          {editing ? (
            <input
              type="text"
              value={editName}
              onChange={e => setEditName(e.target.value)}
              className="text-lg font-semibold w-full border rounded px-2 py-1"
            />
          ) : (
            <h3 className="text-lg font-semibold">{entity.name}</h3>
          )}
          <span className="inline-block mt-1 px-2 py-0.5 text-xs rounded bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200">
            {entity.entity_type}
          </span>
        </div>
        <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {/* Content */}
      <div className="p-4 space-y-4 max-h-96 overflow-y-auto">
        {/* Description */}
        <div>
          <h4 className="text-sm font-medium text-gray-500 mb-1">Description</h4>
          {editing ? (
            <textarea
              value={editDescription}
              onChange={e => setEditDescription(e.target.value)}
              rows={3}
              className="w-full border rounded px-2 py-1 text-sm"
            />
          ) : (
            <p className="text-sm">{entity.description || 'No description'}</p>
          )}
        </div>

        {/* Aliases */}
        {entity.aliases && entity.aliases.length > 0 && (
          <div>
            <h4 className="text-sm font-medium text-gray-500 mb-1">Aliases</h4>
            <div className="flex flex-wrap gap-1">
              {entity.aliases.map((alias, i) => (
                <span key={i} className="px-2 py-0.5 text-xs bg-gray-100 dark:bg-gray-800 rounded">
                  {alias}
                </span>
              ))}
            </div>
          </div>
        )}

        {/* Relationships */}
        {(entity.outgoing_relationships?.length > 0 || entity.incoming_relationships?.length > 0) && (
          <div>
            <h4 className="text-sm font-medium text-gray-500 mb-2">Relationships</h4>
            <div className="space-y-1">
              {entity.outgoing_relationships?.map(rel => (
                <div
                  key={rel.id}
                  className="text-sm flex items-center gap-2 p-1 hover:bg-gray-50 dark:hover:bg-gray-800 rounded cursor-pointer"
                  onClick={() => rel.target && onNavigate?.(rel.target.id)}
                >
                  <span className="text-gray-400">‚Üí</span>
                  <span className="text-blue-600">{rel.relationship_type}</span>
                  <span className="font-medium">{rel.target?.name}</span>
                </div>
              ))}
              {entity.incoming_relationships?.map(rel => (
                <div
                  key={rel.id}
                  className="text-sm flex items-center gap-2 p-1 hover:bg-gray-50 dark:hover:bg-gray-800 rounded cursor-pointer"
                  onClick={() => rel.source && onNavigate?.(rel.source.id)}
                >
                  <span className="text-gray-400">‚Üê</span>
                  <span className="text-blue-600">{rel.relationship_type}</span>
                  <span className="font-medium">{rel.source?.name}</span>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Mentions */}
        {entity.mentions && entity.mentions.length > 0 && (
          <div>
            <h4 className="text-sm font-medium text-gray-500 mb-2">
              Document Mentions ({entity.mentions.length})
            </h4>
            <div className="space-y-2">
              {entity.mentions.slice(0, 5).map(mention => (
                <div key={mention.id} className="text-sm p-2 bg-gray-50 dark:bg-gray-800 rounded">
                  <p className="text-xs text-gray-500 mb-1">{mention.document?.title || 'Unknown document'}</p>
                  <p className="italic">&quot;{mention.context_text || mention.mention_text}&quot;</p>
                </div>
              ))}
              {entity.mentions.length > 5 && (
                <p className="text-xs text-gray-500">
                  +{entity.mentions.length - 5} more mentions
                </p>
              )}
            </div>
          </div>
        )}

        {/* Metadata */}
        <div className="text-xs text-gray-400 pt-2 border-t">
          <p>Confidence: {(entity.confidence * 100).toFixed(0)}%</p>
          <p>Created: {new Date(entity.created_at).toLocaleDateString()}</p>
        </div>
      </div>

      {/* Actions */}
      <div className="p-4 border-t bg-gray-50 dark:bg-gray-800 flex gap-2">
        {editing ? (
          <>
            <button
              onClick={handleSave}
              className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              Save
            </button>
            <button
              onClick={() => setEditing(false)}
              className="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300"
            >
              Cancel
            </button>
          </>
        ) : (
          <>
            <button
              onClick={() => setEditing(true)}
              className="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300"
            >
              Edit
            </button>
            <button
              onClick={handleDelete}
              className="px-3 py-1 text-sm bg-red-100 text-red-700 rounded hover:bg-red-200"
            >
              Delete
            </button>
          </>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/knowledge/KnowledgeGraph.tsx">
'use client'

import { useState, useCallback, useRef, useEffect } from 'react'
import dynamic from 'next/dynamic'
import { useKnowledgeGraph, GraphData } from '@/hooks/useKnowledgeGraph'

// Dynamic import to avoid SSR issues with canvas
const ForceGraph2D = dynamic(() => import('react-force-graph-2d'), {
  ssr: false,
  loading: () => <div className="flex items-center justify-center h-full">Loading graph...</div>,
})

interface KnowledgeGraphProps {
  workspaceId: string
  documentId?: string
  centerId?: string
  onNodeClick?: (nodeId: string) => void
}

const ENTITY_COLORS: Record<string, string> = {
  person: '#3b82f6', // blue
  organization: '#8b5cf6', // purple
  concept: '#10b981', // green
  claim: '#f59e0b', // amber
  methodology: '#ec4899', // pink
  finding: '#06b6d4', // cyan
  dataset: '#84cc16', // lime
  location: '#f97316', // orange
  event: '#6366f1', // indigo
  term: '#64748b', // slate
  other: '#9ca3af', // gray
}

const RELATIONSHIP_COLORS: Record<string, string> = {
  supports: '#22c55e', // green
  contradicts: '#ef4444', // red
  related_to: '#6b7280', // gray
  derived_from: '#8b5cf6', // purple
  part_of: '#3b82f6', // blue
  authored_by: '#f59e0b', // amber
  references: '#64748b', // slate
  defines: '#10b981', // emerald
  uses: '#06b6d4', // cyan
  causes: '#f97316', // orange
  precedes: '#a855f7', // violet
  equivalent_to: '#14b8a6', // teal
}

export function KnowledgeGraph({
  workspaceId,
  documentId,
  centerId,
  onNodeClick,
}: KnowledgeGraphProps) {
  const { getGraph, loading } = useKnowledgeGraph(workspaceId)
  const [graphData, setGraphData] = useState<GraphData | null>(null)
  const [selectedNode, setSelectedNode] = useState<string | null>(null)
  const [depth, setDepth] = useState(2)
  const [entityFilter, setEntityFilter] = useState<string[]>([])
  const [relationshipFilter, setRelationshipFilter] = useState<string[]>([])
  const [error, setError] = useState<string | null>(null)
  const graphRef = useRef<{ zoomToFit: (ms?: number) => void } | null>(null)

  // Load graph data
  const loadGraph = useCallback(async () => {
    try {
      setError(null)
      const data = await getGraph({
        center_id: centerId,
        depth,
        limit: 200,
        entity_types: entityFilter.length > 0 ? entityFilter : undefined,
        relationship_types: relationshipFilter.length > 0 ? relationshipFilter : undefined,
        document_id: documentId,
      })
      setGraphData(data)

      // Zoom to fit after data loads
      setTimeout(() => {
        graphRef.current?.zoomToFit(400)
      }, 100)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load graph')
    }
  }, [getGraph, centerId, depth, entityFilter, relationshipFilter, documentId])

  useEffect(() => {
    loadGraph()
  }, [loadGraph])

  // Transform data for force-graph
  const forceGraphData = graphData
    ? {
        nodes: graphData.nodes.map(n => ({
          id: n.id,
          name: n.name,
          type: n.type,
          val: Math.max(1, (n.mention_count || 0) * 0.5 + 1), // Node size based on mentions
          color: ENTITY_COLORS[n.type] || ENTITY_COLORS.other,
        })),
        links: graphData.edges.map(e => ({
          source: e.source,
          target: e.target,
          type: e.type,
          color: RELATIONSHIP_COLORS[e.type] || '#6b7280',
          curvature: 0.2,
        })),
      }
    : { nodes: [], links: [] }

  const handleNodeClick = useCallback(
    (node: { id: string }) => {
      setSelectedNode(node.id)
      onNodeClick?.(node.id)
    },
    [onNodeClick]
  )

  const entityTypes = Object.keys(ENTITY_COLORS)
  const relationshipTypes = Object.keys(RELATIONSHIP_COLORS)

  return (
    <div className="flex flex-col h-full bg-white dark:bg-gray-900 rounded-lg border">
      {/* Controls */}
      <div className="p-4 border-b space-y-3">
        <div className="flex items-center justify-between">
          <h3 className="font-semibold">Knowledge Graph</h3>
          <div className="flex items-center gap-2">
            <label className="text-sm text-gray-600 dark:text-gray-400">Depth:</label>
            <select
              value={depth}
              onChange={e => setDepth(parseInt(e.target.value))}
              className="text-sm border rounded px-2 py-1"
            >
              <option value={1}>1</option>
              <option value={2}>2</option>
              <option value={3}>3</option>
              <option value={4}>4</option>
            </select>
            <button
              onClick={loadGraph}
              disabled={loading}
              className="text-sm px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
            >
              {loading ? 'Loading...' : 'Refresh'}
            </button>
          </div>
        </div>

        {/* Filters */}
        <div className="flex flex-wrap gap-4 text-sm">
          <div>
            <label className="block text-gray-600 dark:text-gray-400 mb-1">Entity Types:</label>
            <div className="flex flex-wrap gap-1">
              {entityTypes.map(type => (
                <button
                  key={type}
                  onClick={() => {
                    setEntityFilter(prev =>
                      prev.includes(type) ? prev.filter(t => t !== type) : [...prev, type]
                    )
                  }}
                  className={`px-2 py-0.5 rounded text-xs ${
                    entityFilter.length === 0 || entityFilter.includes(type)
                      ? 'text-white'
                      : 'bg-gray-200 text-gray-500'
                  }`}
                  style={{
                    backgroundColor:
                      entityFilter.length === 0 || entityFilter.includes(type)
                        ? ENTITY_COLORS[type]
                        : undefined,
                  }}
                >
                  {type}
                </button>
              ))}
            </div>
          </div>
        </div>
      </div>

      {/* Graph */}
      <div className="flex-1 relative">
        {error && (
          <div className="absolute inset-0 flex items-center justify-center bg-red-50 dark:bg-red-900/20">
            <p className="text-red-600 dark:text-red-400">{error}</p>
          </div>
        )}

        {!error && graphData && graphData.nodes.length === 0 && (
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center text-gray-500">
              <p>No entities found</p>
              <p className="text-sm mt-1">Extract entities from documents to build your knowledge graph</p>
            </div>
          </div>
        )}

        {!error && forceGraphData.nodes.length > 0 && (
          <ForceGraph2D
            ref={graphRef as React.MutableRefObject<never>}
            graphData={forceGraphData}
            nodeLabel="name"
            nodeColor="color"
            nodeRelSize={6}
            linkColor="color"
            linkWidth={1.5}
            linkDirectionalArrowLength={4}
            linkDirectionalArrowRelPos={1}
            linkCurvature={0.2}
            linkLabel="type"
            onNodeClick={(node: unknown) => {
              const n = node as { id?: string }
              if (n.id) handleNodeClick({ id: n.id })
            }}
            cooldownTicks={100}
            onEngineStop={() => graphRef.current?.zoomToFit(400)}
            enableZoomInteraction={true}
            enablePanInteraction={true}
          />
        )}
      </div>

      {/* Stats */}
      {graphData?.stats && (
        <div className="p-3 border-t bg-gray-50 dark:bg-gray-800 text-sm">
          <div className="flex gap-4 text-gray-600 dark:text-gray-400">
            <span>
              <strong>{graphData.stats.node_count}</strong> entities
            </span>
            <span>
              <strong>{graphData.stats.edge_count}</strong> relationships
            </span>
            {selectedNode && (
              <span className="ml-auto">
                Selected: <strong>{graphData.nodes.find(n => n.id === selectedNode)?.name}</strong>
              </span>
            )}
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/src/components/pdf/PDFViewer.tsx">
'use client'

import { useState, useCallback } from 'react'
import { Document, Page, pdfjs } from 'react-pdf'
import 'react-pdf/dist/Page/AnnotationLayer.css'
import 'react-pdf/dist/Page/TextLayer.css'

// Configure PDF.js worker
pdfjs.GlobalWorkerOptions.workerSrc = `//unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.mjs`

interface PDFViewerProps {
  url: string
  title?: string
  initialPage?: number
  onClose?: () => void
  onPageChange?: (page: number) => void
  onTextSelect?: (text: string, page: number) => void
}

export function PDFViewer({
  url,
  title,
  initialPage = 1,
  onClose,
  onPageChange,
  onTextSelect
}: PDFViewerProps) {
  const [numPages, setNumPages] = useState<number>(0)
  const [pageNumber, setPageNumber] = useState(initialPage)
  const [scale, setScale] = useState(1.0)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const onDocumentLoadSuccess = useCallback(({ numPages }: { numPages: number }) => {
    setNumPages(numPages)
    setLoading(false)
    setError(null)
  }, [])

  const onDocumentLoadError = useCallback((error: Error) => {
    console.error('PDF load error:', error)
    setError('Failed to load PDF')
    setLoading(false)
  }, [])

  const goToPage = (page: number) => {
    const newPage = Math.max(1, Math.min(page, numPages))
    setPageNumber(newPage)
    onPageChange?.(newPage)
  }

  const handleTextSelection = () => {
    const selection = window.getSelection()
    if (selection && selection.toString().trim()) {
      onTextSelect?.(selection.toString().trim(), pageNumber)
    }
  }

  const zoomIn = () => setScale(s => Math.min(s + 0.25, 3.0))
  const zoomOut = () => setScale(s => Math.max(s - 0.25, 0.5))
  const resetZoom = () => setScale(1.0)

  return (
    <div className="flex flex-col h-full bg-gray-100 dark:bg-gray-900">
      {/* Toolbar */}
      <div className="flex items-center justify-between px-4 py-2 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-4">
          {onClose && (
            <button
              onClick={onClose}
              className="p-1.5 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 rounded hover:bg-gray-100 dark:hover:bg-gray-700"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          )}
          {title && (
            <h3 className="text-sm font-medium text-gray-900 dark:text-white truncate max-w-[200px]">
              {title}
            </h3>
          )}
        </div>

        {/* Page Navigation */}
        <div className="flex items-center gap-2">
          <button
            onClick={() => goToPage(pageNumber - 1)}
            disabled={pageNumber <= 1}
            className="p-1.5 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 rounded hover:bg-gray-100 dark:hover:bg-gray-700 disabled:opacity-50"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
          </button>

          <span className="text-sm text-gray-600 dark:text-gray-300">
            <input
              type="number"
              value={pageNumber}
              onChange={(e) => goToPage(parseInt(e.target.value) || 1)}
              className="w-12 px-1 py-0.5 text-center bg-gray-100 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded text-sm"
              min={1}
              max={numPages}
            />
            <span className="mx-1">/</span>
            <span>{numPages || '...'}</span>
          </span>

          <button
            onClick={() => goToPage(pageNumber + 1)}
            disabled={pageNumber >= numPages}
            className="p-1.5 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 rounded hover:bg-gray-100 dark:hover:bg-gray-700 disabled:opacity-50"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
          </button>
        </div>

        {/* Zoom Controls */}
        <div className="flex items-center gap-1">
          <button
            onClick={zoomOut}
            disabled={scale <= 0.5}
            className="p-1.5 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 rounded hover:bg-gray-100 dark:hover:bg-gray-700 disabled:opacity-50"
            title="Zoom out"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7" />
            </svg>
          </button>

          <button
            onClick={resetZoom}
            className="px-2 py-1 text-xs font-medium text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
          >
            {Math.round(scale * 100)}%
          </button>

          <button
            onClick={zoomIn}
            disabled={scale >= 3.0}
            className="p-1.5 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 rounded hover:bg-gray-100 dark:hover:bg-gray-700 disabled:opacity-50"
            title="Zoom in"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v6m3-3H7" />
            </svg>
          </button>
        </div>
      </div>

      {/* PDF Display */}
      <div
        className="flex-1 overflow-auto flex justify-center p-4"
        onMouseUp={handleTextSelection}
      >
        {loading && (
          <div className="flex items-center justify-center h-full">
            <div className="flex flex-col items-center gap-3">
              <svg className="w-8 h-8 animate-spin text-indigo-600" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
              </svg>
              <span className="text-sm text-gray-500 dark:text-gray-400">Loading PDF...</span>
            </div>
          </div>
        )}

        {error && (
          <div className="flex items-center justify-center h-full">
            <div className="text-center">
              <svg className="w-12 h-12 mx-auto text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
              </svg>
              <p className="mt-2 text-sm text-red-600 dark:text-red-400">{error}</p>
            </div>
          </div>
        )}

        <Document
          file={url}
          onLoadSuccess={onDocumentLoadSuccess}
          onLoadError={onDocumentLoadError}
          loading={null}
          className="shadow-lg"
        >
          <Page
            pageNumber={pageNumber}
            scale={scale}
            className="bg-white"
            renderTextLayer={true}
            renderAnnotationLayer={true}
          />
        </Document>
      </div>

      {/* Quick Navigation */}
      <div className="px-4 py-2 bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700">
        <div className="flex items-center justify-center gap-2">
          <button
            onClick={() => goToPage(1)}
            disabled={pageNumber === 1}
            className="px-2 py-1 text-xs text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 disabled:opacity-50"
          >
            First
          </button>
          <div className="flex-1 max-w-md">
            <input
              type="range"
              min={1}
              max={numPages || 1}
              value={pageNumber}
              onChange={(e) => goToPage(parseInt(e.target.value))}
              className="w-full h-1 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer"
            />
          </div>
          <button
            onClick={() => goToPage(numPages)}
            disabled={pageNumber === numPages}
            className="px-2 py-1 text-xs text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 disabled:opacity-50"
          >
            Last
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/pdf/PDFViewerModal.tsx">
'use client'

import { useEffect } from 'react'
import { PDFViewer } from './PDFViewer'

interface PDFViewerModalProps {
  isOpen: boolean
  url: string
  title?: string
  initialPage?: number
  onClose: () => void
  onTextSelect?: (text: string, page: number) => void
}

export function PDFViewerModal({
  isOpen,
  url,
  title,
  initialPage,
  onClose,
  onTextSelect
}: PDFViewerModalProps) {
  // Close on escape key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        onClose()
      }
    }
    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [isOpen, onClose])

  // Prevent body scroll when modal is open
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden'
    } else {
      document.body.style.overflow = ''
    }
    return () => {
      document.body.style.overflow = ''
    }
  }, [isOpen])

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Backdrop */}
      <div
        className="absolute inset-0 bg-black/60 backdrop-blur-sm"
        onClick={onClose}
      />

      {/* Modal */}
      <div className="relative w-[90vw] h-[90vh] max-w-6xl bg-white dark:bg-gray-900 rounded-xl shadow-2xl overflow-hidden">
        <PDFViewer
          url={url}
          title={title}
          initialPage={initialPage}
          onClose={onClose}
          onTextSelect={onTextSelect}
        />
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/safety/SafetyPanel.tsx">
'use client'

import { useState } from 'react'

interface SafetyIssue {
  type: 'unsupported_claim' | 'outdated_reference' | 'unverifiable' | 'speculation' | 'overgeneralization' | 'missing_context'
  severity: 'high' | 'medium' | 'low'
  text: string
  suggestion: string
}

interface SafetyAssessment {
  overallScore: number
  riskLevel: 'low' | 'moderate' | 'high' | 'critical'
  issues: SafetyIssue[]
  summary: string
  recommendations: string[]
  stats: {
    totalClaims: number
    supportedClaims: number
    unsupportedClaims: number
    speculativeClaims: number
    citationsCoverage: number
  }
}

interface SafetyPanelProps {
  documentContent: string
  documentId?: string
  projectId?: string
  isOpen: boolean
  onClose: () => void
}

export function SafetyPanel({ documentContent, documentId, projectId, isOpen, onClose }: SafetyPanelProps) {
  const [assessment, setAssessment] = useState<SafetyAssessment | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [expandedIssue, setExpandedIssue] = useState<number | null>(null)

  const runAssessment = async () => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/safety/assess', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: documentContent,
          documentId,
          projectId
        })
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Assessment failed')
      }

      setAssessment(data.assessment)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Assessment failed')
    } finally {
      setLoading(false)
    }
  }

  const getScoreColor = (score: number) => {
    if (score >= 90) return 'text-green-600 dark:text-green-400'
    if (score >= 70) return 'text-blue-600 dark:text-blue-400'
    if (score >= 50) return 'text-yellow-600 dark:text-yellow-400'
    if (score >= 30) return 'text-orange-600 dark:text-orange-400'
    return 'text-red-600 dark:text-red-400'
  }

  const getScoreBg = (score: number) => {
    if (score >= 90) return 'bg-green-500'
    if (score >= 70) return 'bg-blue-500'
    if (score >= 50) return 'bg-yellow-500'
    if (score >= 30) return 'bg-orange-500'
    return 'bg-red-500'
  }

  const getRiskBadge = (risk: string) => {
    switch (risk) {
      case 'low': return 'bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400'
      case 'moderate': return 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-400'
      case 'high': return 'bg-orange-100 text-orange-700 dark:bg-orange-900/30 dark:text-orange-400'
      case 'critical': return 'bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400'
      default: return 'bg-gray-100 text-gray-700'
    }
  }

  const getSeverityIcon = (severity: string) => {
    switch (severity) {
      case 'high': return 'üî¥'
      case 'medium': return 'üü°'
      case 'low': return 'üü¢'
      default: return '‚ö™'
    }
  }

  const getTypeIcon = (type: string) => {
    switch (type) {
      case 'unsupported_claim': return '‚ùì'
      case 'outdated_reference': return 'üìÖ'
      case 'unverifiable': return 'üîç'
      case 'speculation': return 'üí≠'
      case 'overgeneralization': return 'üåê'
      case 'missing_context': return 'üìã'
      default: return '‚ö†Ô∏è'
    }
  }

  const getTypeLabel = (type: string) => {
    switch (type) {
      case 'unsupported_claim': return 'Unsupported Claim'
      case 'outdated_reference': return 'Outdated Reference'
      case 'unverifiable': return 'Unverifiable'
      case 'speculation': return 'Speculation'
      case 'overgeneralization': return 'Overgeneralization'
      case 'missing_context': return 'Missing Context'
      default: return type
    }
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-y-0 right-0 w-[480px] bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-gray-700 shadow-xl z-50 flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-2">
          <svg className="w-5 h-5 text-emerald-600 dark:text-emerald-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
          </svg>
          <h2 className="font-semibold text-gray-900 dark:text-white">Safety Assessment</h2>
        </div>
        <button
          onClick={onClose}
          className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {/* Action Bar */}
      <div className="px-4 py-3 bg-gray-50 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <button
          onClick={runAssessment}
          disabled={loading}
          className="w-full px-4 py-2 text-sm font-medium text-white bg-emerald-600 hover:bg-emerald-700 rounded-lg disabled:opacity-50 flex items-center justify-center gap-2"
        >
          {loading ? (
            <>
              <svg className="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
              </svg>
              Analyzing...
            </>
          ) : (
            <>
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
              </svg>
              Run Safety Assessment
            </>
          )}
        </button>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto p-4">
        {error && (
          <div className="p-3 mb-4 text-sm text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900/20 rounded-lg">
            {error}
          </div>
        )}

        {!assessment && !loading && !error && (
          <div className="text-center py-8">
            <svg className="w-12 h-12 mx-auto text-gray-300 dark:text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
            </svg>
            <p className="mt-3 text-sm text-gray-500 dark:text-gray-400">
              Assess your document for reliability issues
            </p>
            <p className="mt-1 text-xs text-gray-400 dark:text-gray-500">
              AI analyzes claims, evidence, and potential hallucinations
            </p>
          </div>
        )}

        {assessment && (
          <div className="space-y-4">
            {/* Score Card */}
            <div className="p-4 bg-gradient-to-r from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-700 rounded-lg">
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-3">
                  <div className={`text-4xl font-bold ${getScoreColor(assessment.overallScore)}`}>
                    {assessment.overallScore}
                  </div>
                  <div>
                    <div className="text-sm font-medium text-gray-700 dark:text-gray-300">
                      Safety Score
                    </div>
                    <span className={`text-xs px-2 py-0.5 rounded ${getRiskBadge(assessment.riskLevel)}`}>
                      {assessment.riskLevel.toUpperCase()} RISK
                    </span>
                  </div>
                </div>
              </div>
              {/* Score Bar */}
              <div className="h-2 bg-gray-200 dark:bg-gray-600 rounded-full overflow-hidden">
                <div
                  className={`h-full ${getScoreBg(assessment.overallScore)} transition-all duration-500`}
                  style={{ width: `${assessment.overallScore}%` }}
                />
              </div>
            </div>

            {/* Summary */}
            <div className="p-3 bg-emerald-50 dark:bg-emerald-900/20 rounded-lg">
              <p className="text-sm text-gray-700 dark:text-gray-300">
                {assessment.summary}
              </p>
            </div>

            {/* Stats */}
            <div className="grid grid-cols-2 gap-2 text-xs">
              <div className="p-2 bg-gray-50 dark:bg-gray-800 rounded">
                <div className="text-lg font-bold text-gray-900 dark:text-white">
                  {assessment.stats.totalClaims}
                </div>
                <div className="text-gray-500">Total Claims</div>
              </div>
              <div className="p-2 bg-green-50 dark:bg-green-900/20 rounded">
                <div className="text-lg font-bold text-green-600 dark:text-green-400">
                  {assessment.stats.supportedClaims}
                </div>
                <div className="text-gray-500">Supported</div>
              </div>
              <div className="p-2 bg-red-50 dark:bg-red-900/20 rounded">
                <div className="text-lg font-bold text-red-600 dark:text-red-400">
                  {assessment.stats.unsupportedClaims}
                </div>
                <div className="text-gray-500">Unsupported</div>
              </div>
              <div className="p-2 bg-yellow-50 dark:bg-yellow-900/20 rounded">
                <div className="text-lg font-bold text-yellow-600 dark:text-yellow-400">
                  {assessment.stats.speculativeClaims}
                </div>
                <div className="text-gray-500">Speculative</div>
              </div>
            </div>

            {/* Issues */}
            {assessment.issues.length > 0 && (
              <div className="space-y-2">
                <h3 className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Issues ({assessment.issues.length})
                </h3>
                {assessment.issues.map((issue, index) => (
                  <div
                    key={index}
                    className="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                    onClick={() => setExpandedIssue(expandedIssue === index ? null : index)}
                  >
                    <div className="flex items-start gap-2">
                      <span>{getSeverityIcon(issue.severity)}</span>
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1">
                          <span className="text-xs">{getTypeIcon(issue.type)}</span>
                          <span className="text-xs font-medium text-gray-600 dark:text-gray-400">
                            {getTypeLabel(issue.type)}
                          </span>
                        </div>
                        <p className="text-sm text-gray-700 dark:text-gray-300 line-clamp-2">
                          &ldquo;{issue.text}&rdquo;
                        </p>
                        {expandedIssue === index && (
                          <div className="mt-2 pt-2 border-t border-gray-200 dark:border-gray-700">
                            <p className="text-xs text-green-600 dark:text-green-400">
                              <strong>Suggestion:</strong> {issue.suggestion}
                            </p>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Recommendations */}
            {assessment.recommendations.length > 0 && (
              <div className="space-y-2">
                <h3 className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Recommendations
                </h3>
                <ul className="space-y-1">
                  {assessment.recommendations.map((rec, index) => (
                    <li key={index} className="flex items-start gap-2 text-sm text-gray-600 dark:text-gray-400">
                      <span className="text-emerald-500 mt-0.5">‚Ä¢</span>
                      {rec}
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/src/components/workflows/WorkflowPanel.tsx">
'use client'

import { useState, useEffect } from 'react'

interface Workflow {
  id: string
  projectId: string
  workflowType: string
  name: string
  description: string
  schedule: string
  enabled: boolean
  lastRun?: string
  nextRun?: string
}

interface WorkflowPanelProps {
  projectId: string
  isOpen: boolean
  onClose: () => void
}

export function WorkflowPanel({ projectId, isOpen, onClose }: WorkflowPanelProps) {
  const [workflows, setWorkflows] = useState<Workflow[]>([])
  const [loading, setLoading] = useState(true)
  const [updating, setUpdating] = useState<string | null>(null)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (isOpen && projectId) {
      loadWorkflows()
    }
  }, [isOpen, projectId])

  const loadWorkflows = async () => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch(`/api/workflows?projectId=${projectId}`)
      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to load workflows')
      }

      setWorkflows(data.workflows)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load workflows')
    } finally {
      setLoading(false)
    }
  }

  const toggleWorkflow = async (workflow: Workflow) => {
    setUpdating(workflow.id)

    try {
      const response = await fetch('/api/workflows', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          projectId,
          workflowType: workflow.workflowType,
          enabled: !workflow.enabled
        })
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to update workflow')
      }

      // Update local state
      setWorkflows(prev =>
        prev.map(w =>
          w.workflowType === workflow.workflowType
            ? { ...w, enabled: !workflow.enabled }
            : w
        )
      )
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update workflow')
    } finally {
      setUpdating(null)
    }
  }

  const getScheduleIcon = (schedule: string) => {
    switch (schedule) {
      case 'daily':
        return (
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
          </svg>
        )
      case 'weekly':
        return (
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
          </svg>
        )
      default:
        return (
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        )
    }
  }

  const getWorkflowIcon = (type: string) => {
    switch (type) {
      case 'daily_index_refresh':
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
        )
      case 'weekly_exec_summary':
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
        )
      case 'weekly_inconsistency_scan':
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
          </svg>
        )
      case 'weekly_citation_check':
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" />
          </svg>
        )
      case 'weekly_risk_assessment':
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
          </svg>
        )
      default:
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
          </svg>
        )
    }
  }

  const formatDate = (dateString?: string) => {
    if (!dateString) return null
    const date = new Date(dateString)
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    })
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-y-0 right-0 w-[480px] bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-gray-700 shadow-xl z-50 flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-2">
          <svg className="w-5 h-5 text-purple-600 dark:text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
          </svg>
          <h2 className="font-semibold text-gray-900 dark:text-white">Automations</h2>
        </div>
        <button
          onClick={onClose}
          className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {/* Info Banner */}
      <div className="px-4 py-3 bg-purple-50 dark:bg-purple-900/20 border-b border-purple-100 dark:border-purple-800">
        <p className="text-sm text-purple-700 dark:text-purple-300">
          Configure automated workflows to keep your research up-to-date and verified.
        </p>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto p-4">
        {error && (
          <div className="p-3 mb-4 text-sm text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900/20 rounded-lg">
            {error}
          </div>
        )}

        {loading ? (
          <div className="flex items-center justify-center py-8">
            <svg className="w-6 h-6 animate-spin text-purple-600" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
            </svg>
          </div>
        ) : (
          <div className="space-y-3">
            {workflows.map((workflow) => (
              <div
                key={workflow.id}
                className={`p-4 rounded-lg border transition-all ${
                  workflow.enabled
                    ? 'bg-purple-50 dark:bg-purple-900/20 border-purple-200 dark:border-purple-700'
                    : 'bg-gray-50 dark:bg-gray-800 border-gray-200 dark:border-gray-700'
                }`}
              >
                <div className="flex items-start justify-between">
                  <div className="flex items-start gap-3">
                    <div className={`p-2 rounded-lg ${
                      workflow.enabled
                        ? 'bg-purple-100 dark:bg-purple-800 text-purple-600 dark:text-purple-400'
                        : 'bg-gray-200 dark:bg-gray-700 text-gray-500 dark:text-gray-400'
                    }`}>
                      {getWorkflowIcon(workflow.workflowType)}
                    </div>
                    <div className="flex-1">
                      <h3 className="font-medium text-gray-900 dark:text-white">
                        {workflow.name}
                      </h3>
                      <p className="text-sm text-gray-500 dark:text-gray-400 mt-0.5">
                        {workflow.description}
                      </p>
                      <div className="flex items-center gap-3 mt-2">
                        <span className="flex items-center gap-1 text-xs text-gray-500 dark:text-gray-400">
                          {getScheduleIcon(workflow.schedule)}
                          <span className="capitalize">{workflow.schedule}</span>
                        </span>
                        {workflow.lastRun && (
                          <span className="text-xs text-gray-400 dark:text-gray-500">
                            Last: {formatDate(workflow.lastRun)}
                          </span>
                        )}
                        {workflow.nextRun && workflow.enabled && (
                          <span className="text-xs text-purple-600 dark:text-purple-400">
                            Next: {formatDate(workflow.nextRun)}
                          </span>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* Toggle */}
                  <button
                    onClick={() => toggleWorkflow(workflow)}
                    disabled={updating === workflow.id}
                    className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                      workflow.enabled
                        ? 'bg-purple-600'
                        : 'bg-gray-300 dark:bg-gray-600'
                    } ${updating === workflow.id ? 'opacity-50' : ''}`}
                  >
                    <span
                      className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                        workflow.enabled ? 'translate-x-6' : 'translate-x-1'
                      }`}
                    />
                  </button>
                </div>
              </div>
            ))}
          </div>
        )}

        {/* Bottom Info */}
        <div className="mt-6 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
          <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            How it works
          </h4>
          <ul className="space-y-2 text-xs text-gray-500 dark:text-gray-400">
            <li className="flex items-start gap-2">
              <span className="text-purple-500">1.</span>
              Enable workflows you want to automate
            </li>
            <li className="flex items-start gap-2">
              <span className="text-purple-500">2.</span>
              Workflows run on their schedule (daily/weekly)
            </li>
            <li className="flex items-start gap-2">
              <span className="text-purple-500">3.</span>
              Results appear in your notifications and project dashboard
            </li>
          </ul>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(auth)/login/page.tsx">
'use client'

import { useState, Suspense } from 'react'
import { createClient } from '@/lib/supabase/client'
import { useRouter, useSearchParams } from 'next/navigation'
import Link from 'next/link'

function LoginForm() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState<string | null>(null)
  const [loading, setLoading] = useState(false)
  const router = useRouter()
  const searchParams = useSearchParams()
  const redirect = searchParams.get('redirect') || '/dashboard'

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)
    setError(null)

    const supabase = createClient()
    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) {
      setError(error.message)
      setLoading(false)
      return
    }

    router.push(redirect)
    router.refresh()
  }

  const handleMagicLink = async () => {
    if (!email) {
      setError('Please enter your email')
      return
    }

    setLoading(true)
    setError(null)

    const supabase = createClient()
    const { error } = await supabase.auth.signInWithOtp({
      email,
      options: {
        emailRedirectTo: `${window.location.origin}/callback?redirect=${redirect}`,
      },
    })

    if (error) {
      setError(error.message)
      setLoading(false)
      return
    }

    setError(null)
    alert('Check your email for a login link!')
    setLoading(false)
  }

  const handleOAuthLogin = async (provider: 'google' | 'github') => {
    setLoading(true)
    setError(null)

    const supabase = createClient()
    const { error } = await supabase.auth.signInWithOAuth({
      provider,
      options: {
        redirectTo: `${window.location.origin}/callback?redirect=${redirect}`,
      },
    })

    if (error) {
      setError(error.message)
      setLoading(false)
    }
  }

  return (
    <form onSubmit={handleLogin} className="mt-8 space-y-6">
      {error && (
        <div className="bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 p-3 rounded-lg text-sm">
          {error}
        </div>
      )}

      <div className="space-y-4">
        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
            Email address
          </label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-800 dark:text-white"
            placeholder="you@example.com"
          />
        </div>

        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
            Password
          </label>
          <input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-800 dark:text-white"
            placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
          />
        </div>
      </div>

      <div className="space-y-3">
        <button
          type="submit"
          disabled={loading}
          className="w-full flex justify-center py-2.5 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? 'Signing in...' : 'Sign in'}
        </button>

        <button
          type="button"
          onClick={handleMagicLink}
          disabled={loading}
          className="w-full flex justify-center py-2.5 px-4 border border-gray-300 dark:border-gray-700 rounded-lg shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Send magic link
        </button>
      </div>

      <div className="relative">
        <div className="absolute inset-0 flex items-center">
          <div className="w-full border-t border-gray-300 dark:border-gray-700" />
        </div>
        <div className="relative flex justify-center text-sm">
          <span className="px-2 bg-gray-50 dark:bg-gray-900 text-gray-500">Or continue with</span>
        </div>
      </div>

      <div className="grid grid-cols-2 gap-3">
        <button
          type="button"
          onClick={() => handleOAuthLogin('google')}
          disabled={loading}
          className="w-full flex items-center justify-center gap-2 py-2.5 px-4 border border-gray-300 dark:border-gray-700 rounded-lg shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <svg className="w-5 h-5" viewBox="0 0 24 24">
            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
          </svg>
          Google
        </button>

        <button
          type="button"
          onClick={() => handleOAuthLogin('github')}
          disabled={loading}
          className="w-full flex items-center justify-center gap-2 py-2.5 px-4 border border-gray-300 dark:border-gray-700 rounded-lg shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
            <path fillRule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clipRule="evenodd"/>
          </svg>
          GitHub
        </button>
      </div>
    </form>
  )
}

export default function LoginPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 px-4">
      <div className="max-w-md w-full space-y-8">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-gray-900 dark:text-white">
            ResearchBase
          </h1>
          <p className="mt-2 text-gray-600 dark:text-gray-400">
            Sign in to your account
          </p>
        </div>

        <Suspense fallback={<div className="text-center">Loading...</div>}>
          <LoginForm />
        </Suspense>

        <p className="text-center text-sm text-gray-600 dark:text-gray-400">
          Don&apos;t have an account?{' '}
          <Link href="/signup" className="text-blue-600 hover:text-blue-500">
            Sign up
          </Link>
        </p>
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(auth)/signup/page.tsx">
'use client'

import { useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { useRouter } from 'next/navigation'
import Link from 'next/link'

export default function SignupPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [fullName, setFullName] = useState('')
  const [error, setError] = useState<string | null>(null)
  const [loading, setLoading] = useState(false)
  const [success, setSuccess] = useState(false)
  const router = useRouter()

  const handleSignup = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)
    setError(null)

    if (password.length < 6) {
      setError('Password must be at least 6 characters')
      setLoading(false)
      return
    }

    const supabase = createClient()
    const { error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          full_name: fullName,
        },
        emailRedirectTo: `${window.location.origin}/callback`,
      },
    })

    if (error) {
      setError(error.message)
      setLoading(false)
      return
    }

    setSuccess(true)
    setLoading(false)
  }

  const handleOAuthSignup = async (provider: 'google' | 'github') => {
    setLoading(true)
    setError(null)

    const supabase = createClient()
    const { error } = await supabase.auth.signInWithOAuth({
      provider,
      options: {
        redirectTo: `${window.location.origin}/callback`,
      },
    })

    if (error) {
      setError(error.message)
      setLoading(false)
    }
  }

  if (success) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 px-4">
        <div className="max-w-md w-full text-center space-y-4">
          <div className="text-green-600 dark:text-green-400">
            <svg className="w-16 h-16 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <h2 className="text-2xl font-bold text-gray-900 dark:text-white">
            Check your email
          </h2>
          <p className="text-gray-600 dark:text-gray-400">
            We&apos;ve sent a confirmation link to <strong>{email}</strong>
          </p>
          <Link
            href="/login"
            className="inline-block mt-4 text-blue-600 hover:text-blue-500"
          >
            Back to login
          </Link>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 px-4">
      <div className="max-w-md w-full space-y-8">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-gray-900 dark:text-white">
            ResearchBase
          </h1>
          <p className="mt-2 text-gray-600 dark:text-gray-400">
            Create your account
          </p>
        </div>

        <form onSubmit={handleSignup} className="mt-8 space-y-6">
          {error && (
            <div className="bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 p-3 rounded-lg text-sm">
              {error}
            </div>
          )}

          <div className="space-y-4">
            <div>
              <label htmlFor="fullName" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Full name
              </label>
              <input
                id="fullName"
                type="text"
                value={fullName}
                onChange={(e) => setFullName(e.target.value)}
                required
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-800 dark:text-white"
                placeholder="John Doe"
              />
            </div>

            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Email address
              </label>
              <input
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-800 dark:text-white"
                placeholder="you@example.com"
              />
            </div>

            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Password
              </label>
              <input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                minLength={6}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-800 dark:text-white"
                placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
              />
              <p className="mt-1 text-xs text-gray-500">Minimum 6 characters</p>
            </div>
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full flex justify-center py-2.5 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {loading ? 'Creating account...' : 'Create account'}
          </button>

          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300 dark:border-gray-700" />
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-gray-50 dark:bg-gray-900 text-gray-500">Or continue with</span>
            </div>
          </div>

          <div className="grid grid-cols-2 gap-3">
            <button
              type="button"
              onClick={() => handleOAuthSignup('google')}
              disabled={loading}
              className="w-full flex items-center justify-center gap-2 py-2.5 px-4 border border-gray-300 dark:border-gray-700 rounded-lg shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <svg className="w-5 h-5" viewBox="0 0 24 24">
                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
              </svg>
              Google
            </button>

            <button
              type="button"
              onClick={() => handleOAuthSignup('github')}
              disabled={loading}
              className="w-full flex items-center justify-center gap-2 py-2.5 px-4 border border-gray-300 dark:border-gray-700 rounded-lg shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                <path fillRule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clipRule="evenodd"/>
              </svg>
              GitHub
            </button>
          </div>
        </form>

        <p className="text-center text-sm text-gray-600 dark:text-gray-400">
          Already have an account?{' '}
          <Link href="/login" className="text-blue-600 hover:text-blue-500">
            Sign in
          </Link>
        </p>
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/api/ask/route.ts">
import { createClient } from '@/lib/supabase/server'
import { generateQueryEmbedding } from '@/lib/voyage'
import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

interface RelevantChunk {
  id: string
  content: string
  source_id: string
  source_title: string
  similarity: number
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { query, projectId, topK = 5 } = body

    if (!query || typeof query !== 'string') {
      return NextResponse.json({ error: 'Query is required' }, { status: 400 })
    }

    // Generate embedding for the query
    const queryEmbedding = await generateQueryEmbedding(query)

    // Search for similar chunks using pgvector
    // Using a raw SQL query for vector similarity search
    const { data: chunks, error: searchError } = await supabase.rpc(
      'match_source_chunks',
      {
        query_embedding: queryEmbedding,
        match_threshold: 0.5,
        match_count: topK,
        p_project_id: projectId || null
      }
    )

    if (searchError) {
      console.error('Search error:', searchError)

      // Fallback: If the RPC doesn't exist, return empty results
      // The RPC function needs to be created in the database
      if (searchError.message.includes('function') || searchError.message.includes('does not exist')) {
        return NextResponse.json({
          query,
          chunks: [],
          answer: null,
          message: 'Vector search function not yet configured. Please run the database migration to add match_source_chunks function.'
        })
      }

      return NextResponse.json({ error: 'Search failed' }, { status: 500 })
    }

    // Format the results
    const relevantChunks: RelevantChunk[] = (chunks || []).map((chunk: {
      id: string
      content: string
      source_id: string
      source_title: string
      similarity: number
    }) => ({
      id: chunk.id,
      content: chunk.content,
      source_id: chunk.source_id,
      source_title: chunk.source_title,
      similarity: chunk.similarity
    }))

    // Build context from relevant chunks
    const context = relevantChunks
      .map((chunk, i) => `[${i + 1}] From "${chunk.source_title}":\n${chunk.content}`)
      .join('\n\n')

    // Generate answer using Claude if we have relevant chunks
    let answer: string

    if (relevantChunks.length === 0) {
      answer = 'No relevant sources found for your query. Try uploading more sources or rephrasing your question.'
    } else {
      const anthropicApiKey = process.env.ANTHROPIC_API_KEY

      if (!anthropicApiKey) {
        // Fallback if no API key
        answer = `Based on ${relevantChunks.length} relevant source(s), here's what I found:\n\n${context}`
      } else {
        try {
          const anthropic = new Anthropic({ apiKey: anthropicApiKey })

          const systemPrompt = `You are a research assistant helping users understand their uploaded sources.
Your task is to synthesize information from the provided source excerpts to answer the user's question.

Guidelines:
- Only use information from the provided sources
- Cite sources using [1], [2], etc. notation matching the source numbers
- If the sources don't contain enough information to fully answer the question, say so
- Be concise but thorough
- Maintain academic objectivity`

          const userPrompt = `Based on the following excerpts from the user's research sources, answer their question.

QUESTION: ${query}

SOURCES:
${context}

Please provide a well-structured answer with proper citations to the source numbers.`

          const response = await anthropic.messages.create({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 1024,
            messages: [
              { role: 'user', content: userPrompt }
            ],
            system: systemPrompt
          })

          // Extract text from response
          const textContent = response.content.find(block => block.type === 'text')
          answer = textContent ? textContent.text : 'Unable to generate answer.'

        } catch (claudeError) {
          console.error('Claude API error:', claudeError)
          // Fallback to showing raw context
          answer = `Based on ${relevantChunks.length} relevant source(s), here's what I found:\n\n${context}`
        }
      }
    }

    return NextResponse.json({
      query,
      chunks: relevantChunks,
      answer,
      sources_count: relevantChunks.length
    })

  } catch (error) {
    console.error('Ask handler error:', error)
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Internal server error'
    }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/documents/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/documents - List documents (optionally filtered by project)
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const projectId = searchParams.get('project_id')

    let query = supabase
      .from('documents')
      .select('*')
      .order('updated_at', { ascending: false })

    if (projectId) {
      query = query.eq('project_id', projectId)
    }

    const { data: documents, error } = await query

    if (error) {
      console.error('Error fetching documents:', error)
      return NextResponse.json({ error: 'Failed to fetch documents' }, { status: 500 })
    }

    return NextResponse.json({ documents })

  } catch (error) {
    console.error('Documents handler error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/documents - Create a new document
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { title, project_id } = body

    if (!title) {
      return NextResponse.json({ error: 'Title is required' }, { status: 400 })
    }

    if (!project_id) {
      return NextResponse.json({ error: 'Project ID is required' }, { status: 400 })
    }

    // Verify user has access to the project
    const { data: project } = await supabase
      .from('projects')
      .select('id, workspace_id')
      .eq('id', project_id)
      .single()

    if (!project) {
      return NextResponse.json({ error: 'Project not found' }, { status: 404 })
    }

    // Check workspace membership
    const { data: membership } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', project.workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!membership) {
      return NextResponse.json({ error: 'Not a member of this workspace' }, { status: 403 })
    }

    // Only owners, admins, and editors can create documents
    if (!['owner', 'admin', 'editor'].includes(membership.role)) {
      return NextResponse.json({ error: 'Insufficient permissions' }, { status: 403 })
    }

    // Create document
    const { data: document, error: createError } = await supabase
      .from('documents')
      .insert({
        title,
        project_id,
        created_by: user.id,
      })
      .select()
      .single()

    if (createError) {
      console.error('Error creating document:', createError)
      return NextResponse.json({ error: 'Failed to create document' }, { status: 500 })
    }

    // Create main branch for the document
    const { data: mainBranch, error: branchError } = await supabase
      .from('doc_branches')
      .insert({
        document_id: document.id,
        name: 'main',
        is_main: true,
        created_by: user.id,
      })
      .select()
      .single()

    if (branchError) {
      console.error('Error creating main branch:', branchError)
      // Cleanup: delete the document
      await supabase.from('documents').delete().eq('id', document.id)
      return NextResponse.json({ error: 'Failed to create document' }, { status: 500 })
    }

    // Create initial empty section
    await supabase
      .from('doc_sections')
      .insert({
        branch_id: mainBranch.id,
        order_index: 0,
        title: 'Introduction',
        content_json: { type: 'doc', content: [{ type: 'paragraph' }] },
        content_text: '',
      })

    // Log activity (non-blocking)
    void (async () => {
      try {
        await supabase.rpc('log_activity', {
          p_action: 'document.create',
          p_workspace_id: project.workspace_id,
          p_project_id: project_id,
          p_document_id: document.id,
          p_target_type: 'document',
          p_target_id: document.id,
          p_details: { title: document.title },
        })
      } catch (err) {
        console.error('Failed to log activity:', err)
      }
    })()

    return NextResponse.json({
      document: {
        ...document,
        main_branch_id: mainBranch.id,
      }
    }, { status: 201 })

  } catch (error) {
    console.error('Create document error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/projects/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/projects - List projects (optionally filtered by workspace)
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const workspaceId = searchParams.get('workspace_id')

    let query = supabase
      .from('projects')
      .select('*')
      .order('updated_at', { ascending: false })

    if (workspaceId) {
      query = query.eq('workspace_id', workspaceId)
    }

    const { data: projects, error } = await query

    if (error) {
      console.error('Error fetching projects:', error)
      return NextResponse.json({ error: 'Failed to fetch projects' }, { status: 500 })
    }

    return NextResponse.json({ projects })

  } catch (error) {
    console.error('Projects handler error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/projects - Create a new project
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { name, description, workspace_id } = body

    if (!name) {
      return NextResponse.json({ error: 'Name is required' }, { status: 400 })
    }

    if (!workspace_id) {
      return NextResponse.json({ error: 'Workspace ID is required' }, { status: 400 })
    }

    // Verify user has access to the workspace
    const { data: membership } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', workspace_id)
      .eq('user_id', user.id)
      .single()

    if (!membership) {
      return NextResponse.json({ error: 'Not a member of this workspace' }, { status: 403 })
    }

    // Only owners, admins, and editors can create projects
    if (!['owner', 'admin', 'editor'].includes(membership.role)) {
      return NextResponse.json({ error: 'Insufficient permissions' }, { status: 403 })
    }

    // Create project
    const { data: project, error: createError } = await supabase
      .from('projects')
      .insert({
        name,
        description: description || null,
        workspace_id,
      })
      .select()
      .single()

    if (createError) {
      console.error('Error creating project:', createError)
      return NextResponse.json({ error: 'Failed to create project' }, { status: 500 })
    }

    // Log activity (non-blocking)
    void (async () => {
      try {
        await supabase.rpc('log_activity', {
          p_action: 'project.create',
          p_workspace_id: workspace_id,
          p_project_id: project.id,
          p_target_type: 'project',
          p_target_id: project.id,
          p_details: { name: project.name },
        })
      } catch (err) {
        console.error('Failed to log activity:', err)
      }
    })()

    return NextResponse.json({ project }, { status: 201 })

  } catch (error) {
    console.error('Create project error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/sources/upload/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const formData = await request.formData()
    const file = formData.get('file') as File
    const projectId = formData.get('projectId') as string

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 })
    }

    if (!file.type.includes('pdf')) {
      return NextResponse.json({ error: 'Only PDF files are supported' }, { status: 400 })
    }

    // Generate unique filename
    const timestamp = Date.now()
    const filename = `${user.id}/${projectId || 'default'}/${timestamp}-${file.name}`

    // Upload to Supabase Storage
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('sources')
      .upload(filename, file, {
        contentType: 'application/pdf',
        upsert: false
      })

    if (uploadError) {
      console.error('Upload error:', uploadError)
      return NextResponse.json({ error: 'Failed to upload file' }, { status: 500 })
    }

    // Get public URL
    const { data: urlData } = supabase.storage
      .from('sources')
      .getPublicUrl(filename)

    // Create source record in database
    const { data: source, error: dbError } = await supabase
      .from('sources')
      .insert({
        project_id: projectId || null,
        title: file.name.replace('.pdf', ''),
        source_type: 'pdf',
        storage_path: filename,
        file_size: file.size,
        uploaded_by: user.id,
        processing_status: 'pending'
      })
      .select()
      .single()

    if (dbError) {
      console.error('Database error:', dbError)
      // Clean up uploaded file
      await supabase.storage.from('sources').remove([filename])
      return NextResponse.json({ error: 'Failed to create source record' }, { status: 500 })
    }

    // Auto-trigger processing in background (non-blocking)
    // We use fetch to call the process endpoint, but don't await it
    const processUrl = new URL(`/api/sources/${source.id}/process`, request.url)
    fetch(processUrl.toString(), {
      method: 'POST',
      headers: {
        'Cookie': request.headers.get('cookie') || '',
      },
    }).catch(err => {
      console.error('Failed to trigger processing:', err)
    })

    return NextResponse.json({
      success: true,
      source: {
        id: source.id,
        title: source.title,
        storage_path: source.storage_path,
        url: urlData.publicUrl,
        processing_status: 'processing' // Will be processing soon
      }
    })

  } catch (error) {
    console.error('Upload handler error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/workspaces/[id]/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/workspaces/[id] - Get workspace details
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get workspace with member info
    const { data: workspace, error } = await supabase
      .from('workspaces')
      .select(`
        *,
        workspace_members (
          user_id,
          role,
          invited_at,
          joined_at
        )
      `)
      .eq('id', id)
      .single()

    if (error || !workspace) {
      return NextResponse.json({ error: 'Workspace not found' }, { status: 404 })
    }

    // Check if user is a member
    const userMember = workspace.workspace_members.find(
      (m: { user_id: string }) => m.user_id === user.id
    )
    if (!userMember) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    return NextResponse.json({
      workspace: {
        id: workspace.id,
        name: workspace.name,
        description: workspace.description,
        slug: workspace.slug,
        owner_id: workspace.owner_id,
        created_at: workspace.created_at,
        updated_at: workspace.updated_at,
        member_count: workspace.workspace_members.length,
      },
      role: userMember.role,
    })

  } catch (error) {
    console.error('Get workspace error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * PATCH /api/workspaces/[id] - Update workspace
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check user's role
    const { data: member } = await supabase
      .from('workspace_members')
      .select('role')
      .eq('workspace_id', id)
      .eq('user_id', user.id)
      .single()

    if (!member || !['owner', 'admin'].includes(member.role)) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    const body = await request.json()
    const { name, description, slug } = body

    const updates: Record<string, unknown> = { updated_at: new Date().toISOString() }
    if (name !== undefined) updates.name = name
    if (description !== undefined) updates.description = description
    if (slug !== undefined) updates.slug = slug

    const { data: workspace, error: updateError } = await supabase
      .from('workspaces')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (updateError) {
      console.error('Update workspace error:', updateError)
      if (updateError.code === '23505') {
        return NextResponse.json({ error: 'Slug already exists' }, { status: 409 })
      }
      return NextResponse.json({ error: 'Failed to update workspace' }, { status: 500 })
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_action: 'workspace.update',
      p_workspace_id: id,
      p_target_type: 'workspace',
      p_target_id: id,
      p_details: updates,
    })

    return NextResponse.json({ workspace })

  } catch (error) {
    console.error('Update workspace error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * DELETE /api/workspaces/[id] - Delete workspace
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Only owner can delete
    const { data: workspace } = await supabase
      .from('workspaces')
      .select('owner_id')
      .eq('id', id)
      .single()

    if (!workspace || workspace.owner_id !== user.id) {
      return NextResponse.json({ error: 'Only workspace owner can delete' }, { status: 403 })
    }

    const { error: deleteError } = await supabase
      .from('workspaces')
      .delete()
      .eq('id', id)

    if (deleteError) {
      console.error('Delete workspace error:', deleteError)
      return NextResponse.json({ error: 'Failed to delete workspace' }, { status: 500 })
    }

    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Delete workspace error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/app/page.tsx">
import Link from 'next/link'
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'

export default async function Home() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  // If logged in, redirect to dashboard
  if (user) {
    redirect('/dashboard')
  }

  return (
    <div className="min-h-screen bg-white dark:bg-gray-950">
      {/* Header */}
      <header className="fixed top-0 left-0 right-0 z-50 bg-white/80 dark:bg-gray-950/80 backdrop-blur-md border-b border-gray-200 dark:border-gray-800">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center gap-2">
              <div className="w-8 h-8 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg flex items-center justify-center">
                <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                </svg>
              </div>
              <span className="text-xl font-bold text-gray-900 dark:text-white">ResearchBase</span>
            </div>
            <nav className="hidden md:flex items-center gap-8">
              <a href="#features" className="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm font-medium transition-colors">
                Features
              </a>
              <a href="#how-it-works" className="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm font-medium transition-colors">
                How it works
              </a>
              <a href="#pricing" className="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm font-medium transition-colors">
                Pricing
              </a>
            </nav>
            <div className="flex items-center gap-4">
              <Link
                href="/login"
                className="text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white text-sm font-medium transition-colors"
              >
                Sign in
              </Link>
              <Link
                href="/signup"
                className="inline-flex items-center px-4 py-2 rounded-lg text-sm font-medium text-white bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 shadow-lg shadow-indigo-500/25 transition-all"
              >
                Get started free
              </Link>
            </div>
          </div>
        </div>
      </header>

      {/* Hero */}
      <main>
        <section className="relative pt-32 pb-20 overflow-hidden">
          {/* Background gradient */}
          <div className="absolute inset-0 bg-gradient-to-b from-indigo-50 to-white dark:from-indigo-950/20 dark:to-gray-950" />
          <div className="absolute top-0 left-1/2 -translate-x-1/2 w-[800px] h-[800px] bg-gradient-to-r from-indigo-400/30 to-purple-400/30 rounded-full blur-3xl" />

          <div className="relative max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="text-center max-w-4xl mx-auto">
              <div className="inline-flex items-center px-3 py-1 rounded-full bg-indigo-100 dark:bg-indigo-900/50 text-indigo-700 dark:text-indigo-300 text-sm font-medium mb-6">
                <span className="w-2 h-2 bg-green-500 rounded-full mr-2 animate-pulse" />
                Now in public beta
              </div>
              <h1 className="text-5xl sm:text-6xl lg:text-7xl font-bold text-gray-900 dark:text-white tracking-tight leading-tight">
                Your AI-powered
                <br />
                <span className="bg-gradient-to-r from-indigo-500 to-purple-600 bg-clip-text text-transparent">
                  research brain
                </span>
              </h1>
              <p className="mt-6 text-xl text-gray-600 dark:text-gray-400 max-w-2xl mx-auto leading-relaxed">
                Write with AI assistance. Understand your documents semantically.
                Find evidence instantly. Verify citations automatically.
                Build your knowledge base effortlessly.
              </p>
              <div className="mt-10 flex flex-col sm:flex-row justify-center gap-4">
                <Link
                  href="/signup"
                  className="inline-flex items-center justify-center px-8 py-4 rounded-xl text-base font-semibold text-white bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 shadow-xl shadow-indigo-500/25 transition-all hover:scale-105"
                >
                  Start for free
                  <svg className="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7l5 5m0 0l-5 5m5-5H6" />
                  </svg>
                </Link>
                <a
                  href="#how-it-works"
                  className="inline-flex items-center justify-center px-8 py-4 rounded-xl text-base font-semibold text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-750 shadow-lg transition-all"
                >
                  See how it works
                </a>
              </div>

              {/* Trust badges */}
              <div className="mt-12 flex flex-wrap justify-center gap-8 text-gray-500 dark:text-gray-400">
                <div className="flex items-center gap-2">
                  <svg className="w-5 h-5 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                  </svg>
                  <span className="text-sm">No credit card required</span>
                </div>
                <div className="flex items-center gap-2">
                  <svg className="w-5 h-5 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                  </svg>
                  <span className="text-sm">Free during beta</span>
                </div>
                <div className="flex items-center gap-2">
                  <svg className="w-5 h-5 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                  </svg>
                  <span className="text-sm">Cancel anytime</span>
                </div>
              </div>
            </div>

            {/* Hero image/preview */}
            <div className="mt-16 relative">
              <div className="absolute inset-0 bg-gradient-to-t from-white dark:from-gray-950 to-transparent z-10 h-32 bottom-0 top-auto" />
              <div className="bg-gray-900 rounded-2xl shadow-2xl overflow-hidden border border-gray-800">
                <div className="flex items-center gap-2 px-4 py-3 bg-gray-800 border-b border-gray-700">
                  <div className="flex gap-1.5">
                    <div className="w-3 h-3 rounded-full bg-red-500" />
                    <div className="w-3 h-3 rounded-full bg-yellow-500" />
                    <div className="w-3 h-3 rounded-full bg-green-500" />
                  </div>
                  <div className="flex-1 text-center text-sm text-gray-400">ResearchBase</div>
                </div>
                <div className="p-6 bg-gray-900 min-h-[400px] flex items-center justify-center">
                  <div className="text-center text-gray-500">
                    <svg className="w-16 h-16 mx-auto mb-4 text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                    </svg>
                    <p className="text-lg font-medium text-gray-400">Interactive Demo Coming Soon</p>
                    <p className="text-sm text-gray-600 mt-1">Sign up to be notified when it&apos;s ready</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>

        {/* Features */}
        <section id="features" className="py-24 bg-gray-50 dark:bg-gray-900">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="text-center max-w-3xl mx-auto mb-16">
              <h2 className="text-3xl sm:text-4xl font-bold text-gray-900 dark:text-white">
                Everything you need for modern research
              </h2>
              <p className="mt-4 text-lg text-gray-600 dark:text-gray-400">
                From writing to verification, ResearchBase has you covered with AI-powered tools designed for researchers.
              </p>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
              {[
                {
                  title: 'AI Writing Assistant',
                  description: 'Transform your text with slash commands. Summarize, rewrite, expand, and refine with Claude AI.',
                  icon: 'M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z',
                  color: 'from-blue-500 to-cyan-500',
                },
                {
                  title: 'Ask Your Project',
                  description: 'Query your entire knowledge base in natural language. Get answers synthesized from all your sources.',
                  icon: 'M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z',
                  color: 'from-purple-500 to-pink-500',
                },
                {
                  title: 'PDF Source Library',
                  description: 'Upload PDFs, automatically extract and embed text. Search semantically across all your documents.',
                  icon: 'M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z',
                  color: 'from-orange-500 to-red-500',
                },
                {
                  title: 'Evidence Finder',
                  description: 'Find supporting evidence for any claim. Semantic search surfaces the most relevant passages instantly.',
                  icon: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z',
                  color: 'from-green-500 to-emerald-500',
                },
                {
                  title: 'Citation Verification',
                  description: 'AI-powered fact-checking. Verify if your citations actually support your claims.',
                  icon: 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z',
                  color: 'from-indigo-500 to-purple-500',
                },
                {
                  title: 'Safety Scoring',
                  description: 'Detect unsupported claims, speculation, and potential hallucinations before they become problems.',
                  icon: 'M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z',
                  color: 'from-yellow-500 to-orange-500',
                },
              ].map((feature, index) => (
                <div key={index} className="relative group">
                  <div className="absolute -inset-1 bg-gradient-to-r opacity-0 group-hover:opacity-100 blur transition duration-500 rounded-2xl" style={{ backgroundImage: `linear-gradient(to right, var(--tw-gradient-stops))` }} />
                  <div className="relative p-8 bg-white dark:bg-gray-800 rounded-2xl shadow-lg hover:shadow-xl transition-shadow">
                    <div className={`w-12 h-12 bg-gradient-to-br ${feature.color} rounded-xl flex items-center justify-center mb-6`}>
                      <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d={feature.icon} />
                      </svg>
                    </div>
                    <h3 className="text-xl font-semibold text-gray-900 dark:text-white mb-3">
                      {feature.title}
                    </h3>
                    <p className="text-gray-600 dark:text-gray-400 leading-relaxed">
                      {feature.description}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </section>

        {/* How it works */}
        <section id="how-it-works" className="py-24">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="text-center max-w-3xl mx-auto mb-16">
              <h2 className="text-3xl sm:text-4xl font-bold text-gray-900 dark:text-white">
                How ResearchBase works
              </h2>
              <p className="mt-4 text-lg text-gray-600 dark:text-gray-400">
                Three simple steps to transform your research workflow
              </p>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-12">
              {[
                {
                  step: '01',
                  title: 'Upload your sources',
                  description: 'Drop your PDFs and documents. We automatically extract text, generate embeddings, and index everything for instant search.',
                },
                {
                  step: '02',
                  title: 'Write with AI',
                  description: 'Start writing in our rich editor. Use slash commands to summarize, expand, or rewrite. Let AI help you articulate your ideas.',
                },
                {
                  step: '03',
                  title: 'Verify & cite',
                  description: 'Find evidence for your claims, insert citations, and verify them automatically. Export in APA, MLA, Chicago, or BibTeX.',
                },
              ].map((item, index) => (
                <div key={index} className="relative">
                  <div className="text-6xl font-bold text-gray-100 dark:text-gray-800 mb-4">
                    {item.step}
                  </div>
                  <h3 className="text-xl font-semibold text-gray-900 dark:text-white mb-3">
                    {item.title}
                  </h3>
                  <p className="text-gray-600 dark:text-gray-400 leading-relaxed">
                    {item.description}
                  </p>
                </div>
              ))}
            </div>
          </div>
        </section>

        {/* Pricing */}
        <section id="pricing" className="py-24 bg-gray-50 dark:bg-gray-900">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="text-center max-w-3xl mx-auto mb-16">
              <h2 className="text-3xl sm:text-4xl font-bold text-gray-900 dark:text-white">
                Simple, transparent pricing
              </h2>
              <p className="mt-4 text-lg text-gray-600 dark:text-gray-400">
                Free during beta. No credit card required.
              </p>
            </div>

            <div className="max-w-lg mx-auto">
              <div className="relative">
                <div className="absolute -inset-1 bg-gradient-to-r from-indigo-500 to-purple-600 rounded-2xl blur opacity-25" />
                <div className="relative bg-white dark:bg-gray-800 rounded-2xl shadow-xl p-8">
                  <div className="flex items-center justify-between mb-6">
                    <div>
                      <h3 className="text-2xl font-bold text-gray-900 dark:text-white">Beta Access</h3>
                      <p className="text-gray-500 dark:text-gray-400">Everything included</p>
                    </div>
                    <div className="text-right">
                      <div className="text-4xl font-bold text-gray-900 dark:text-white">$0</div>
                      <div className="text-sm text-gray-500 dark:text-gray-400">during beta</div>
                    </div>
                  </div>

                  <ul className="space-y-4 mb-8">
                    {[
                      'Unlimited documents',
                      'AI writing assistance',
                      'PDF source upload',
                      'Ask-Project queries',
                      'Citation verification',
                      'All export formats',
                      'Real-time collaboration',
                    ].map((feature, index) => (
                      <li key={index} className="flex items-center gap-3">
                        <svg className="w-5 h-5 text-green-500 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                          <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                        </svg>
                        <span className="text-gray-700 dark:text-gray-300">{feature}</span>
                      </li>
                    ))}
                  </ul>

                  <Link
                    href="/signup"
                    className="block w-full text-center px-6 py-4 rounded-xl text-base font-semibold text-white bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 shadow-lg transition-all"
                  >
                    Get started free
                  </Link>
                </div>
              </div>
            </div>
          </div>
        </section>

        {/* Final CTA */}
        <section className="py-24">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="relative overflow-hidden rounded-3xl bg-gradient-to-r from-indigo-500 to-purple-600 px-8 py-16 sm:px-16 sm:py-24">
              <div className="absolute inset-0 bg-[url('/grid.svg')] opacity-10" />
              <div className="relative text-center">
                <h2 className="text-3xl sm:text-4xl font-bold text-white mb-4">
                  Ready to transform your research?
                </h2>
                <p className="text-xl text-indigo-100 mb-8 max-w-2xl mx-auto">
                  Join researchers who are already using AI to write better, faster, and with more confidence.
                </p>
                <Link
                  href="/signup"
                  className="inline-flex items-center px-8 py-4 rounded-xl text-base font-semibold text-indigo-600 bg-white hover:bg-gray-100 shadow-xl transition-all hover:scale-105"
                >
                  Start for free
                  <svg className="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7l5 5m0 0l-5 5m5-5H6" />
                  </svg>
                </Link>
              </div>
            </div>
          </div>
        </section>
      </main>

      {/* Footer */}
      <footer className="border-t border-gray-200 dark:border-gray-800 py-12">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex flex-col md:flex-row justify-between items-center gap-6">
            <div className="flex items-center gap-2">
              <div className="w-8 h-8 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg flex items-center justify-center">
                <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                </svg>
              </div>
              <span className="text-lg font-bold text-gray-900 dark:text-white">ResearchBase</span>
            </div>
            <div className="flex items-center gap-8 text-sm text-gray-500 dark:text-gray-400">
              <a href="#" className="hover:text-gray-900 dark:hover:text-white transition-colors">Privacy</a>
              <a href="#" className="hover:text-gray-900 dark:hover:text-white transition-colors">Terms</a>
              <a href="mailto:hello@researchbase.pro" className="hover:text-gray-900 dark:hover:text-white transition-colors">Contact</a>
            </div>
            <div className="text-sm text-gray-500 dark:text-gray-400">
              &copy; 2025 ResearchBase. All rights reserved.
            </div>
          </div>
        </div>
      </footer>
    </div>
  )
}
</file>

<file path="app/src/components/editor/EditorToolbar.tsx">
'use client'

import { Editor } from '@tiptap/react'
import { useCallback } from 'react'

interface EditorToolbarProps {
  editor: Editor
  onCitationClick?: () => void
}

interface ToolbarButtonProps {
  onClick: () => void
  isActive?: boolean
  disabled?: boolean
  children: React.ReactNode
  title?: string
}

function ToolbarButton({ onClick, isActive, disabled, children, title }: ToolbarButtonProps) {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      title={title}
      className={`p-2 rounded hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors ${
        isActive ? 'bg-gray-200 dark:bg-gray-700 text-blue-600' : 'text-gray-600 dark:text-gray-400'
      } ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
    >
      {children}
    </button>
  )
}

function Divider() {
  return <div className="w-px h-6 bg-gray-200 dark:bg-gray-700 mx-1" />
}

export function EditorToolbar({ editor, onCitationClick }: EditorToolbarProps) {
  const setLink = useCallback(() => {
    const previousUrl = editor.getAttributes('link').href
    const url = window.prompt('URL', previousUrl)

    if (url === null) {
      return
    }

    if (url === '') {
      editor.chain().focus().extendMarkRange('link').unsetLink().run()
      return
    }

    editor.chain().focus().extendMarkRange('link').setLink({ href: url }).run()
  }, [editor])

  return (
    <div className="flex flex-wrap items-center gap-1 px-3 py-2 border-b border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800">
      {/* Text formatting */}
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleBold().run()}
        isActive={editor.isActive('bold')}
        title="Bold (Cmd+B)"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 4h8a4 4 0 014 4 4 4 0 01-4 4H6z" />
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 12h9a4 4 0 014 4 4 4 0 01-4 4H6z" />
        </svg>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleItalic().run()}
        isActive={editor.isActive('italic')}
        title="Italic (Cmd+I)"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 4h4m-2 0v16m-4 0h8" transform="skewX(-10)" />
        </svg>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleUnderline().run()}
        isActive={editor.isActive('underline')}
        title="Underline (Cmd+U)"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 4v7a5 5 0 0010 0V4M5 20h14" />
        </svg>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleStrike().run()}
        isActive={editor.isActive('strike')}
        title="Strikethrough"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 12H7m5-8a4 4 0 014 4M12 20a4 4 0 01-4-4" />
        </svg>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleHighlight().run()}
        isActive={editor.isActive('highlight')}
        title="Highlight"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
        </svg>
      </ToolbarButton>

      <Divider />

      {/* Headings */}
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}
        isActive={editor.isActive('heading', { level: 1 })}
        title="Heading 1"
      >
        <span className="text-sm font-bold">H1</span>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
        isActive={editor.isActive('heading', { level: 2 })}
        title="Heading 2"
      >
        <span className="text-sm font-bold">H2</span>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleHeading({ level: 3 }).run()}
        isActive={editor.isActive('heading', { level: 3 })}
        title="Heading 3"
      >
        <span className="text-sm font-bold">H3</span>
      </ToolbarButton>

      <Divider />

      {/* Lists */}
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleBulletList().run()}
        isActive={editor.isActive('bulletList')}
        title="Bullet List"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
        </svg>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleOrderedList().run()}
        isActive={editor.isActive('orderedList')}
        title="Numbered List"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 8h10M7 12h10M7 16h10M3 8h.01M3 12h.01M3 16h.01" />
        </svg>
      </ToolbarButton>

      <Divider />

      {/* Block elements */}
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleBlockquote().run()}
        isActive={editor.isActive('blockquote')}
        title="Quote"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
        </svg>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleCodeBlock().run()}
        isActive={editor.isActive('codeBlock')}
        title="Code Block"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
        </svg>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().setHorizontalRule().run()}
        title="Horizontal Rule"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 12H4" />
        </svg>
      </ToolbarButton>

      <Divider />

      {/* Link */}
      <ToolbarButton
        onClick={setLink}
        isActive={editor.isActive('link')}
        title="Add Link"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
        </svg>
      </ToolbarButton>

      {/* Citation */}
      {onCitationClick && (
        <ToolbarButton
          onClick={onCitationClick}
          isActive={editor.isActive('citation')}
          title="Add Citation"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
        </ToolbarButton>
      )}

      <Divider />

      {/* Alignment */}
      <ToolbarButton
        onClick={() => editor.chain().focus().setTextAlign('left').run()}
        isActive={editor.isActive({ textAlign: 'left' })}
        title="Align Left"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h10M4 18h14" />
        </svg>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().setTextAlign('center').run()}
        isActive={editor.isActive({ textAlign: 'center' })}
        title="Align Center"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M7 12h10M5 18h14" />
        </svg>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().setTextAlign('right').run()}
        isActive={editor.isActive({ textAlign: 'right' })}
        title="Align Right"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M10 12h10M6 18h14" />
        </svg>
      </ToolbarButton>

      <Divider />

      {/* Undo/Redo */}
      <ToolbarButton
        onClick={() => editor.chain().focus().undo().run()}
        disabled={!editor.can().undo()}
        title="Undo (Cmd+Z)"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
        </svg>
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().redo().run()}
        disabled={!editor.can().redo()}
        title="Redo (Cmd+Shift+Z)"
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 10h-10a8 8 0 00-8 8v2M21 10l-6 6m6-6l-6-6" />
        </svg>
      </ToolbarButton>
    </div>
  )
}
</file>

<file path="app/src/components/help/KeyboardShortcutsHelp.tsx">
'use client'

import { useState, useEffect } from 'react'

interface ShortcutGroup {
  title: string
  shortcuts: {
    keys: string[]
    description: string
  }[]
}

const SHORTCUT_GROUPS: ShortcutGroup[] = [
  {
    title: 'Navigation',
    shortcuts: [
      { keys: ['Cmd/Ctrl', 'K'], description: 'Open Ask Project' },
      { keys: ['Cmd/Ctrl', 'Shift', 'E'], description: 'Find Evidence' },
      { keys: ['Cmd/Ctrl', 'Shift', 'C'], description: 'Open Citations panel' },
      { keys: ['Cmd/Ctrl', 'Shift', 'A'], description: 'Open Arguments panel' },
      { keys: ['Cmd/Ctrl', 'Shift', 'Y'], description: 'Open Safety panel' },
      { keys: ['Esc'], description: 'Close panels' },
    ]
  },
  {
    title: 'Document',
    shortcuts: [
      { keys: ['Cmd/Ctrl', 'S'], description: 'Save document' },
      { keys: ['/'], description: 'Open slash commands (in editor)' },
    ]
  },
  {
    title: 'Formatting',
    shortcuts: [
      { keys: ['Cmd/Ctrl', 'B'], description: 'Bold' },
      { keys: ['Cmd/Ctrl', 'I'], description: 'Italic' },
      { keys: ['Cmd/Ctrl', 'U'], description: 'Underline' },
      { keys: ['Cmd/Ctrl', 'Shift', 'X'], description: 'Strikethrough' },
    ]
  }
]

interface KeyboardShortcutsHelpProps {
  isOpen: boolean
  onClose: () => void
}

export function KeyboardShortcutsHelp({ isOpen, onClose }: KeyboardShortcutsHelpProps) {
  // Close on escape
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        onClose()
      }
    }
    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [isOpen, onClose])

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Backdrop */}
      <div
        className="absolute inset-0 bg-black/50 backdrop-blur-sm"
        onClick={onClose}
      />

      {/* Modal */}
      <div className="relative bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-lg w-full mx-4 overflow-hidden">
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-2">
            <svg className="w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
            </svg>
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
              Keyboard Shortcuts
            </h2>
          </div>
          <button
            onClick={onClose}
            className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="p-6 max-h-[60vh] overflow-y-auto space-y-6">
          {SHORTCUT_GROUPS.map((group) => (
            <div key={group.title}>
              <h3 className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-3">
                {group.title}
              </h3>
              <div className="space-y-2">
                {group.shortcuts.map((shortcut, index) => (
                  <div
                    key={index}
                    className="flex items-center justify-between py-2"
                  >
                    <span className="text-sm text-gray-700 dark:text-gray-300">
                      {shortcut.description}
                    </span>
                    <div className="flex items-center gap-1">
                      {shortcut.keys.map((key, keyIndex) => (
                        <span key={keyIndex}>
                          <kbd className="px-2 py-1 text-xs font-mono bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded border border-gray-200 dark:border-gray-600">
                            {key}
                          </kbd>
                          {keyIndex < shortcut.keys.length - 1 && (
                            <span className="text-gray-400 mx-1">+</span>
                          )}
                        </span>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>

        {/* Footer */}
        <div className="px-6 py-3 bg-gray-50 dark:bg-gray-700/50 border-t border-gray-200 dark:border-gray-700">
          <p className="text-xs text-gray-500 dark:text-gray-400 text-center">
            Press <kbd className="px-1.5 py-0.5 text-xs font-mono bg-gray-100 dark:bg-gray-700 rounded">?</kbd> anywhere to toggle this help
          </p>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/sources/page.tsx">
'use client'

import { useState, useEffect, useCallback } from 'react'
import Link from 'next/link'
import { PDFViewerModal } from '@/components/pdf'

interface Source {
  id: string
  title: string
  source_type: string
  file_size: number
  page_count: number | null
  chunk_count: number | null
  processing_status: string
  created_at: string
  url: string
}

export default function SourcesPage() {
  const [sources, setSources] = useState<Source[]>([])
  const [loading, setLoading] = useState(true)
  const [uploading, setUploading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [selectedPDF, setSelectedPDF] = useState<Source | null>(null)

  const fetchSources = useCallback(async () => {
    try {
      const response = await fetch('/api/sources')
      const data = await response.json()

      if (data.error) {
        throw new Error(data.error)
      }

      setSources(data.sources || [])
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load sources')
    } finally {
      setLoading(false)
    }
  }, [])

  useEffect(() => {
    fetchSources()
  }, [fetchSources])

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    setUploading(true)
    setError(null)

    try {
      const formData = new FormData()
      formData.append('file', file)

      const response = await fetch('/api/sources/upload', {
        method: 'POST',
        body: formData,
      })

      const data = await response.json()

      if (data.error) {
        throw new Error(data.error)
      }

      // Trigger processing
      await fetch(`/api/sources/${data.source.id}/process`, {
        method: 'POST',
      })

      // Refresh sources list
      await fetchSources()

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to upload file')
    } finally {
      setUploading(false)
      // Reset file input
      e.target.value = ''
    }
  }

  const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return bytes + ' B'
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB'
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB'
  }

  const getStatusBadge = (status: string) => {
    const styles: Record<string, string> = {
      pending: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200',
      processing: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200',
      completed: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200',
      failed: 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200',
    }

    return (
      <span className={`px-2 py-1 text-xs rounded-full ${styles[status] || styles.pending}`}>
        {status}
      </span>
    )
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Sources
          </h1>
          <p className="text-gray-600 dark:text-gray-400 mt-1">
            Upload and manage your research PDFs
          </p>
        </div>

        <div className="flex gap-3">
          <Link
            href="/sources/import"
            className="inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700"
          >
            <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
            </svg>
            Import
          </Link>
          <label className="relative">
            <input
              type="file"
              accept=".pdf"
              onChange={handleFileUpload}
              disabled={uploading}
              className="absolute inset-0 w-full h-full opacity-0 cursor-pointer disabled:cursor-not-allowed"
            />
            <span className={`inline-flex items-center px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 ${uploading ? 'opacity-50 cursor-not-allowed' : ''}`}>
            {uploading ? (
              <>
                <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                </svg>
                Uploading...
              </>
            ) : (
              <>
                <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
                Upload PDF
              </>
            )}
            </span>
          </label>
        </div>
      </div>

      {error && (
        <div className="bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 p-4 rounded-lg">
          {error}
        </div>
      )}

      {loading ? (
        <div className="text-center py-12">
          <div className="animate-spin h-8 w-8 border-4 border-blue-600 border-t-transparent rounded-full mx-auto" />
          <p className="mt-4 text-gray-500">Loading sources...</p>
        </div>
      ) : sources.length === 0 ? (
        <div className="text-center py-12 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <svg className="w-12 h-12 mx-auto text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
          <h3 className="mt-4 text-lg font-medium text-gray-900 dark:text-white">
            No sources yet
          </h3>
          <p className="mt-2 text-gray-500 dark:text-gray-400">
            Upload your first PDF to start building your knowledge base
          </p>
        </div>
      ) : (
        <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 overflow-hidden">
          <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
            <thead className="bg-gray-50 dark:bg-gray-900">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Title
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Size
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Pages
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Chunks
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Status
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Actions
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
              {sources.map((source) => (
                <tr key={source.id} className="hover:bg-gray-50 dark:hover:bg-gray-900/50">
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="flex items-center">
                      <svg className="w-8 h-8 text-red-500 mr-3" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z" />
                        <path d="M14 2v6h6M16 13H8M16 17H8M10 9H8" stroke="white" strokeWidth="1" fill="none" />
                      </svg>
                      <div>
                        <div className="text-sm font-medium text-gray-900 dark:text-white">
                          {source.title}
                        </div>
                        <div className="text-sm text-gray-500 dark:text-gray-400">
                          {new Date(source.created_at).toLocaleDateString()}
                        </div>
                      </div>
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                    {formatFileSize(source.file_size)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                    {source.page_count || '-'}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                    {source.chunk_count || '-'}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    {getStatusBadge(source.processing_status)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium space-x-3">
                    <button
                      onClick={() => setSelectedPDF(source)}
                      className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                    >
                      View
                    </button>
                    <a
                      href={source.url}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                    >
                      Download
                    </a>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {/* Back to dashboard */}
      <div className="pt-4">
        <Link
          href="/dashboard"
          className="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm"
        >
          &larr; Back to Dashboard
        </Link>
      </div>

      {/* PDF Viewer Modal */}
      {selectedPDF && (
        <PDFViewerModal
          isOpen={!!selectedPDF}
          url={selectedPDF.url}
          title={selectedPDF.title}
          onClose={() => setSelectedPDF(null)}
        />
      )}
    </div>
  )
}
</file>

<file path="app/src/app/api/sources/[id]/process/route.ts">
import { createClient } from '@/lib/supabase/server'
import { generateEmbeddings } from '@/lib/voyage'
import { NextRequest, NextResponse } from 'next/server'
import * as pdfjsLib from 'pdfjs-dist/legacy/build/pdf.mjs'

// Initialize PDF.js without worker for serverless environment
pdfjsLib.GlobalWorkerOptions.workerSrc = ''

/**
 * Extract text from a PDF using PDF.js
 */
async function extractTextFromPDF(buffer: ArrayBuffer): Promise<{ text: string; numPages: number; pageTexts: string[] }> {
  try {
    // Load the PDF document
    const loadingTask = pdfjsLib.getDocument({
      data: new Uint8Array(buffer),
      useSystemFonts: true,
    })

    const pdf = await loadingTask.promise
    const numPages = pdf.numPages
    const pageTexts: string[] = []

    // Extract text from each page
    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
      const page = await pdf.getPage(pageNum)
      const textContent = await page.getTextContent()

      // Combine text items, preserving some structure
      let lastY: number | null = null
      let pageText = ''

      for (const item of textContent.items) {
        if ('str' in item) {
          const textItem = item as { str: string; transform: number[] }
          const currentY = textItem.transform[5]

          // Add newline if we've moved to a new line (Y position changed significantly)
          if (lastY !== null && Math.abs(currentY - lastY) > 5) {
            pageText += '\n'
          } else if (pageText && !pageText.endsWith(' ') && !pageText.endsWith('\n')) {
            pageText += ' '
          }

          pageText += textItem.str
          lastY = currentY
        }
      }

      pageTexts.push(pageText.trim())
    }

    // Combine all pages with clear page breaks
    const text = pageTexts
      .map((pageText, idx) => `[Page ${idx + 1}]\n${pageText}`)
      .join('\n\n')

    return { text, numPages, pageTexts }
  } catch (error) {
    console.error('PDF extraction error:', error)
    throw new Error(`Failed to extract text from PDF: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

interface ChunkWithPage {
  content: string
  pageNumber: number
}

/**
 * Chunk text by pages, preserving page information
 */
function chunkTextByPages(pageTexts: string[], maxChunkSize: number = 1000): ChunkWithPage[] {
  const chunks: ChunkWithPage[] = []

  for (let pageNum = 0; pageNum < pageTexts.length; pageNum++) {
    const pageText = pageTexts[pageNum]
    if (!pageText.trim()) continue

    const paragraphs = pageText.split(/\n\n+/)
    let currentChunk = ''

    for (const paragraph of paragraphs) {
      const trimmed = paragraph.trim()
      if (!trimmed || trimmed.length < 20) continue

      if (currentChunk.length + trimmed.length > maxChunkSize) {
        if (currentChunk.trim().length > 50) {
          chunks.push({ content: currentChunk.trim(), pageNumber: pageNum + 1 })
        }
        // Handle long paragraphs
        if (trimmed.length > maxChunkSize) {
          const sentences = trimmed.split(/(?<=[.!?])\s+/)
          let sentenceChunk = ''
          for (const sentence of sentences) {
            if (sentenceChunk.length + sentence.length > maxChunkSize) {
              if (sentenceChunk.trim().length > 50) {
                chunks.push({ content: sentenceChunk.trim(), pageNumber: pageNum + 1 })
              }
              sentenceChunk = sentence
            } else {
              sentenceChunk += ' ' + sentence
            }
          }
          if (sentenceChunk.trim().length > 50) {
            chunks.push({ content: sentenceChunk.trim(), pageNumber: pageNum + 1 })
          }
          currentChunk = ''
        } else {
          currentChunk = trimmed
        }
      } else {
        currentChunk += (currentChunk ? '\n\n' : '') + trimmed
      }
    }

    // Push remaining content from this page
    if (currentChunk.trim().length > 50) {
      chunks.push({ content: currentChunk.trim(), pageNumber: pageNum + 1 })
    }
  }

  return chunks
}

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const supabase = await createClient()

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get source record
    const { data: source, error: sourceError } = await supabase
      .from('sources')
      .select('*')
      .eq('id', id)
      .single()

    if (sourceError || !source) {
      return NextResponse.json({ error: 'Source not found' }, { status: 404 })
    }

    // Update status to processing
    await supabase
      .from('sources')
      .update({ processing_status: 'processing' })
      .eq('id', id)

    try {
      // Download PDF from storage
      const { data: fileData, error: downloadError } = await supabase.storage
        .from('sources')
        .download(source.storage_path)

      if (downloadError || !fileData) {
        throw new Error('Failed to download PDF')
      }

      // Extract text from PDF
      const buffer = await fileData.arrayBuffer()
      const { numPages, pageTexts } = await extractTextFromPDF(buffer)

      // Chunk the text by pages
      const chunks = chunkTextByPages(pageTexts)

      if (chunks.length === 0) {
        throw new Error('No text content extracted from PDF')
      }

      // Generate embeddings for all chunks
      const chunkContents = chunks.map(c => c.content)
      const embeddings = await generateEmbeddings(chunkContents)

      // Store chunks with embeddings and page numbers
      const chunkRecords = chunks.map((chunk, index) => ({
        source_id: id,
        content: chunk.content,
        chunk_index: index,
        page_number: chunk.pageNumber,
        embedding: embeddings[index],
      }))

      // Insert chunks in batches
      const BATCH_SIZE = 50
      for (let i = 0; i < chunkRecords.length; i += BATCH_SIZE) {
        const batch = chunkRecords.slice(i, i + BATCH_SIZE)
        const { error: insertError } = await supabase
          .from('source_chunks')
          .insert(batch)

        if (insertError) {
          console.error('Error inserting chunks:', insertError)
          throw new Error('Failed to store chunks')
        }
      }

      // Update source with metadata
      await supabase
        .from('sources')
        .update({
          processing_status: 'completed',
          page_count: numPages,
          chunk_count: chunks.length,
        })
        .eq('id', id)

      return NextResponse.json({
        success: true,
        source_id: id,
        chunks_created: chunks.length,
        pages: numPages,
      })

    } catch (processingError) {
      console.error('Processing error:', processingError)

      // Update status to failed
      await supabase
        .from('sources')
        .update({
          processing_status: 'failed',
          processing_error: processingError instanceof Error ? processingError.message : 'Unknown error',
        })
        .eq('id', id)

      throw processingError
    }

  } catch (error) {
    console.error('Process handler error:', error)
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Internal server error'
    }, { status: 500 })
  }
}
</file>

<file path="app/src/app/api/workspaces/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'

/**
 * GET /api/workspaces - List user's workspaces
 */
export async function GET() {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get workspaces where user is a member or owner
    const { data: workspaces, error } = await supabase
      .from('workspaces')
      .select(`
        *,
        workspace_members!inner (
          role,
          joined_at
        )
      `)
      .eq('workspace_members.user_id', user.id)
      .order('created_at', { ascending: false })

    if (error) {
      console.error('Error fetching workspaces:', error)
      return NextResponse.json({ error: 'Failed to fetch workspaces' }, { status: 500 })
    }

    // Transform to include user's role
    const result = workspaces.map(w => ({
      id: w.id,
      name: w.name,
      slug: w.slug,
      owner_id: w.owner_id,
      created_at: w.created_at,
      updated_at: w.updated_at,
      role: w.workspace_members[0]?.role,
      joined_at: w.workspace_members[0]?.joined_at,
    }))

    return NextResponse.json({ workspaces: result })

  } catch (error) {
    console.error('Workspaces handler error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * POST /api/workspaces - Create a new workspace
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { name, slug } = body

    if (!name) {
      return NextResponse.json({ error: 'Name is required' }, { status: 400 })
    }

    // Generate slug if not provided
    const workspaceSlug = slug || name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '')

    // Create workspace
    const { data: workspace, error: createError } = await supabase
      .from('workspaces')
      .insert({
        name,
        slug: workspaceSlug,
        owner_id: user.id,
      })
      .select()
      .single()

    if (createError) {
      console.error('Error creating workspace:', createError)
      if (createError.code === '23505') {
        return NextResponse.json({ error: 'Workspace slug already exists' }, { status: 409 })
      }
      return NextResponse.json({ error: 'Failed to create workspace' }, { status: 500 })
    }

    // Add creator as owner member
    const { error: memberError } = await supabase
      .from('workspace_members')
      .insert({
        workspace_id: workspace.id,
        user_id: user.id,
        role: 'owner',
        joined_at: new Date().toISOString(),
      })

    if (memberError) {
      console.error('Error adding owner member:', memberError)
      // Cleanup: delete the workspace
      await supabase.from('workspaces').delete().eq('id', workspace.id)
      return NextResponse.json({ error: 'Failed to create workspace' }, { status: 500 })
    }

    // Log activity (don't fail workspace creation if logging fails)
    void (async () => {
      try {
        await supabase.rpc('log_activity', {
          p_action: 'workspace.create',
          p_workspace_id: workspace.id,
          p_target_type: 'workspace',
          p_target_id: workspace.id,
          p_details: { name: workspace.name },
        })
      } catch (err) {
        console.error('Failed to log activity:', err)
      }
    })()

    return NextResponse.json({
      workspace: {
        ...workspace,
        role: 'owner',
      }
    }, { status: 201 })

  } catch (error) {
    console.error('Create workspace error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/src/components/editor/Editor.tsx">
'use client'

import { useState, useCallback, useRef, useEffect } from 'react'
import { useEditor, EditorContent, Editor as TiptapEditor } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import Placeholder from '@tiptap/extension-placeholder'
import Link from '@tiptap/extension-link'
import Underline from '@tiptap/extension-underline'
import Highlight from '@tiptap/extension-highlight'
import TextAlign from '@tiptap/extension-text-align'
import { EditorToolbar } from './EditorToolbar'
import { Citation } from './extensions/Citation'
import { AISpan } from './extensions/AISpan'
import { SlashCommand } from './extensions/SlashCommand'

interface EditorProps {
  content?: string
  onChange?: (content: string) => void
  placeholder?: string
  editable?: boolean
  documentId?: string
  onCitationClick?: () => void
}

export function Editor({
  content = '',
  onChange,
  placeholder = 'Start writing...',
  editable = true,
  documentId,
  onCitationClick
}: EditorProps) {
  const [isAIProcessing, setIsAIProcessing] = useState(false)
  const [aiError, setAIError] = useState<string | null>(null)
  const editorRef = useRef<TiptapEditor | null>(null)

  const handleAICommand = useCallback(async (action: string, text: string) => {
    if (!text.trim()) {
      setAIError('Please select some text or write content first')
      setTimeout(() => setAIError(null), 3000)
      return
    }

    setIsAIProcessing(true)
    setAIError(null)

    try {
      const response = await fetch('/api/ai/edit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action,
          text: text.trim(),
          documentId
        })
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'AI request failed')
      }

      if (data.result && editorRef.current) {
        // Insert the AI result at cursor position or replace selection
        const currentEditor = editorRef.current
        const { from, to } = currentEditor.state.selection

        if (from !== to) {
          // Replace selection
          currentEditor.chain().focus().deleteRange({ from, to }).insertContent(data.result).run()
        } else {
          // Insert at cursor with AI span marking
          currentEditor.chain().focus().insertContent(
            `<span data-ai-span="true" data-ai-job-id="${Date.now()}" data-ai-model="claude-sonnet-4-20250514" data-ai-action="${action}" data-ai-timestamp="${new Date().toISOString()}">${data.result}</span>`
          ).run()
        }
      }
    } catch (error) {
      console.error('AI command error:', error)
      setAIError(error instanceof Error ? error.message : 'AI request failed')
      setTimeout(() => setAIError(null), 5000)
    } finally {
      setIsAIProcessing(false)
    }
  }, [documentId])

  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        heading: {
          levels: [1, 2, 3],
        },
      }),
      Placeholder.configure({
        placeholder,
      }),
      Link.configure({
        openOnClick: false,
        HTMLAttributes: {
          class: 'text-blue-600 hover:text-blue-800 underline cursor-pointer',
        },
      }),
      Underline,
      Highlight.configure({
        multicolor: true,
      }),
      TextAlign.configure({
        types: ['heading', 'paragraph'],
      }),
      Citation,
      AISpan,
      SlashCommand.configure({
        onCommand: handleAICommand
      }),
    ],
    content,
    editable,
    onUpdate: ({ editor }) => {
      onChange?.(editor.getHTML())
    },
    editorProps: {
      attributes: {
        class: 'prose prose-sm sm:prose lg:prose-lg dark:prose-invert max-w-none focus:outline-none min-h-[300px] px-4 py-3',
      },
    },
  })

  // Keep ref in sync with editor
  useEffect(() => {
    editorRef.current = editor
  }, [editor])

  if (!editor) {
    return null
  }

  return (
    <div className="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden bg-white dark:bg-gray-900 relative">
      <EditorToolbar editor={editor} onCitationClick={onCitationClick} />
      <EditorContent editor={editor} />

      {/* AI Processing Indicator */}
      {isAIProcessing && (
        <div className="absolute bottom-4 right-4 flex items-center gap-2 px-3 py-2 bg-blue-600 text-white text-sm rounded-lg shadow-lg">
          <svg className="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
          </svg>
          AI is writing...
        </div>
      )}

      {/* AI Error Message */}
      {aiError && (
        <div className="absolute bottom-4 right-4 px-3 py-2 bg-red-600 text-white text-sm rounded-lg shadow-lg">
          {aiError}
        </div>
      )}

      {/* Slash Command Hint */}
      {!isAIProcessing && (
        <div className="absolute bottom-2 left-4 text-xs text-gray-400 dark:text-gray-500">
          Type / for AI commands
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/dashboard/page.tsx">
import { createClient } from '@/lib/supabase/server'
import Link from 'next/link'

export default async function DashboardPage() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  // Fetch user's workspaces
  const { data: workspaces } = await supabase
    .from('workspaces')
    .select(`
      *,
      workspace_members!inner(role)
    `)
    .order('created_at', { ascending: false })

  return (
    <div className="space-y-8">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Welcome back
          </h1>
          <p className="text-gray-600 dark:text-gray-400 mt-1">
            {user?.user_metadata?.full_name || user?.email}
          </p>
        </div>
        <Link
          href="/workspace/new"
          className="inline-flex items-center px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
        >
          <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
          </svg>
          New Workspace
        </Link>
      </div>

      {/* Workspaces Grid */}
      <div>
        <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
          Your Workspaces
        </h2>

        {workspaces && workspaces.length > 0 ? (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {workspaces.map((workspace) => (
              <Link
                key={workspace.id}
                href={`/workspace/${workspace.id}`}
                className="block p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 hover:border-blue-500 dark:hover:border-blue-500 transition-colors"
              >
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  {workspace.name}
                </h3>
                <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                  {workspace.workspace_members?.[0]?.role || 'member'}
                </p>
              </Link>
            ))}
          </div>
        ) : (
          <div className="text-center py-12 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
            <svg className="w-12 h-12 mx-auto text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
            </svg>
            <h3 className="mt-4 text-lg font-medium text-gray-900 dark:text-white">
              No workspaces yet
            </h3>
            <p className="mt-2 text-gray-500 dark:text-gray-400">
              Create your first workspace to get started
            </p>
            <Link
              href="/workspace/new"
              className="mt-4 inline-flex items-center px-4 py-2 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
            >
              Create Workspace
            </Link>
          </div>
        )}
      </div>

      {/* Quick Actions */}
      <div>
        <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
          Quick Actions
        </h2>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          <Link
            href="/documents/demo"
            className="block p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 hover:border-blue-500 dark:hover:border-blue-500 transition-colors"
          >
            <div className="flex items-center">
              <div className="w-10 h-10 bg-blue-100 dark:bg-blue-900 rounded-lg flex items-center justify-center">
                <svg className="w-5 h-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                </svg>
              </div>
              <div className="ml-4">
                <h3 className="text-sm font-medium text-gray-900 dark:text-white">
                  Try the Editor
                </h3>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                  Explore the rich text editor
                </p>
              </div>
            </div>
          </Link>

          <Link
            href="/documents/new"
            className="block p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 hover:border-blue-500 dark:hover:border-blue-500 transition-colors"
          >
            <div className="flex items-center">
              <div className="w-10 h-10 bg-green-100 dark:bg-green-900 rounded-lg flex items-center justify-center">
                <svg className="w-5 h-5 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
              </div>
              <div className="ml-4">
                <h3 className="text-sm font-medium text-gray-900 dark:text-white">
                  New Document
                </h3>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                  Start a fresh document
                </p>
              </div>
            </div>
          </Link>

          <Link
            href="/sources"
            className="block p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 hover:border-blue-500 dark:hover:border-blue-500 transition-colors"
          >
            <div className="flex items-center">
              <div className="w-10 h-10 bg-purple-100 dark:bg-purple-900 rounded-lg flex items-center justify-center">
                <svg className="w-5 h-5 text-purple-600 dark:text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
              </div>
              <div className="ml-4">
                <h3 className="text-sm font-medium text-gray-900 dark:text-white">
                  Upload PDF
                </h3>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                  Add sources to your library
                </p>
              </div>
            </div>
          </Link>

          <Link
            href="/automations"
            className="block p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 hover:border-purple-500 dark:hover:border-purple-500 transition-colors"
          >
            <div className="flex items-center">
              <div className="w-10 h-10 bg-amber-100 dark:bg-amber-900 rounded-lg flex items-center justify-center">
                <svg className="w-5 h-5 text-amber-600 dark:text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
              </div>
              <div className="ml-4">
                <h3 className="text-sm font-medium text-gray-900 dark:text-white">
                  Automations
                </h3>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                  Configure workflow schedules
                </p>
              </div>
            </div>
          </Link>
        </div>
      </div>

      {/* Quick Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="text-2xl font-bold text-gray-900 dark:text-white">
            {workspaces?.length || 0}
          </div>
          <div className="text-sm text-gray-500 dark:text-gray-400">
            Workspaces
          </div>
        </div>
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="text-2xl font-bold text-gray-900 dark:text-white">
            0
          </div>
          <div className="text-sm text-gray-500 dark:text-gray-400">
            Documents
          </div>
        </div>
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="text-2xl font-bold text-gray-900 dark:text-white">
            0
          </div>
          <div className="text-sm text-gray-500 dark:text-gray-400">
            Sources
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/src/app/(dashboard)/documents/[id]/page.tsx">
'use client'

import { useState, useEffect, use, useRef, useMemo } from 'react'
import { Editor } from '@/components/editor'
import { AskProject } from '@/components/ask/AskProject'
import { CitationDialog } from '@/components/editor/CitationDialog'
import { CitationPanel } from '@/components/citations/CitationPanel'
import { ArgumentPanel } from '@/components/arguments/ArgumentPanel'
import { SafetyPanel } from '@/components/safety/SafetyPanel'
import { EvidencePanel } from '@/components/evidence/EvidencePanel'
import { KeyboardShortcutsHelp } from '@/components/help/KeyboardShortcutsHelp'
import { createClient } from '@/lib/supabase/client'
import { useKeyboardShortcuts } from '@/hooks/useKeyboardShortcuts'
import Link from 'next/link'

interface DocumentPageProps {
  params: Promise<{ id: string }>
}

interface Citation {
  id: string
  text: string
  sourceId: string
  sourceTitle: string
  pageNumber?: number
}

export default function DocumentPage({ params }: DocumentPageProps) {
  const { id } = use(params)
  const [document, setDocument] = useState<{
    id: string
    title: string
    content: string
    project_id?: string
  } | null>(null)
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [lastSaved, setLastSaved] = useState<Date | null>(null)
  const [askPanelOpen, setAskPanelOpen] = useState(false)
  const [citationDialogOpen, setCitationDialogOpen] = useState(false)
  const [citationPanelOpen, setCitationPanelOpen] = useState(false)
  const [argumentPanelOpen, setArgumentPanelOpen] = useState(false)
  const [safetyPanelOpen, setSafetyPanelOpen] = useState(false)
  const [evidencePanelOpen, setEvidencePanelOpen] = useState(false)
  const [citations, setCitations] = useState<Citation[]>([])
  const [selectedText, setSelectedText] = useState('')
  const [shortcutsHelpOpen, setShortcutsHelpOpen] = useState(false)
  const editorRef = useRef<HTMLDivElement>(null)

  // Keyboard shortcuts
  const shortcuts = useMemo(() => [
    {
      key: 'k',
      ctrl: true,
      handler: () => setAskPanelOpen(true),
      description: 'Open Ask Project'
    },
    {
      key: 's',
      ctrl: true,
      handler: () => handleSave(),
      description: 'Save document'
    },
    {
      key: 'c',
      ctrl: true,
      shift: true,
      handler: () => setCitationPanelOpen(true),
      description: 'Open Citations'
    },
    {
      key: 'a',
      ctrl: true,
      shift: true,
      handler: () => setArgumentPanelOpen(true),
      description: 'Open Arguments'
    },
    {
      key: 'y',
      ctrl: true,
      shift: true,
      handler: () => setSafetyPanelOpen(true),
      description: 'Open Safety'
    },
    {
      key: 'e',
      ctrl: true,
      shift: true,
      handler: () => setEvidencePanelOpen(true),
      description: 'Open Evidence'
    },
    {
      key: 'Escape',
      handler: () => {
        setAskPanelOpen(false)
        setCitationPanelOpen(false)
        setArgumentPanelOpen(false)
        setSafetyPanelOpen(false)
        setEvidencePanelOpen(false)
        setCitationDialogOpen(false)
        setShortcutsHelpOpen(false)
      },
      description: 'Close panels'
    },
    {
      key: '?',
      shift: true,
      handler: () => setShortcutsHelpOpen(prev => !prev),
      description: 'Toggle keyboard shortcuts help'
    }
  ], [])

  useKeyboardShortcuts(shortcuts)

  useEffect(() => {
    async function loadDocument() {
      const supabase = createClient()

      // For now, create a mock document if it doesn't exist
      // Later this will fetch from the database
      if (id === 'new') {
        setDocument({
          id: 'new',
          title: 'Untitled Document',
          content: '<p>Start writing your research...</p>'
        })
      } else {
        // Try to fetch from database
        const { data, error } = await supabase
          .from('documents')
          .select('id, title, content')
          .eq('id', id)
          .single()

        if (error || !data) {
          // Create demo document for testing
          setDocument({
            id,
            title: 'Demo Document',
            content: `
              <h1>Welcome to ResearchBase</h1>
              <p>This is your AI-powered research environment. Start writing and use the toolbar above to format your text.</p>
              <h2>Features</h2>
              <ul>
                <li><strong>Rich text editing</strong> - Format your text with headings, lists, and more</li>
                <li><strong>AI assistance</strong> - Use slash commands to summarize, rewrite, or expand text</li>
                <li><strong>Citations</strong> - Link your claims to source evidence</li>
                <li><strong>Collaboration</strong> - Work together in real-time</li>
              </ul>
              <blockquote>
                <p>"The best research is collaborative research." - ResearchBase</p>
              </blockquote>
              <h2>Getting Started</h2>
              <p>Try using the toolbar above or these keyboard shortcuts:</p>
              <ul>
                <li><code>Cmd+B</code> for <strong>bold</strong></li>
                <li><code>Cmd+I</code> for <em>italic</em></li>
                <li><code>Cmd+U</code> for <u>underline</u></li>
              </ul>
            `
          })
        } else {
          setDocument({
            id: data.id,
            title: data.title,
            content: data.content || ''
          })
        }
      }

      setLoading(false)
    }

    loadDocument()
  }, [id])

  const handleContentChange = async (content: string) => {
    if (!document) return

    setDocument({ ...document, content })

    // Auto-save with debounce would go here
    // For now, just update the state
  }

  const handleSave = async () => {
    if (!document) return

    setSaving(true)

    // Simulate save - in production this would save to Supabase
    await new Promise(resolve => setTimeout(resolve, 500))

    setLastSaved(new Date())
    setSaving(false)
  }

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!document) return
    setDocument({ ...document, title: e.target.value })
  }

  const handleCitationClick = () => {
    // Get selected text from window selection
    const selection = window.getSelection()
    if (selection && selection.toString().trim()) {
      setSelectedText(selection.toString().trim())
    }
    setCitationDialogOpen(true)
  }

  const handleCitationInsert = async (sourceId: string, pageNumber?: number) => {
    // Fetch source title
    const supabase = createClient()
    const { data: source } = await supabase
      .from('sources')
      .select('title')
      .eq('id', sourceId)
      .single()

    const newCitation: Citation = {
      id: `citation-${Date.now()}`,
      text: selectedText || 'Selected text',
      sourceId,
      sourceTitle: source?.title || 'Unknown Source',
      pageNumber
    }

    setCitations(prev => [...prev, newCitation])
    setSelectedText('')
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-gray-500">Loading document...</div>
      </div>
    )
  }

  if (!document) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold text-gray-900 dark:text-white">Document not found</h2>
          <Link href="/dashboard" className="mt-4 text-blue-600 hover:text-blue-500">
            Return to dashboard
          </Link>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      {/* Header */}
      <header className="sticky top-0 z-10 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <div className="max-w-5xl mx-auto px-4 py-3">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <Link
                href="/dashboard"
                className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                </svg>
              </Link>
              <input
                type="text"
                value={document.title}
                onChange={handleTitleChange}
                className="text-lg font-semibold text-gray-900 dark:text-white bg-transparent border-none focus:outline-none focus:ring-0 w-64"
                placeholder="Document title"
              />
            </div>
            <div className="flex items-center space-x-1 sm:space-x-3">
              {lastSaved && (
                <span className="hidden sm:inline text-sm text-gray-500">
                  Saved {lastSaved.toLocaleTimeString()}
                </span>
              )}
              <button
                onClick={() => setEvidencePanelOpen(true)}
                className="p-2 sm:px-3 sm:py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 flex items-center gap-2"
                title="Find Evidence (Ctrl+Shift+E)"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
                <span className="hidden md:inline">Evidence</span>
              </button>
              <button
                onClick={() => setSafetyPanelOpen(true)}
                className="p-2 sm:px-3 sm:py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 flex items-center gap-2"
                title="Safety Assessment (Ctrl+Shift+Y)"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
                </svg>
                <span className="hidden md:inline">Safety</span>
              </button>
              <button
                onClick={() => setArgumentPanelOpen(true)}
                className="p-2 sm:px-3 sm:py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 flex items-center gap-2"
                title="Analyze Arguments (Ctrl+Shift+A)"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                </svg>
                <span className="hidden md:inline">Arguments</span>
              </button>
              <button
                onClick={() => setCitationPanelOpen(true)}
                className="p-2 sm:px-3 sm:py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 flex items-center gap-2"
                title="View Citations (Ctrl+Shift+C)"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                <span className="hidden md:inline">Citations</span>
                {citations.length > 0 && (
                  <span className="bg-purple-600 text-white text-xs rounded-full px-1.5">
                    {citations.length}
                  </span>
                )}
              </button>
              <button
                onClick={() => setAskPanelOpen(true)}
                className="p-2 sm:px-3 sm:py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 flex items-center gap-2"
                title="Ask Project (Cmd/Ctrl+K)"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span className="hidden md:inline">Ask</span>
              </button>
              <button
                onClick={handleSave}
                disabled={saving}
                className="px-2 py-2 sm:px-4 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 disabled:opacity-50"
                title="Save (Cmd/Ctrl+S)"
              >
                {saving ? (
                  <svg className="w-4 h-4 sm:hidden animate-spin" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
                  </svg>
                ) : (
                  <svg className="w-4 h-4 sm:hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                  </svg>
                )}
                <span className="hidden sm:inline">{saving ? 'Saving...' : 'Save'}</span>
              </button>
              <button
                onClick={() => setShortcutsHelpOpen(true)}
                className="p-2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700"
                title="Keyboard shortcuts (Shift+?)"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
              </button>
            </div>
          </div>
        </div>
      </header>

      {/* Editor */}
      <main className="max-w-5xl mx-auto px-4 py-8" ref={editorRef}>
        <Editor
          content={document.content}
          onChange={handleContentChange}
          placeholder="Start writing your research..."
          documentId={document.id}
          onCitationClick={handleCitationClick}
        />
      </main>

      {/* Ask Project Sidebar */}
      <AskProject
        projectId={document.project_id}
        isOpen={askPanelOpen}
        onClose={() => setAskPanelOpen(false)}
      />

      {/* Citation Dialog */}
      <CitationDialog
        isOpen={citationDialogOpen}
        onClose={() => setCitationDialogOpen(false)}
        onInsert={handleCitationInsert}
        projectId={document.project_id}
      />

      {/* Citation Panel */}
      <CitationPanel
        citations={citations}
        documentId={document.id}
        isOpen={citationPanelOpen}
        onClose={() => setCitationPanelOpen(false)}
        onVerify={(citation) => {
          // Update citation with verification
          setCitations(prev =>
            prev.map(c => c.id === citation.id ? citation : c)
          )
        }}
        onJumpTo={(citation) => {
          // For now just close the panel
          // In future, scroll to the citation in the editor
          setCitationPanelOpen(false)
        }}
      />

      {/* Argument Panel */}
      <ArgumentPanel
        documentContent={document.content}
        documentId={document.id}
        isOpen={argumentPanelOpen}
        onClose={() => setArgumentPanelOpen(false)}
      />

      {/* Safety Panel */}
      <SafetyPanel
        documentContent={document.content}
        documentId={document.id}
        projectId={document.project_id}
        isOpen={safetyPanelOpen}
        onClose={() => setSafetyPanelOpen(false)}
      />

      {/* Evidence Panel */}
      <EvidencePanel
        projectId={document.project_id}
        selectedText={selectedText}
        isOpen={evidencePanelOpen}
        onClose={() => setEvidencePanelOpen(false)}
        onInsertCitation={(evidence) => {
          // Create a citation from the evidence
          const newCitation: Citation = {
            id: `citation-${Date.now()}`,
            text: evidence.content.substring(0, 100) + '...',
            sourceId: evidence.sourceId,
            sourceTitle: evidence.sourceTitle,
            pageNumber: evidence.pageNumber
          }
          setCitations(prev => [...prev, newCitation])
          setEvidencePanelOpen(false)
        }}
      />

      {/* Keyboard Shortcuts Help */}
      <KeyboardShortcutsHelp
        isOpen={shortcutsHelpOpen}
        onClose={() => setShortcutsHelpOpen(false)}
      />
    </div>
  )
}
</file>

</files>
